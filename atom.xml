<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seven&#39;s Blog</title>
  <subtitle>Share, Learn, Enjoy, Keep</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sevencai.github.io/"/>
  <updated>2019-02-22T12:29:46.000Z</updated>
  <id>http://sevencai.github.io/</id>
  
  <author>
    <name>Seven Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack 编译目录原样输出及webpack4 treeshaking小结</title>
    <link href="http://sevencai.github.io/2019/02/22/webpack-%E7%BC%96%E8%AF%91%E7%9B%AE%E5%BD%95%E5%8E%9F%E6%A0%B7%E8%BE%93%E5%87%BA%E5%8F%8Awebpack4-treeshaking%E5%B0%8F%E7%BB%93/"/>
    <id>http://sevencai.github.io/2019/02/22/webpack-编译目录原样输出及webpack4-treeshaking小结/</id>
    <published>2019-02-22T12:16:03.000Z</published>
    <updated>2019-02-22T12:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要记录两点</p>
<ol>
<li><p>如何在webpack中编译一个文件夹中的文件并且按照【原目录】输出。</p>
</li>
<li><p>总结在webpack 中使用 treeshaking 的条件。</p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="webpack-编译文件目录并原样输出"><a href="#webpack-编译文件目录并原样输出" class="headerlink" title="webpack 编译文件目录并原样输出"></a>webpack 编译文件目录并原样输出</h2><p><strong>场景是需要编译一个文件夹下的所有js文件，并且把这些js文件都按照【原来的目录结构】输出。</strong></p>
<p>首先编译一个文件夹的所有js文件，比较好做。我们可以使用<code>glob</code>来获取目录下的所有js文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Webpack babel transform config  </span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: glob.sync(<span class="string">"./src/**/*.js"</span>),  </span><br><span class="line">  </span><br><span class="line">  mode: <span class="string">"production"</span>,  </span><br><span class="line">  </span><br><span class="line">  output: &#123;  </span><br><span class="line">	filename: <span class="string">'[name].js'</span>,  </span><br><span class="line">	path: path.resolve(__dirname, <span class="string">'./'</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="comment">// .....  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们像如上这么写，会直接输出一个 main.js 文件。也就是所有被编译的文件都会在同样的一个文件中输出。这不是我想要的，我想要的是【每个文件单独编译，并原样目录输出】。</p>
<p>查找了下 <code>webpack</code> 没有相关的配置, 如果我们要输出<code>module/a/index.js</code>在 <code>dist/module/a/</code>目录下。我们再写 entry 时就可以这么写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    <span class="string">'module/a/index'</span>: <span class="string">'module/a/index.js'</span>,</span><br><span class="line">    <span class="string">'module/b/index'</span>: <span class="string">'module/b/index.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以为了动态去输出到相应的目录，我们只需要去找到对应的entry即可。比如我们想要原样输出编译后的 src 目录下的文件, 先用 正则匹配到 对应的路径。然后再映射到entry上即可。主要是实现：<br><code>./src/lib/a.js =&gt; ./lib/a.js</code>的map。简单点的demo可能如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)  </span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)  </span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)  </span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all file entries  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntries</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;  </span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(<span class="string">"./src/**/*.js"</span>)  </span><br><span class="line">  </span><br><span class="line">  entryFiles.forEach(<span class="function"><span class="params">filepath</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> fileDir = <span class="regexp">/.\/src\/(.*?)\.js/</span>.exec(filepath)  </span><br><span class="line">  </span><br><span class="line">    map[fileDir[<span class="number">1</span>]] = filepath  </span><br><span class="line">  &#125;)  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> map  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Webpack babel transform config  </span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: getEntries(),  </span><br><span class="line">  </span><br><span class="line">  mode: <span class="string">"production"</span>,  </span><br><span class="line">  </span><br><span class="line">  output: &#123;  </span><br><span class="line">    filename: <span class="string">'[name].js'</span>,  </span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./'</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;  </span><br><span class="line">    rules: [  </span><br><span class="line">      &#123;  </span><br><span class="line">        test: <span class="regexp">/\.js/</span>,  </span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,  </span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">    ]  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  plugins: [  </span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'lib'</span>]),  </span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;)  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="webpack-的-treeshaking-条件"><a href="#webpack-的-treeshaking-条件" class="headerlink" title="webpack 的 treeshaking 条件"></a>webpack 的 treeshaking 条件</h2><p>webpack2 的 treeshaking 一般我们经常会用到。最近有浏览了类似的文章，总结下（下面是使用webpack4的相关配置）：</p>
<p><img src="treeshaking.png" alt="文档截图"></p>
<p>也就是说必须得</p>
<p>使用 treeshake 减少文件体积的4个条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   使用 ES2015 模块语法（即  `import`  和  `export`）。</span><br><span class="line">-   在项目  `package.json`  文件中，添加一个 &quot;sideEffects&quot; 属性。</span><br><span class="line">-   不能把 ES6 模块用 babel 先转换成 CommonJs, 在`@babel/preset-env`中，这是个默认行为，需要设置 `module: false`禁用掉。先编译成 CommonJs 后webpack就无法分析依赖了。</span><br><span class="line">-   webpack4中设置 mode: production，自动开启压缩, 如果是非webpack4,则需要引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如  `UglifyJSPlugin`）。</span><br></pre></td></tr></table></figure>
<p>设置 module 为 false 的原因引用如下：</p>
<blockquote>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a><code>modules</code></h3><p><code>&quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false</code>, defaults to  <code>&quot;auto&quot;</code>.<br>Enable transformation of ES6 module syntax to another module type.<br>Setting this to  <code>false</code>  will not transform modules.</p>
</blockquote>
<p>错误示范：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exports.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)    </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line">exports.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./a.js'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，需要用 import ,export ES6语法 才能 treeshake</span></span><br><span class="line">api.a()</span><br></pre></td></tr></table></figure></p>
<p>正确示范：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'b'</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>  </span><br><span class="line">a()</span><br></pre></td></tr></table></figure></p>
<p>简单点的示例demo:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js  </span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)  </span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)  </span><br><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: <span class="string">'./test.mjs'</span>,  </span><br><span class="line">  </span><br><span class="line">  mode: <span class="string">"production"</span>,  </span><br><span class="line">  </span><br><span class="line">  output: &#123;  </span><br><span class="line">    filename: <span class="string">'index.js'</span>,  </span><br><span class="line">	path: path.resolve(__dirname, <span class="string">'./dist'</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">module</span>: &#123;  </span><br><span class="line">    rules: [  </span><br><span class="line">      &#123;  </span><br><span class="line">        test: <span class="regexp">/\.js/</span>,  </span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,  </span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">    ]  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当 mode 为 development 时，需要开启下面的代码。</span></span><br><span class="line">  <span class="comment">// 当 mode 为 production 时，不需要</span></span><br><span class="line">  optimization: &#123;  </span><br><span class="line">    minimizer: [  </span><br><span class="line">      <span class="keyword">new</span> UglifyJSPlugin(&#123;  </span><br><span class="line">        uglifyOptions: &#123;  </span><br><span class="line">          compress: &#123;  </span><br><span class="line">            warnings: <span class="literal">true</span>  </span><br><span class="line">          &#125;,  </span><br><span class="line">          output: &#123;  </span><br><span class="line">            comments: <span class="literal">false</span>  </span><br><span class="line">          &#125;,  </span><br><span class="line">          sourceMap: <span class="literal">true</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;)  </span><br><span class="line">    ]  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  plugins: [  </span><br><span class="line">    <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;  </span><br><span class="line">      minimize: <span class="literal">true</span>,  </span><br><span class="line">      debug: <span class="literal">false</span>  </span><br><span class="line">  &#125;),  </span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;)  </span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="sideEffects怎么理解？"><a href="#sideEffects怎么理解？" class="headerlink" title="sideEffects怎么理解？"></a>sideEffects怎么理解？</h2><p>sideEffects 这个估计再花一个文章也讲不完。大概的表达下是：</p>
<p>很多时候在转换代码后，我们的代码会由于被编译而产生副作用，比如你对一个函数使用了 location.href 或者 window 上加了东西，即使你没有真的使用这个模块，这个模块也会被打包进到dist里去。</p>
<p>所以如果你真的想去除那些完全没有被引用到的，即使有副作用的包：<strong>就应该把这些 包/模块 被标记为 <code>sideEffects: false</code> 了，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除。</strong></p>
<p>举个我看到的很好的例子，例子原本出于文章<a href="https://juejin.im/post/5b4ff9ece51d45190c18bb65" target="_blank" rel="noopener"># Webpack 中的 sideEffects 到底该怎么用？</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import DevTools from &apos;mobx-react-devtools&apos;;</span><br><span class="line"></span><br><span class="line">class MyApp extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        ...</span><br><span class="line">        &#123; process.env.NODE_ENV === &apos;production&apos; ? null : &lt;DevTools /&gt; &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你不在webpack4中设置 <code>sideEffects: false</code>， 那么即使 <code>NODE_ENV=production</code>, <code>mobx-react-devtools</code>也会被引入。</p>
<p>所以<strong>如果我们能确定或者想让这个包不对包以外的对象造成影响，那么我们就完全的可以放心设置这个参数了</strong>。</p>
<p>关于 副作用，推荐一篇文章<a href="https://zhuanlan.zhihu.com/p/32831172" target="_blank" rel="noopener">你的Tree-Shaking并没什么卵用
</a>, 也方便自己后续查阅。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近主要是想对组里的一些包做优化，做优化的过程中解决了一些问题，也带来了一些新的疑惑。疑惑还没解决，所以还不能总结成文章。虽然不是纠结上面的东西，但也算是纠结了好几天了。(ಥ _ ಥ)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要记录两点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何在webpack中编译一个文件夹中的文件并且按照【原目录】输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;总结在webpack 中使用 treeshaking 的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="工具/配置" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>2018年度总结</title>
    <link href="http://sevencai.github.io/2018/12/31/2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://sevencai.github.io/2018/12/31/2018年度总结/</id>
    <published>2018-12-31T09:44:03.000Z</published>
    <updated>2018-12-31T03:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年已经是过去</p>
<p>小时候印象最深的一年是2008年</p>
<p>那一年开了运动会</p>
<p>那一年跟爸爸去了北京</p>
<p>那一年妈妈40岁</p>
<p>那一年我13岁</p>
<p>那一年下了大雪</p>
<p>那一年汶川地震</p>
<p>转眼间10年就过去了，10年，我长大了</p>
<p>那个胆小的我，变了敢于承担的我</p>
<p>那个问爸爸妈妈要钱的我，变成了给爸爸妈妈买东西的我</p>
<p>那个学生，变成了社会人</p>
<p>那个一个人，现在多了一个人和一个狗</p>
<p>多数时候我开心快乐，但是也有时候心情低落，崩溃大哭</p>
<p>我热爱我的工作，但也有时开始会想怎么能少加班</p>
<p>我赚了钱，但是也没有存一分钱，过着不亏待自己和家人的日子</p>
<p>我变了很多，不变的是我还是那个小胖子，我甚至已经会说俏皮话</p>
<p>我爱我的家人，爱我的妈妈，但总觉得自己亏欠她</p>
<p>我虽然每天跟她打电话，但是她总是跟我隐瞒她的心事</p>
<p>工作中遇到过不顺的时候，今年双十一那个星期，那一天，我觉得是我人生中最难过的一天</p>
<p>我不够强大</p>
<p>我今天去了日本，重庆，阳江，世界很大，我也在努力去看看，迈的步子不大，但在前进</p>
<p>我今年工作1年半了。算上实习2年半了</p>
<p>我依旧不化妆，甚至还长胖了5斤</p>
<p>一直在努力想着改变，但有时候很讨厌自己为什么不是那个坚持不懈的人</p>
<p>工作上觉得自己有进步，但是还有很多不足，清晰可见</p>
<p>我做了一些有意义的事情，比如帮助流浪狗，学习急救知识</p>
<p>也做了一些工作上可以节省劳动力的功能，虽然不是 KPI，但是我做的很开心</p>
<p>我有一次连续一个星期熬夜，就睡几个小时的时候的经历</p>
<p>大姨妈还是一样的痛的我想跳楼</p>
<p>我很爱我的小狗狗，但是它好像不太爱我，总咬我的衣服</p>
<p>大龙很棒，生病有点多</p>
<p>我们开始一起会思考未来的职业发展</p>
<p>也有任性的时候，一起哭的时候，一起生病的时候</p>
<p>他经历了一个月的低谷期，不过他很棒，很快就调整过来</p>
<p>迷茫的时候，我会休息一天，调整一天</p>
<p>我开始了每天阅读英语，但是也有漏天的时候</p>
<p>18年，我出了一次车祸，我现在还很清晰的记得那个时刻</p>
<p>过好每一天很重要，因为人生真的不可预测</p>
<p>刚刚跟组里去吃了个饭，今年饭局很多，很开心</p>
<p>今年组里还来了一个妹子，我觉得这是我春天的开始</p>
<p>我写了很多总结今年，但是还是没有勇气发到公司 KM 上</p>
<p>我今年有进步，有认真工作，也有忽然不想干的时候</p>
<p>那些迷茫的时候，我想为什么会有人愿意每天上12小时的班</p>
<p>那些认真工作的时候，我想不写代码真的可惜了</p>
<p>有的时候觉得自己是个胆小鬼</p>
<p>我享受每次写一段很好的代码的时候，享受每次写 created by sevencai 的时候</p>
<p>我在一天天的长大</p>
<p>妈妈在一天天的变老</p>
<p>19年的时候，我就24了</p>
<p>也许今年能存点钱，能圆老妈的门面梦</p>
<p>希望对 PHP,Nodejs 更加深学习</p>
<p>我现在对他们只停留在能做出来东西上（工程上），虽然对一般的工作来说够用了，但更深层次的东西并没有仔细学习过，并且遇到问花费的时间也会多些</p>
<p>也许今年能瘦下来，改掉不剩饭，非要把自己吃撑的坏毛病</p>
<p>也许今年能够工作顺利，明年这个时候，觉得自己又进步了非常多</p>
<p>也许家里人身体都健康，希望身边的人都幸福开心</p>
<p>也许我的愿望19年都会成真</p>
<p>也许我能多读点书</p>
<p>也许我能改变懒惰</p>
<p>也许我真的能坚持下来做一件事情</p>
<p>也许我能变得更加有效率，少加点班</p>
<p>只要有心，从自己开始做出改变，从心里由衷的善良和开朗，坚持和耐心，未来可期，我也相信自己，因为18年已经迈出了一小步了，不是吗</p>
<p>嗯，今天是2018的最后一天，天气很冷</p>
<p>2019，我准备好了，你来吧，嘻嘻🌹</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年已经是过去&lt;/p&gt;
&lt;p&gt;小时候印象最深的一年是2008年&lt;/p&gt;
&lt;p&gt;那一年开了运动会&lt;/p&gt;
&lt;p&gt;那一年跟爸爸去了北京&lt;/p&gt;
&lt;p&gt;那一年妈妈40岁&lt;/p&gt;
&lt;p&gt;那一年我13岁&lt;/p&gt;
&lt;p&gt;那一年下了大雪&lt;/p&gt;
&lt;p&gt;那一年汶川地震&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://sevencai.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>import or require?</title>
    <link href="http://sevencai.github.io/2018/12/05/import-or-require/"/>
    <id>http://sevencai.github.io/2018/12/05/import-or-require/</id>
    <published>2018-12-05T13:25:18.000Z</published>
    <updated>2018-12-05T07:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>之所以会去写这个，是因为自己最近遇到了 import 的一个问题。</p>
<p>找问题的过称中，发现自己虽然一直在用 import，但对 require/import 的区别并没有了解的很全面。</p>
<p>具体的点就在 <code>Imports are hoisted</code>。趁此机会大概的重新总结下。</p>
<hr>
<h2 id="历史追溯"><a href="#历史追溯" class="headerlink" title="历史追溯"></a>历史追溯</h2><blockquote>
<p>了解历史，不一定是使用历史，却可以对整体的知识有个大致的认识。我自己没有经历过 <code>SeaJS/RequireJS</code> 时代，所以对它里面具体的原理实现和用法不是特别熟悉。只是看到组里以前同事的旧代码，才发现那几年确实可能很火。</p>
</blockquote>
<p>关于 CommonJS, RequireJS, SeaJS , 我大致的画了如下一个图来描述：</p>
<p><img src="understandstandard.png" alt="关系图"></p>
<p>总结为下面几点：</p>
<ol>
<li><code>CommonJS</code> 因 <code>Nodejs</code> 而生，是 <strong><code>Nodejs 的规范</code></strong>，一直沿用至今。</li>
<li>由于浏览器端也需要模块化的原因，由 <code>CommonJS</code> 衍生出来了 AMD 和 CMD 规范。</li>
<li>基于 AMD/CMD 规范，出现了两个基于此规范的库。分别是 <code>RequireJS</code>, <code>SeaJS</code>。</li>
<li><code>RequireJS</code> 是 AMD 的规范。特点是：<strong>提前加载</strong>。</li>
<li><code>SeaJS</code> 是 CMD 的规范。特点是：按需加载。<strong>用到时才加载</strong>。</li>
<li>现在新的标准 <code>ES6 import/export</code> 出现，但是很多浏览器还未实现，所以最终还是需要用 <strong>babel 转换成 CommonJS</strong>。</li>
<li><code>import/export</code> 是大势所趋。</li>
</ol>
<p>具体的想看 AMD/CMD 的区别，可以参考 16 年我总结的文件。<a href="https://sevencai.github.io/2016/02/18/AMD%E5%92%8CCMD%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/">AMD和CMD的区别和联系</a>。</p>
<hr>
<h2 id="import-require-区别-Commonjs-pk-ES6"><a href="#import-require-区别-Commonjs-pk-ES6" class="headerlink" title="import / require 区别 (Commonjs pk ES6)"></a>import / require 区别 (Commonjs pk ES6)</h2><p><img src="requireimport.png" alt="require pk import"></p>
<h3 id="写法不同"><a href="#写法不同" class="headerlink" title="写法不同"></a>写法不同</h3><p>CommonJS 的模块化，require/exports 基本上只有下面这几种写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">exports.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line">fs.readFileSync(path)</span><br></pre></td></tr></table></figure></p>
<p>import 的写法多种多样，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cookie <span class="keyword">from</span> <span class="string">'./cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; getCookie, setCookie &#125; <span class="keyword">from</span> <span class="string">'./cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cookie, &#123; getCookie &#125; <span class="keyword">from</span> <span class="string">'./cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两者相同</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cookie &#125; <span class="keyword">from</span> <span class="string">'./cookie'</span></span><br><span class="line"><span class="keyword">import</span> cookie <span class="keyword">from</span> <span class="string">'./cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> cookie</span><br><span class="line"><span class="keyword">export</span> cookie</span><br><span class="line"><span class="keyword">export</span> &#123; getCookie, setCookie &#125;</span><br></pre></td></tr></table></figure></p>
<p>等等写法。 import 比较灵活，并且支持部分模块的导入。不像 require 全部导入。</p>
<h3 id="加载顺序不同-Imports-are-hoisted"><a href="#加载顺序不同-Imports-are-hoisted" class="headerlink" title="加载顺序不同 - Imports are hoisted"></a>加载顺序不同 - Imports are hoisted</h3><p>ES6 模块是编译时加载，使得静态分析成为可能。</p>
<p>import 会提前加载，类似于 JS 里的概念 变量提升。也就可以理解为 import 总被先移到上面去执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in config'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">port</span>: <span class="number">80</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'begin load'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'load finished'</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行 main.js 将返回：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> config</span><br><span class="line">begin load</span><br><span class="line">load finished</span><br></pre></td></tr></table></figure></p>
<p>也就是说这么写不会报错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderData()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; renderData &#125; <span class="keyword">from</span> <span class="string">'../util'</span></span><br></pre></td></tr></table></figure></p>
<p>但是这么写会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">if (x === true) &#123;</span><br><span class="line">  import MyModual from &apos;./myModual&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import x+var from &apos;./&apos; + filename</span><br></pre></td></tr></table></figure></p>
<p>import 是在编译时，if 这些语句都会被忽略，会被提到最上面。因此会报语法错误，而不是执行的错误。所以import export 最好就放在最顶层。不要在函数或者条件语句中。</p>
<p>require 是非静态编译类型。是 CommonsJS 这种，运行时加载,所以可以动态去拼接模块。</p>
<p>对于Require来说运行结果就是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'in config'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">port</span>: <span class="number">80</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'begin load'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./config.mjs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'load finished'</span>)</span><br></pre></td></tr></table></figure></p>
<p>得到的结果，跟我们的预期相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin load</span><br><span class="line">in config</span><br><span class="line">load finished</span><br></pre></td></tr></table></figure></p>
<h3 id="Imports-只可读-Imports-are-read-only-views-on-exports"><a href="#Imports-只可读-Imports-are-read-only-views-on-exports" class="headerlink" title="Imports 只可读 - Imports are read-only views on exports"></a>Imports 只可读 - Imports are read-only views on exports</h3><p>这点可以阅读这个文档：<a href="http://exploringjs.com/es6/ch_modules.html#sec_imports-as-views-on-exports" target="_blank" rel="noopener">讲的很清楚</a>。看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./counter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The imported value `counter` is live</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>上面这种是ok的，但是下面这种是不合法的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./counter'</span>;</span><br><span class="line"></span><br><span class="line">counter++ <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note that while you can’t change the values of imports, you can change the objects that they are referring to. For example:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>这点我们可以理解为，变量的地址是不能改变的，重新赋值时，变量的地址变了，这个不允许，但是你如果改变对象的里面属性的值，地址是不变的。</p>
<p>这个就像你声明一个 const obj, 也可以更改 Obj.value 一样。</p>
<p>Require 不同，你可以修改里面的内容。</p>
<p>推荐文章： <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ruanyifeng-es6-module</a></p>
<h3 id="值引用-or-值拷贝"><a href="#值引用-or-值拷贝" class="headerlink" title="值引用 or 值拷贝"></a>值引用 or 值拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'increase count to'</span>, ++count, <span class="string">'in counter.js after 500ms'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">'./counter.mjs'</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'read count after 1000ms in es6 is'</span>, count)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">increase count to 1 in counter.js after 500ms</span><br><span class="line">read count after 1000ms in es6 is 1</span><br></pre></td></tr></table></figure></p>
<p>另外一段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line">exports.count = <span class="number">0</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'increase count to'</span>, ++exports.count, <span class="string">'in counter.js after 500ms'</span>)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;count&#125; = <span class="built_in">require</span>(<span class="string">'./counter'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'read count after 1000ms in commonjs is'</span>, count)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>得到的结果是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">increase count to <span class="number">1</span> <span class="keyword">in</span> counter.js after <span class="number">500</span>ms</span><br><span class="line">read count after <span class="number">1000</span>ms <span class="keyword">in</span> commonjs is <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>大概的意思其实就是：<strong>CommonJS模块是运行输出(加载)一个值(或对象)的拷贝，而ES6模块则是编译时输出(加载)一个值的引用(或者叫做连接).</strong></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本地测试 import 时可以使用 <strong><code>--experimental-modules</code> 实验模块标志来启用加载 <code>ECMAScript Modules</code> 的特性</strong>。</p>
<p>作为ES模块加载的文件名，须以.mjs后缀结尾</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node --experimental-modules app.mjs</span><br><span class="line"></span><br><span class="line">// 此种方法，在输出的时候会提示：</span><br><span class="line">(node:6527) ExperimentalWarning: The ESM module loader is experimental.</span><br></pre></td></tr></table></figure>
<p>线上环境还是用 babel 去转 ~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之所以会去写这个，是因为自己最近遇到了 import 的一个问题。&lt;/p&gt;
&lt;p&gt;找问题的过称中，发现自己虽然一直在用 import，但对 require/import 的区别并没有了解的很全面。&lt;/p&gt;
&lt;p&gt;具体的点就在 &lt;code&gt;Imports are hoiste
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>async await 做了什么事情</title>
    <link href="http://sevencai.github.io/2018/12/03/async-await-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85/"/>
    <id>http://sevencai.github.io/2018/12/03/async-await-做了什么事情/</id>
    <published>2018-12-03T13:10:02.000Z</published>
    <updated>2018-12-04T04:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>组里的一个有趣又很严谨的同事，今天在纠结一个不看起来是问题的问题，其实这种感觉就像你经常这么用或者这么想的一个东西，某一天某个时刻，你突然不知道为什么了，就像我偶尔会去纠结为什么某个汉字是这样写：</p>
<p><img src="testasyncawait.png" alt="问题"></p>
<p>他认为最后应该 res === b,而不是 res === a, 我认为很明显应该 res === a, 因为大家平时一直都是这么用的, 但是跟他讲理由的时候，竟然语塞了。</p>
<hr>
<h2 id="关于-async-🚶"><a href="#关于-async-🚶" class="headerlink" title="关于 async 🚶"></a>关于 async 🚶</h2><p>于是我去找了一段 MDN 上的解释：</p>
<blockquote>
<p>当调用一个 async 函数时，<strong>会返回一个 Promise 对象</strong>。当这个 async 函数返回一个值时，<strong>Promise 的 resolve 方法会负责传递这个值</strong>；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。</p>
</blockquote>
<p>上面这句话我用两个粗体标明了两句话，第一句话意思明显，意为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用 test() 得到的是一个 Promise, 也就是无论函数内返回（return）的是什么（常量 or 字符串 or Promise or 其它）， async 总会用 <code>Promise.resolve</code> 包一层，如若 async 里面有异常， 会 <code>throw Error</code>。</strong></p>
<p><strong>如果 test 内什么都不返回，也会得到 <code>Promise.resolve(undefined)</code>, 总之 async 总返回一个 Promise 对象。</strong></p>
<p>再看后面一句解释： Promise 的 resolve 方法会负责传递这个值；</p>
<p>哇，是不是突然间觉得我同事疑惑的是对的了。其实不要受这句话的影响。它说的传递，其实就是return过去的时候是传递的。总结下： 我们就理解为：async 返回了一个包含改值的 Promise。</p>
<p>分析下面这段代码的执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test()</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res === a)</span><br><span class="line">    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么为什么 <code>test().then(a =&gt; { a === {} })</code> 又是对的了呢？ 不是说返回了一个 Promise 吗？ 怎么又是一个对象值了？(注意这里是值引用，所以可以直接这么比较)</p>
<p><strong>这是因为 <code>Promise.then</code> 里面会在重新接收这个值的时候，得到的不再是一个 Promise 对象，而是一个被解析过了的值</strong>。 也就是说下面这段代码的含义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个 Promise ，内容为 statusCode 404</span></span><br><span class="line">    <span class="keyword">return</span> getServerStatusCode(r);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// res 为一个对象，不是一个 Promise, 因为已经被解析过了</span></span><br><span class="line">    <span class="built_in">console</span>.log(res.statusCode);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个时候，你 then 里面的值，就跟你用 await 得到的一样了。</p>
<hr>
<h2 id="关于-await-👂"><a href="#关于-await-👂" class="headerlink" title="关于 await 👂"></a>关于 await 👂</h2><p>await 等待的是什么呢？</p>
<blockquote>
<p>await  操作符用于等待一个Promise 对象。它只能在异步函数 <code>async function</code> 中使用。</p>
</blockquote>
<p>上面是 MDN 里的说明，我觉得不太对， await 不一定是等待一个 Promise 对象，它要等待的是<strong>一个 Promise 对象或者任何要等待的值。</strong>。</p>
<p>如果它等待的不是一个 Promise 对象，如 await 3 , 那么表达式的运算结果就是它等待的东西。</p>
<p>如果它等待的是一个 Promise 对象， 如 <code>await Promise.resolve(3)</code>, 那么 await 会阻塞后面的代码，等待 Promise 对象 <code>resolve or reject</code>。</p>
<p>看下下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Promise</span>.reject(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> a &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = <span class="keyword">await</span> abc()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"err"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"main"</span>, obj === a) <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>, obj === &#123;&#125;) <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj) <span class="comment">// null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj) === <span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>很明显， obj 是等于 null 的，因为 await 等待的是一个 reject 的结果。导致了异常被抛出来了。所以赋值等工作都没有进行。</p>
<blockquote>
<p>await 表达式会暂停当前 <code>async function</code> 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <code>async function</code>。</p>
<p>若 Promise 处理异常(rejected)，await 表达式会把 Promise 的<strong>异常原因抛出</strong>。</p>
<p>另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</p>
</blockquote>
<p>MDN 的解释跟我们理解的相同。也就是说 <strong>await 如果得到的是一个 reject 的结果，会直接 throw 一个 Error 出来。这也是为什么为了避免报错，我们需要对 <code>async await</code> 进行 <code>try catch</code> 的原因</strong>。</p>
<hr>
<h2 id="使用-async-await-要注意的地方"><a href="#使用-async-await-要注意的地方" class="headerlink" title="使用 async await 要注意的地方"></a>使用 async await 要注意的地方</h2><p>async await 设计本身是为了让我们防止地狱回调的，但是是不能够滥用。比如下面这个很经典的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizza = <span class="keyword">await</span> selectPizza()</span><br><span class="line">  <span class="keyword">const</span> drink = <span class="keyword">await</span> selectDrink()</span><br><span class="line"></span><br><span class="line">  order(pizza, drink); <span class="comment">// async call</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>上面的 <code>getPizzaInfo</code> 和 <code>getDrinkInfo</code> 实际并没有任何依赖关系，这么写还增加了等待的时间。所以在用 async await 的时候，一定要充分理解他们的关系。可以优化如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaPromise = selectPizza();</span><br><span class="line">  <span class="keyword">const</span> drinkPromise = selectDrink();</span><br><span class="line">  <span class="keyword">const</span> pizza = <span class="keyword">await</span> pizzaPromise;</span><br><span class="line">  <span class="keyword">const</span> drink = <span class="keyword">await</span> drinkPromise;</span><br><span class="line">  order(pizza, drink); <span class="comment">// async call</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.all([selectPizza(), selectDrink()]).then(order); <span class="comment">// async call</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>再举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">c(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  d();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最后写成了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> a();</span><br><span class="line"><span class="keyword">await</span> b();</span><br><span class="line"><span class="keyword">await</span> c();</span><br><span class="line"><span class="keyword">await</span> d();</span><br></pre></td></tr></table></figure></p>
<p>这种原本 d 只需要等待 c 的，结果变成要等待 a,b,c。 时间慢了很多。性能不好。稍改一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aPromise = a()</span><br><span class="line"><span class="keyword">const</span> cPromise = c()</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> aPromise()</span><br><span class="line">b()</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> cPromise()</span><br><span class="line">d()</span><br></pre></td></tr></table></figure>
<p>这样会稍微好点了，但是还是有问题， d由原来的需要等待 c, 变成了需要等待 a,c(如果a的返回时间要大于c)</p>
<p>所以可以改成下面这两种方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span>() &#123;</span><br><span class="line">    <span class="keyword">await</span> a()</span><br><span class="line"></span><br><span class="line">    b()</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() &#123;</span><br><span class="line">    <span class="keyword">await</span> c()</span><br><span class="line"></span><br><span class="line">    d()</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者改为</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([a(), c()])</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([b(), d()])</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>总之用 async, await 的时候得多想想。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有好奇心和探索知识的欲望是好事，当别人问你的问题的时候，如果你不能把别人解释清楚的时候，那么可能他的问题同样就是你的问题~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组里的一个有趣又很严谨的同事，今天在纠结一个不看起来是问题的问题，其实这种感觉就像你经常这么用或者这么想的一个东西，某一天某个时刻，你突然不知道为什么了，就像我偶尔会去纠结为什么某个汉字是这样写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;testasyncawait.png&quot; a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>总结几个最近遇到的问题</title>
    <link href="http://sevencai.github.io/2018/11/27/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sevencai.github.io/2018/11/27/总结几个最近遇到的问题/</id>
    <published>2018-11-27T13:08:19.000Z</published>
    <updated>2018-11-27T13:19:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了些文章，遇到了写问题，花了点时间总结如下。</p>
<hr>
<h2 id="localhost-和-127-0-0-1"><a href="#localhost-和-127-0-0-1" class="headerlink" title="localhost 和 127.0.0.1"></a>localhost 和 127.0.0.1</h2><p>一般情况下，我们的电脑可能有<strong>三块网卡</strong>。分别是🌹：</p>
<ol>
<li>一块叫 loopback 的虚拟网卡</li>
<li>一块叫 ethernet 的有限网卡</li>
<li>一块叫 wlan 的无限网卡</li>
</ol>
<p>我们电脑的本机 IP ，可以理解为时真实网卡的 IP, 有限和无限分别有一个。是网络出口IP。</p>
<p>现在主要是了解下这个 虚拟的网卡 loopback 它是什么，以及它和 127.0.0.1 的关系。</p>
<p>127.0.0.1 到 127.255.255.255整个都是环回地址(loopback)，用来测试本机的TCP/IP协议栈，发往这段A类地址<strong>数据包不会出网卡，网络设备不会对其做路由</strong>, 也就是只在本地做回环访问，故只能本机访问。</p>
<p><strong>所以环回地址是主机用于向自身发送通信的一个特殊地址，是一个特殊的目的地址。因此如果一台主机上的两项服务如果使用的是环回地址而非分配的主机地址，就可以绕开 TCP/IP 协议栈的下层，不用再通过链路层，物理层，以太网等传出去。</strong></p>
<p><strong>而localhost 是一个 域名，一般指向 127.0.0.1， 实际上它也可以指向任何一个ip, 可以去系统文件中修改</strong>。</p>
<p>之所以去了解这个，其实是因为最近踩了下面个坑，顺带也去了解了下这个。</p>
<hr>
<h2 id="whistle-转发-header-host-被更改问题"><a href="#whistle-转发-header-host-被更改问题" class="headerlink" title="whistle 转发 header host 被更改问题"></a>whistle 转发 header host 被更改问题</h2><p>❎同事B为了在页面内 include 一个 php cgi 返回的 token, 希望能够在 apache 里面配置代理转发，当看到了这个include的 cgi 后，即转发到对应的 机器上。</p>
<p>她发现 php 的接口已经成功转发到测试机器上，但是返回的内容不正常，在帮她调试接口后，发现后台接口验证了 Valid Host, 而她的 host 还是本机的 localhost。</p>
<p>她相关的whistle 配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay.qq.com  localhost/wechat_h5/dist/h5/store/views/</span><br></pre></td></tr></table></figure></p>
<p>可以通过 pay.qq.com/index.shtml 直接访问到对应的本地页面。但是为什么 header 里面的 host 竟然不是 pay.qq.com 而是 localhost 呢？❌</p>
<p>这里是由于 whistle 导致的。</p>
<p>whistle 对于上面这种配置，<strong>会认为是一个 rule</strong>, 直接整个链接类似被 302 跳转了，导致了 header 里的 host 也被修改为了 localhost, 所以不能通过接口校验。</p>
<p>需要改成如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay.qq.com/wechat_h5/dist/h5/store/views/ localhost</span><br></pre></td></tr></table></figure></p>
<p>这种情况，<strong>whistle 会认为这是一个 host 代理， header 里面的内容不会受影响</strong>。</p>
<p>两种类似相似的写法，还是有不一样的效果，如果不是这种后台会验证 valid host 的情况，两种都可以用。</p>
<hr>
<h2 id="es6-promise-不支持-finally"><a href="#es6-promise-不支持-finally" class="headerlink" title="es6-promise 不支持 finally?"></a>es6-promise 不支持 finally?</h2><p><code>es6-promise</code> 是一个比较好的 <code>promise polyfill</code> 库 ，但是遗憾的是目前它还不支持 finally，如果用 <code>es6-promise</code> ，又想用 <code>finally</code> ，怎么办呢？可以简单的用 <code>then</code> 来代替 <code>finally</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">printPersonFullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'./data/person.json'</span>)</span><br><span class="line">           .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> response.json();</span><br><span class="line">           &#125;)</span><br><span class="line">           .then(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>);</span><br><span class="line">           &#125;)</span><br><span class="line">           .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">           .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">           &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这样最后一个 then 方法一定会进入，及时之前 catch 到了 error。可以简单的来替代 finally。</p>
<hr>
<h2 id="神奇的translate3d"><a href="#神奇的translate3d" class="headerlink" title="神奇的translate3d"></a>神奇的translate3d</h2><p><code>ios safari</code> 下，如果你经常用 <code>position: fixed</code>， 可能会遇到一些奇奇怪怪的问题，比如页面卡住，页面白屏等问题。</p>
<p>这时候你可以试试神奇的 translate3d, 它会触发 GPU 的重新加速。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Element-header</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0,0,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Element-header--fixed</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不太了解 CSS 的我，靠这个解决了很多问题。<a href="https://stanko.github.io/ios-safari-scroll-position-fixed/" target="_blank" rel="noopener">相关参考文章</a>。</p>
<p>建议是<code>safari</code>中能不用<code>fixed</code>就不用 <code>fixed</code>。</p>
<hr>
<h2 id="Promise-Anti-patterns"><a href="#Promise-Anti-patterns" class="headerlink" title="Promise Anti-patterns"></a>Promise Anti-patterns</h2><p>最近看了一篇文章，讲的不错，大概讲的就是说常见的一些错误的 Promise 用法。在这里记录下，供自己经常翻看。原文章地址在<a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="noopener">此。</a></p>
<h3 id="Nested-Promises"><a href="#Nested-Promises" class="headerlink" title="Nested Promises"></a>Nested Promises</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  loadAnotherthing().then(<span class="function"><span class="keyword">function</span>(<span class="params">another</span>) </span>&#123;</span><br><span class="line">    DoSomethingOnThem(something, another);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To fix:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.all([loadSomething(), loadAnotherThing()])</span><br><span class="line">    .spread(<span class="function"><span class="keyword">function</span>(<span class="params">something, another</span>) </span>&#123;</span><br><span class="line">        DoSomethingOnThem(something, another);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Broken-Chain"><a href="#The-Broken-Chain" class="headerlink" title="The Broken Chain"></a>The Broken Chain</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        somethingComplicated();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To Fixed:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = doSomethingAsync();</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        somethingComplicated()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Collection-Kerfuffle"><a href="#The-Collection-Kerfuffle" class="headerlink" title="The Collection Kerfuffle"></a>The Collection Kerfuffle</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resultArr = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_recursive</span>(<span class="params">idx</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= resultArr.length) <span class="keyword">return</span> resultArr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doSomethingAsync(arr[idx]).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            resultArr.push(res);</span><br><span class="line">            <span class="keyword">return</span> _recursive(idx + <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _recursive(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To fix, use map &amp; reduce:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.all(arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doSomethingAsync(item);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or you want them in series</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doSomethingAsyncWithResult(item, result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, q());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Ghost-Promise"><a href="#The-Ghost-Promise" class="headerlink" title="The Ghost Promise"></a>The Ghost Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise;</span><br><span class="line"><span class="keyword">if</span> (asyncCallNeeded)</span><br><span class="line">    promise = doSomethingAsync();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    promise = Q.resolve(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingCool();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To fix:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 Q 包一层</span></span><br><span class="line">Q(asyncCallNeeded ? doSomethingAsync() : <span class="number">42</span>)</span><br><span class="line">    .then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            doSomethingGood();</span><br><span class="line">        &#125;)</span><br><span class="line">    .catch(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            handleTheError();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Overly-Keen-Error-Handler"><a href="#The-Overly-Keen-Error-Handler" class="headerlink" title="The Overly Keen Error Handler"></a>The Overly Keen Error Handler</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somethingAsync.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> somethingElseAsync();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        handleMyError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To fix :<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免上面fufilled内的error不被 catch 到</span></span><br><span class="line">somethingAsync</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> somethingElseAsync();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        handleMyError(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Forgotten-Promise"><a href="#The-Forgotten-Promise" class="headerlink" title="The Forgotten Promise"></a>The Forgotten Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">doSomethingAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    res = manipulateMeInSomeWay(res);</span><br><span class="line">    deferred.resolve(res);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    deferred.reject(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> deferred.promise;</span><br></pre></td></tr></table></figure>
<p>To fix:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免上述无意义的创建 promise</span></span><br><span class="line"><span class="keyword">return</span> doSomethingAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> manipulateMeInSomeWay(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了一些文章，其实多看看这些总结类的文章，然后自己把自己工作中遇到的问题总结出来是个很好的事情，梳理了自己的脑袋瓜哈哈。 今天好累啊，可能是生病的原因，早点回家了。9点20。给老妈打个☎️，回去再看看书，遛遛狗🐩，完美😊~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了些文章，遇到了写问题，花了点时间总结如下。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;localhost-和-127-0-0-1&quot;&gt;&lt;a href=&quot;#localhost-和-127-0-0-1&quot; class=&quot;headerlink&quot; title=&quot;localhost 和 
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>记几个小知识点</title>
    <link href="http://sevencai.github.io/2018/11/20/%E8%AE%B0%E5%87%A0%E4%B8%AA%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://sevencai.github.io/2018/11/20/记几个小知识点/</id>
    <published>2018-11-20T13:14:33.000Z</published>
    <updated>2018-11-20T13:21:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>好久都没有更新博客了，之前经历了疯狂的一段加班时间，收获了下面一句话，对我来说很珍贵的经验。📒</p>
<p><strong>再短也要记得思考，再忙也要记得时不时停下来，不慌不忙一步步走稳</strong>~📚</p>
</blockquote>
<hr>
<h2 id="在-url-上增加参数"><a href="#在-url-上增加参数" class="headerlink" title="在 url 上增加参数"></a>在 url 上增加参数</h2><p>下面这段是一段给 url 增加参数的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 url 上添加参数</span></span><br><span class="line"><span class="comment"> * @param arr  Array or Object</span></span><br><span class="line"><span class="comment"> * @param url</span></span><br><span class="line"><span class="comment"> * @return &#123;string|*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addParam</span>(<span class="params">arr, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> names = <span class="built_in">Object</span>.keys(arr)</span><br><span class="line">  <span class="keyword">var</span> postfix = serializeParams(arr)</span><br><span class="line"></span><br><span class="line">  url = delParam(names, url)</span><br><span class="line">  url += <span class="regexp">/(\?|&amp;)$/</span>.test(url) ? <span class="string">""</span> + postfix : <span class="regexp">/\?/</span>.test(url) ? <span class="string">"&amp;"</span> + postfix : <span class="string">"?"</span> + postfix</span><br><span class="line">  <span class="keyword">return</span> url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除去写法问题，逻辑上能看出有什么问题吗❌？</p>
<p>它只支持不带 hash 的增加参数，对于带 hash 的url, 它基本不能使用。因为这个方法已经被其他人使用，为了最小的改动性，可以在上面再封装一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addHashParam</span>(<span class="params">arr, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prefix, suffix] = url.split(<span class="string">"#"</span>)</span><br><span class="line">  <span class="keyword">let</span> addedUrl = addParam(arr, prefix)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> [addedUrl, <span class="string">"#"</span>, suffix].join(<span class="string">""</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addedUrl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的 split 一下，再对 hash 之前的进行 addParam, 最后再拼接回去即可。</p>
<hr>
<h2 id="chrome-breakpoints"><a href="#chrome-breakpoints" class="headerlink" title="chrome breakpoints"></a>chrome breakpoints</h2><p>今天又把 chrome 的 <a href="https://developers.google.com/web/tools/chrome-devtools/javascript/breakpoints?hl=zh-cn" target="_blank" rel="noopener">breakpoints 的文档</a>瞟了一遍。希望自己能把下面这个图记清楚：</p>
<p><img src="chromebreakpoint.png" alt="Overview of when to use each breakpoint type"></p>
<p>平时还是得刻意有意的去使用不同的类型断点形式，这样才不会如果突然事件很紧发现问题时，手忙脚乱。</p>
<p>比如上面这些断点类型中， <code>Line-of-code</code>，<code>Conditional line-of-code</code>，<code>Exception</code> 用的比较多，其他几个如 <code>DOM</code>, <code>Xhr</code>, <code>Function</code> 用的比较📒少。</p>
<hr>
<h2 id="关于网络的小知识"><a href="#关于网络的小知识" class="headerlink" title="关于网络的小知识"></a>关于网络的小知识</h2><p>最近公司的网络部分打通了，对于 mac pro 而言，以前非常不好真机调试，现在非常方便了我们。去了解了下这里面的工作。</p>
<blockquote>
<p>同一网段：要判断两个IP地址是不是在同一个网段，就将它们的IP地址分别与<strong>子网掩码</strong>做<strong>与运算</strong>，得到的结果一网络号，如果网络号相同，就在同一子网，否则，不在同一子网。</p>
<p>一般情况下，如果两个设备的 IP 地址前三位都是一样的话，就算是位于同一网段。</p>
</blockquote>
<p>抓包或者真机调试需要电脑和手机在同一网段下。 现在由于网络打通，都在同一局域网内，直接手机上配置代理，连接电脑相应的端口即可。一般我们为了抓包，电脑上会装 fiddler or charles or whistle, 我这里使用 whistle 开启了一个新端口，手机就连这个端口即可抓包。</p>
<p>原先由于我们的手机和电脑不是同一个网络，所以才需要软AP如 小米 WIFI 这种东西去使手机和电脑在同一个网络里，进行抓包。</p>
<p>这里出来了一个新词，叫做 <strong>软AP</strong>。</p>
<p>软AP指的是：<strong>“软AP”的无线产品在市场上颇为常见，软AP就是Soft-AP，它的硬件部分就是一块标准的无线网卡，但其通过驱动程序使其提供与AP一样的信号转接、路由等功能</strong>。与传统AP相比，它的成本很低，功能上也能凑合。</p>
<p>简单的理解话<strong>AP 就是 AccessPoint ,是无限访问热点的简称，无限路由器可以称为 AP, 软AP 则是用软件和无线王卡结合模拟出来的</strong>。</p>
<p>是否需要这个软AP跟我们的网络有关系。若电脑和手机处于一个网段，就不需要软AP创建WIFI网络。若不在一个网络，就需要用到软AP软件。比如你的电脑是连的自家的WIFI,你的手机是4G网络。或者你的电脑是有限网络，手机是无线网络，那么很有可能就不在一个网段上。</p>
<blockquote>
<p>在同一个局域网内是可以相互连接到对方的广播的，也可以冒认接收端来截取数据。或者混乱arp数据包，进行全部抓取。那么如何将mac和iPhone连接到同一个局域网呢？方法一，将两个设备都连接一个wifi路由器；方法二，将mac连接以太网，然后在 系统偏好设置——共享 中设置共享以太网来源的连接，然后用wifi端口共享给电脑（手机）。然后再将手机去连接电脑发散出的wifi。</p>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要对未来有信心，要对自己做的事情写的代码抱有信念，要跟随自己的心。（不是对别人的鸡汤，是对自己的鼓励，加油）🌹</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好久都没有更新博客了，之前经历了疯狂的一段加班时间，收获了下面一句话，对我来说很珍贵的经验。📒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再短也要记得思考，再忙也要记得时不时停下来，不慌不忙一步步走稳&lt;/strong&gt;~📚&lt;/p&gt;
&lt;/blockquote
    
    </summary>
    
    
      <category term="笔记" scheme="http://sevencai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记几个小问题</title>
    <link href="http://sevencai.github.io/2018/08/31/%E8%AE%B0%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://sevencai.github.io/2018/08/31/记几个小问题/</id>
    <published>2018-08-31T13:06:47.000Z</published>
    <updated>2018-08-31T13:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="swiper-v-for-中-click-不生效"><a href="#swiper-v-for-中-click-不生效" class="headerlink" title="swiper v-for 中 click 不生效"></a>swiper v-for 中 click 不生效</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper-slide</span><br><span class="line">	v-<span class="keyword">for</span>=<span class="string">"(item, index) in bannerAds"</span></span><br><span class="line">	v-bind:key=<span class="string">"index"</span></span><br><span class="line">	@click.native=<span class="string">"linkAds(item)"</span></span><br><span class="line">	:style=<span class="string">"'background-image:url('+ item.url +')'"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/swiper-slide&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你的 swiper 也是使用了 v-for 并且 click 作用在 v-for 所在的元素，那么有可能会导致 click 事件不会执行。这时候试试在用 <code>@click.native</code> 可解决问题。</p>
<p>类似的问题还有 <code>router-link</code> 上加 click 也不生效。方法相同。</p>
<p>一般是自己定义的组件，或者 vue 自定义的标签，如上面的 <code>router-link</code>会有这个问题。</p>
<p>可以理解为，<strong><code>.native</code> 修饰符就是用来注册元素的原生事件而不是组件自定义事件的。是把组件变回原生DOM的一种方式，相当于给组件绑定原生事件。对原生html标签无用。</strong>因为本身Vue是有自己的一套进行传递的机制，这样告诉了Vue,用原生的事件，而不是Vue自己的那一套事件触发机制。</p>
<hr>
<h2 id="对象的-filter"><a href="#对象的-filter" class="headerlink" title="对象的 filter"></a>对象的 filter</h2><p>一般我们会很习惯去用 arr.filter 去帮我们做一些过滤的事情，那么如果是想要给 object map 做一些过滤的事情，我们可以像下面这样封装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 对象过滤器</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param filterFunction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">objectFilter</span>(<span class="params">obj, filterFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    ...Object.keys(obj)</span><br><span class="line">      .filter(<span class="function"><span class="params">key</span> =&gt;</span> filterFunction(obj[key]))</span><br><span class="line">      .map(<span class="function"><span class="params">key</span> =&gt;</span> (&#123; [key]: obj[key] &#125;))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象过滤器</span></span><br><span class="line"><span class="comment"> * arr.reduce(callback[, initialValue])</span></span><br><span class="line"><span class="comment"> * callback(accumulator, currentValue, currentIndex, array)</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param filterFunction</span></span><br><span class="line"><span class="comment"> * @returns &#123;&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">filterObject</span>(<span class="params">obj, filterFunction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    .filter(<span class="function"><span class="params">key</span> =&gt;</span> filterFunction(obj[key]))</span><br><span class="line">    .reduce(<span class="function">(<span class="params">res, currKey</span>) =&gt;</span> (res[currKey] = obj[key]), &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Raven配置某些时候不发送错误数据"><a href="#Raven配置某些时候不发送错误数据" class="headerlink" title="Raven配置某些时候不发送错误数据"></a>Raven配置某些时候不发送错误数据</h2><p><code>shouldSendCallback</code>设置只有 production 环境才发送错误数据，本地的错误内容不发送到 sentry 上。</p>
<p><code>dataCallback</code>在发送数据之前想要做的事情，可以放这里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Raven.config(<span class="string">"xxxx"</span>, &#123;</span><br><span class="line">  environment: process.env.NODE_ENV,</span><br><span class="line">  release: process.env.VERSION,</span><br><span class="line">  sampleRate: <span class="number">0.1</span>,</span><br><span class="line">  dataCallback: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV != <span class="string">"production"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;,</span><br><span class="line">  shouldSendCallback: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> process.env.NODE_ENV == <span class="string">"production"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .addPlugin(RavenVue, Vue)</span><br><span class="line">  .install()</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;swiper-v-for-中-click-不生效&quot;&gt;&lt;a href=&quot;#swiper-v-for-中-click-不生效&quot; class=&quot;headerlink&quot; title=&quot;swiper v-for 中 click 不生效&quot;&gt;&lt;/a&gt;swiper v-for 中
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>The Linux Command Line 读书笔记（三）</title>
    <link href="http://sevencai.github.io/2018/08/23/The-Linux-Command-Line-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://sevencai.github.io/2018/08/23/The-Linux-Command-Line-读书笔记（三）/</id>
    <published>2018-08-23T07:27:57.000Z</published>
    <updated>2018-08-23T07:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章：shell-环境-🏡"><a href="#第11章：shell-环境-🏡" class="headerlink" title="第11章：shell 环境 🏡"></a>第11章：shell 环境 🏡</h1><blockquote>
<p>shell 在 shell 会话中保存着大量信息。这些信息被称为 (shell 的) 环境。 程序获取环境中的数据（即环境变量）来了解本机的配置。虽然大多数程序用配置文件来存储程序设置， 一些程序会根据环境变量来调整他们的行为。知道了这些，我们就可以用环境变量来自定制 shell 体验。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   printenv - 打印部分或所有的环境变量</span><br><span class="line">-   <span class="built_in">set</span> - 设置 shell 选项</span><br><span class="line">-   <span class="built_in">export</span> — 导出环境变量，让随后执行的程序知道。</span><br><span class="line">-   <span class="built_in">alias</span> - 创建命令别名</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h2 id="printenv-amp-set"><a href="#printenv-amp-set" class="headerlink" title="printenv &amp; set"></a>printenv &amp; set</h2><blockquote>
<p>shell 在环境中存储了两种基本类型的数据，虽然 bash 几乎无法分辨这些数据的类型。 它们是<strong>环境变量和 shell 变量</strong>。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
</blockquote>
<p>我们可以用 bash 的内建命令 set，或者是 printenv 程序来查看环境变量。<strong>set 命令可以 显示 shell 或环境变量，而 printenv 只是显示环境变量。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printenv | less</span><br><span class="line"></span><br><span class="line"><span class="comment">// printenv 支持查看某个环境变量</span></span><br><span class="line">printenv USER   =&gt; sevencai</span><br></pre></td></tr></table></figure>
<p>当使用没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数 都会被显示。不同于 printenv 命令，set 命令的输出很友好地按照首字母顺序排列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> | less</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line">// 别名无法通过使用 <span class="built_in">set</span> 或 printenv 来查看。 用不带参数的 <span class="built_in">alias</span> 来查看别名:</span><br><span class="line"><span class="built_in">alias</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="如何建立-shell-环境？"><a href="#如何建立-shell-环境？" class="headerlink" title="如何建立 shell 环境？"></a>如何建立 shell 环境？</h2><blockquote>
<p>When we log on to the system, the bash program starts, and reads a series of configuration scripts called startup files, which define the default environment shared by all users. This is followed by more startup files in our home directory that define our personal environment. The exact sequence depends on the type of shell session being started. There are two kinds: a login shell session and a non-login shell session.</p>
</blockquote>
<p>登录shell或者非登录shell都会去读取相应的文件，但是读取的文件多少会有区别。例如：</p>
<p>登录shell可能会读取：</p>
<p><img src="login.png" alt="login"></p>
<p>非登录shell可能会读取：</p>
<p><img src="unlogin.png" alt="unlogin.png"></p>
<p>一个典型的 .bashrc 文件可能长下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></p>
<p>翻译过来可能是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If the file ~/.bashrc exists, <span class="keyword">then</span></span><br><span class="line"><span class="built_in">read</span> the ~/.bashrc file.</span><br></pre></td></tr></table></figure></p>
<p><strong>是否曾经对 shell 怎样知道在哪里找到我们在命令行中输入的命令感到迷惑？例如，当我们输入 ls 后， shell 不会查找整个计算机系统来找到 /bin/ls（ls 命令的全路径名），相反，它查找一个目录列表， 这些目录包含在 PATH 变量中。</strong></p>
<p>我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> l.=<span class="string">'ls -d .* --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l --color=auto'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="第12章：-vi简介🐩"><a href="#第12章：-vi简介🐩" class="headerlink" title="第12章： vi简介🐩"></a>第12章： vi简介🐩</h1><p>这个我已经比较熟悉了，这里还是列出下书里的总结，整体的总结书里写的挺好：</p>
<blockquote>
<p>vi（发音“vee eye”），大多数 Linux 发行版不包含真正的 vi；而是自带一款高级替代版本，叫做 vim（它是“vi improved”的简写）由 Bram Moolenaar 开发的。vim 相对于传统的 Unix vi 来说，取得了实质性进步。通常，vim 在 Linux 系统中是“vi”的符号链接（或别名）。</p>
</blockquote>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><p><img src="move.png" alt="move"></p>
<p>补充一个：<code>0,$,^,g_</code>  的区别和联系。<code>0,$</code>是到行头和行尾，<code>^,g_</code>到非blank字符位置。<code>J</code>合并行。</p>
<h2 id="文本删除命令"><a href="#文本删除命令" class="headerlink" title="文本删除命令"></a>文本删除命令</h2><p><img src="delete.png" alt="delete"></p>
<h2 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h2><p><img src="copy.png" alt="copy"></p>
<h2 id="全局查找与替换"><a href="#全局查找与替换" class="headerlink" title="全局查找与替换"></a>全局查找与替换</h2><p>如<code>:%s/Line/line/g</code></p>
<p>查找一行内的是用 <code>f</code> 命令，查找下一个出现的，是用 <code>/</code>命令。</p>
<p><img src="replace.png" alt="replace"></p>
<h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h2><ol>
<li>vi file1 file2 file3…</li>
<li>:n 从这个文件切换下一个文件，使用这个 ex 命令</li>
<li>:N 回到先前的文件使用:N</li>
<li>:buffers 我们可以查看正在编辑的文件列表，使用:buffers 命令。运行这个 命令后，屏幕顶部就会显示出一个文件列表, :buffers 2 就切换到2号文件了。</li>
</ol>
<hr>
<h1 id="第13章：自定制-shell-提示符-💉"><a href="#第13章：自定制-shell-提示符-💉" class="headerlink" title="第13章：自定制 shell 提示符 💉"></a>第13章：自定制 shell 提示符 💉</h1><p>和 Linux 内的许多程序一样，shell 提示符是可高度配置的，虽然我们把它相当多地看作是理所当然的， 但是我们一旦学会了怎样控制它，shell 提示符是一个相当有用的工具。</p>
<p>我们的默认提示符如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$</span><br></pre></td></tr></table></figure></p>
<p>注意它包含我们的用户名，主机名和当前工作目录，但是它又是怎样得到这些东西的呢？ 结果证明非常简单。提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one” 的简写）。我们可以通过 echo 命令来查看 PS1的内容。</p>
<h2 id="认识-PS1"><a href="#认识-PS1" class="headerlink" title="认识$PS1"></a>认识$PS1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[me@linuxbox ~]$ <span class="built_in">echo</span> <span class="variable">$PS1</span></span><br><span class="line"><span class="variable">$&#123;ret_status&#125;</span> %&#123;<span class="variable">$fg</span>[cyan]%&#125;%c%&#123;<span class="variable">$reset_color</span>%&#125; $(git_prompt_info)</span><br></pre></td></tr></table></figure>
<h2 id="更改-PS1"><a href="#更改-PS1" class="headerlink" title="更改 $PS1"></a>更改 $PS1</h2><p>我们可以首先备份下 $PS1, 然后再随意修改 $PS1, 最后再重新变回来就可以了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 备份 PS1</span><br><span class="line">ps1_old=<span class="string">"<span class="variable">$PS1</span>"</span></span><br><span class="line"></span><br><span class="line">// 随意修改 PS1</span><br><span class="line">$ PS1=<span class="string">"\a\$ "</span></span><br><span class="line"></span><br><span class="line">// 最后改回来</span><br><span class="line">PS1=<span class="variable">$ps1_old</span></span><br></pre></td></tr></table></figure></p>
<p>其实这个我平时肯定不会用，但是看着看着还挺有意思的，就随意记录了下。</p>
<hr>
<h1 id="总结-🌺"><a href="#总结-🌺" class="headerlink" title="总结 🌺"></a>总结 🌺</h1><p>这几个章节主要是总结了<code>配置文件和 shell 环境</code>这 一张。这章内容少用，但是对于理解整体 shell 是很有帮助的。</p>
<p>时间都是挤出来的，事实证明利用好中午和晚上回家之前的时间，也是能有所收获。📚</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第11章：shell-环境-🏡&quot;&gt;&lt;a href=&quot;#第11章：shell-环境-🏡&quot; class=&quot;headerlink&quot; title=&quot;第11章：shell 环境 🏡&quot;&gt;&lt;/a&gt;第11章：shell 环境 🏡&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;s
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://sevencai.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>The Linux Command Line 读书笔记（二）</title>
    <link href="http://sevencai.github.io/2018/08/17/The-Linux-Command-Line-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://sevencai.github.io/2018/08/17/The-Linux-Command-Line-读书笔记（二）/</id>
    <published>2018-08-17T09:11:25.000Z</published>
    <updated>2018-08-17T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-权限管理🏫"><a href="#第九章-权限管理🏫" class="headerlink" title="第九章-权限管理🏫"></a>第九章-权限管理🏫</h1><blockquote>
<p>Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统，区别在于它们不仅是多任务系统，而且也是 多用户系统。这到底意味着什么？它意味着多个用户可以在同一时间使用同一台计算机。<br>为了使多用户特性付诸实践，那么必须发明一种方法来<strong>阻止用户彼此之间受到影响</strong>。毕竟，一个 用户的行为不能导致计算机崩溃，也不能乱动属于另一个用户的文件。</p>
</blockquote>
<p>主要的命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id – 显示用户身份号（每个用户都会有个 id）</span><br><span class="line">chmod – 更改文件模式</span><br><span class="line"><span class="built_in">umask</span> – 设置默认的文件权限 (这个我基本不会用到，暂时忽略)</span><br><span class="line">su – 以另一个用户的身份来运行 shell</span><br><span class="line">sudo – 以另一个用户的身份来执行命令</span><br><span class="line">chown – 更改文件所有者</span><br><span class="line">chgrp – 更改文件组所有权</span><br><span class="line">passwd – 更改用户密码</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="chmod-更改文件模式"><a href="#chmod-更改文件模式" class="headerlink" title="chmod-更改文件模式"></a>chmod-更改文件模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--    1 sevencai  TENCENT\Domain Users     523  8 15 15:36 README.md</span><br></pre></td></tr></table></figure>
<p><strong>列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。</strong></p>
<p>具体可能有的值有：</p>
<p><img src="firstletter.png" alt="first letter"></p>
<p><strong>剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。</strong></p>
<p><img src="filemode.png" alt="filemode"></p>
<p><img src="attribute.png" alt="attribute"></p>
<p>如<code>-rwxr-xr-x</code>标识的含义是：一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。</p>
<p><strong>我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。</strong></p>
<p>对应的值为：</p>
<p><img src="otcal.png" alt="octal"></p>
<p>通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 foo.txt</span><br><span class="line">chmod 755 shell.sh</span><br></pre></td></tr></table></figure>
<p>通过传递参数 “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有 权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—)。</p>
<p>chmod 命令还支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定 要影响的对象，如下所示：</p>
<p><img src="ugoa.png" alt="ugoa"></p>
<p><strong>如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。</strong></p>
<p>有下面这些例子（我感觉这种我应该不会经常用，先前一直用上面的二进制模式比较多）：</p>
<p><img src="other.png" alt="ugoa+-"></p>
<hr>
<h2 id="su-及-sudo"><a href="#su-及-sudo" class="headerlink" title="su 及 sudo"></a>su 及 sudo</h2><blockquote>
<p>su － 以其他用户身份和组 ID 运行一个 shell<br>语法类似： su [-[l]] [user]</p>
</blockquote>
<p>如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。</p>
<p>因此为了启动超级用户我们可能会这样执行<code>su -</code>。</p>
<p>如果以<code>su -c &#39;command&#39;</code>这样的方式启动一个 shell, 是可以执行单个的<code>command</code>命令，而不是重新启动了一个可以交互的shell。注意 command 要用 引号引起来。如<code>su -c &#39;ls -l /root/*&#39;</code>。</p>
<p><strong>sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。</strong></p>
<p>执行 <code>sudo -l</code>可以看当前被赋予了哪些权限如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  midas-welfare git:(master) sudo -l</span><br><span class="line">Password:</span><br><span class="line">Matching Defaults entries for sevencai on SEVENCAI-MB2:</span><br><span class="line">    env_reset ......</span><br><span class="line">User sevencai may run the following commands on SEVENCAI-MB2:</span><br><span class="line">    (ALL) ALL</span><br></pre></td></tr></table></figure></p>
<p>所以这里总结下 su 和 sudo 的区别和联系：</p>
<ol>
<li><code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码。</li>
<li><code>sudo</code> 命令只允许使用提升的权限运行单个命令，而 <code>su</code> 命令会启动一个新的 shell，同时允许使用 root 权限运行尽可能多的命令，直到明确退出登录</li>
</ol>
<p><strong>所以根据第一条，我们可以知道就安全性而言，<code>sudo</code> 比 <code>su</code> 更好。<code>su</code>意味着要与其他用户共享 root 密码，这是一件比较危险的事情。并且对于 <code>su</code> 而言如果要撤销特定用户的超级（root）权限，唯一的办法就是更改 root 密码，然后再告知其他用户。很麻烦。但是 <code>sudo</code> 就不一样了,如果想要阻止某个用户访问 root 权限，只需要调整 <code>sudoers</code> 这个文件中的配置即可。</strong></p>
<p>The key difference between <code>sudo</code> and <code>su</code> is <code>sudo</code> runs a command as root, whereas <code>su</code> makes you root.</p>
<hr>
<h2 id="chown-－-更改文件所有者和用户组"><a href="#chown-－-更改文件所有者和用户组" class="headerlink" title="chown － 更改文件所有者和用户组"></a>chown － 更改文件所有者和用户组</h2><p><strong>chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [owner][:[group]] file...</span><br></pre></td></tr></table></figure>
<p><img src="chown.png" alt="chown"></p>
<p>下面这个例子比较实用，有两个用户，janet拥有超级用户访问权限，而 tony 没有。用户 janet 想要从 她的家目录复制一个文件到用户 tony 的家目录。因为用户 janet 想要 tony 能够编辑这个文件， janet 把这个文件的所有者更改为 tony:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo cp myfile.txt ~tony</span><br><span class="line">Password:</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root  root <span class="number">8031</span> <span class="number">2008</span><span class="number">-03</span><span class="number">-20</span> <span class="number">14</span>:<span class="number">30</span> /home/tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> tony  tony <span class="number">8031</span> <span class="number">2008</span><span class="number">-03</span><span class="number">-20</span> <span class="number">14</span>:<span class="number">30</span> /home/tony/myfile.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="更改用户密码"><a href="#更改用户密码" class="headerlink" title="更改用户密码"></a>更改用户密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd [user]</span><br><span class="line">sudo passwd root 更改 root 用户的密码</span><br></pre></td></tr></table></figure>
<p>passwd 命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前相似的密码、 字典中的单词作为密码或者是太容易猜到的密码。</p>
<hr>
<h1 id="第十章：进程🚓"><a href="#第十章：进程🚓" class="headerlink" title="第十章：进程🚓"></a>第十章：进程🚓</h1><p>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   ps – 报告当前进程快照</span><br><span class="line">-   top – 显示任务</span><br><span class="line">-   <span class="built_in">jobs</span> – 列出活跃的任务</span><br><span class="line">-   <span class="built_in">bg</span> – 把一个任务放到后台执行</span><br><span class="line">-   <span class="built_in">fg</span> – 把一个任务放到前台执行</span><br><span class="line">-   <span class="built_in">kill</span> – 给一个进程发送信号</span><br><span class="line">-   killall – 杀死指定名字的进程</span><br><span class="line">-   shutdown – 关机或重启系统</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>查看进程，最常使用地命令（有几个命令）是 ps(process)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br><span class="line"></span><br><span class="line">  PID TTY           TIME CMD</span><br><span class="line">54944 ttys000    0:00.14 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp sevencai</span><br><span class="line">55003 ttys000    0:00.61 -zsh</span><br><span class="line">10488 ttys001    0:00.27 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp sevencai</span><br><span class="line">10492 ttys001    0:02.66 -zsh</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。为了得到更多信息， 我们需要加上一些选项。TTY 是 “Teletype”(直译电传打字机) 的简写，是指进程的控制终端。TIME 字段表示 进程所消耗的 CPU 时间数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上 “x” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以 看到我们所拥有的每个进程的信息。</span></span><br><span class="line">ps x</span><br><span class="line">ps x | less</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够显示属于每个用户的进程信息。使用这个选项，可以唤醒 “BSD 风格” 的输出结果。</span></span><br><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="用-top-命令动态查看进程"><a href="#用-top-命令动态查看进程" class="headerlink" title="用 top 命令动态查看进程"></a>用 top 命令动态查看进程</h2><p><strong>虽然 ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照。 为了看到更多动态的信息，我们使用 <code>top</code> 命令。</strong></p>
<p>top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。</p>
<hr>
<h2 id="通过-kill-命令给进程发送信号"><a href="#通过-kill-命令给进程发送信号" class="headerlink" title="通过 kill 命令给进程发送信号"></a>通过 kill 命令给进程发送信号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID...</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -1 13546</span><br><span class="line"><span class="built_in">kill</span> -9 pid (我经常用)</span><br></pre></td></tr></table></figure>
<p>具体的 <code>-signal</code> 的可选值，如下所示：</p>
<p><img src="kill.png" alt="kill"></p>
<hr>
<h1 id="总结🌹"><a href="#总结🌹" class="headerlink" title="总结🌹"></a>总结🌹</h1><p>加上这篇文章，<code>The Linux Command Line</code> 的第一章就结束了。我零零散散的花的时间去整理的，中间也去除了一些我基本上不怎么用到的，着重加强了下我经常用到的一些命令。</p>
<p>比如 kill ，我以前经常用到 kill -9, 但是其实一直不知道这个 -9 是什么东西。现在进行稍微系统一点的学习，打命令不再依靠熟悉和曾经用过，而是有理解的。📚❄️</p>
<p>包括还有  sudo 及 su, 以前一直有用过，但是模拟两可，并不知道两者的区别。现在都大致的有了解。以后看运维同学敲命令，我看它敲 su or sudo 就知道它是大概的区别是什么了。想要做什么事情。🐶</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第九章-权限管理🏫&quot;&gt;&lt;a href=&quot;#第九章-权限管理🏫&quot; class=&quot;headerlink&quot; title=&quot;第九章-权限管理🏫&quot;&gt;&lt;/a&gt;第九章-权限管理🏫&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Unix 传统中的操作系统不同于那些 MS-DOS
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://sevencai.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>The Linux Command Line 读书笔记（一）</title>
    <link href="http://sevencai.github.io/2018/08/10/The-Linux-Command-Line-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sevencai.github.io/2018/08/10/The-Linux-Command-Line-读书笔记（一）/</id>
    <published>2018-08-10T12:54:15.000Z</published>
    <updated>2018-08-10T13:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章是我读 <em>The Linux Command Line</em> 的读书笔记。电子版的书的地址是：<a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">TLCL</a>。相比于鸟叔，这本书好在比较少，重点比较突出，大部分里面的命令都是我会经常用到的。缺点是也存在少量冗余的内容。不便于我查找和学习。因此我把我需要的东西从中抽取出来，总结并且提炼，以便日后的查找和学习。此篇笔记📒是书的第一章到第九章。</p>
</blockquote>
<h2 id="第一章：什么是-shell🏠"><a href="#第一章：什么是-shell🏠" class="headerlink" title="第一章：什么是 shell🏠"></a>第一章：什么是 shell🏠</h2><p>shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。“bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。</p>
<blockquote>
<p>[me@linuxbox ~]$</p>
</blockquote>
<ol>
<li>代表 username@machinename ，后面可能是 $ or #，其中 # 代表了你有 root 权限， 对应的 $ 可能代表的就是普通的用户。</li>
<li>一些简单的命令如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date  当前时间</span><br><span class="line">cal  日期</span><br><span class="line">df  查看磁盘剩余空间的数量</span><br><span class="line"><span class="built_in">exit</span>  终止会话</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第二章：文件系统中跳转"><a href="#第二章：文件系统中跳转" class="headerlink" title="第二章：文件系统中跳转"></a>第二章：文件系统中跳转</h2><p>相关命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 打印出当前工作目录名</span><br><span class="line"><span class="built_in">cd</span>  dir 更改目录</span><br><span class="line">ls  列出目录内容，不包括带 . 的隐藏目录</span><br><span class="line">ls  -a 可以列出带 . 隐藏的目录</span><br><span class="line"><span class="built_in">cd</span>  更改工作目录到你的家目录</span><br><span class="line"><span class="built_in">cd</span>  - 更改工作目录到先前的工作目录</span><br><span class="line"><span class="built_in">cd</span>  ~user_name 更改工作目录到用户家目录</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="第三章：探究操作系统"><a href="#第三章：探究操作系统" class="headerlink" title="第三章：探究操作系统"></a>第三章：探究操作系统</h2><p>相关命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls    列出目录内容</span><br><span class="line">file   确定文件类型</span><br><span class="line">less   浏览文件内容</span><br><span class="line"></span><br><span class="line">ls -l    使用 ls 命令的“-l”选项，则结果以长模式输出 === ll</span><br><span class="line">ls -lt   <span class="string">"t"</span>选项按文件修改时间的先后来排序</span><br><span class="line">file filename   查看文件的类型</span><br></pre></td></tr></table></figure></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote>
<p>命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br><span class="line">ls -lt --reverse</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>options</code> : 选项, 一般是 -l  这种形式，也支持长选项，长选项由两个中划线加上一个字组成。如 <code>--reverse</code>。 当然也有两种合并的。如上。</p>
<p>下面这张图来源于书里的对ls的命令的一部分列举，红色的框是我经常用的：</p>
<p><img src="ls.png" alt="ls"></p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less 命令是一个用来浏览文本文件的程序,less 程序允许你前后滚动文件。</p>
<blockquote>
<p>格式为： less filename<br>如 less a.log<br>如 ps -ef | less 以分页的形式查看当前进程 (这个好用)</p>
</blockquote>
<p><img src="less.png" alt="less"></p>
<p>上面这个图里是不是感觉跟 vim 命令很像，我再补充几个，是我经常用到的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-   /字符串：向下搜索<span class="string">"字符串"</span>的功能</span><br><span class="line">-   ?字符串：向上搜索<span class="string">"字符串"</span>的功能</span><br><span class="line">-   n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-   N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-   b 向后翻一页</span><br><span class="line">-   d 向后翻半页</span><br><span class="line">-   空格键 滚动一页</span><br><span class="line">-   回车键 滚动一行</span><br><span class="line">-   u 向前滚动半页</span><br><span class="line">-   y 向前滚动一行</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四章：操作文件和目录"><a href="#第四章：操作文件和目录" class="headerlink" title="第四章：操作文件和目录"></a>第四章：操作文件和目录</h2><p>主要命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-   cp — 复制文件和目录</span><br><span class="line">-   mv — 移动/重命名文件和目录</span><br><span class="line">-   mkdir — 创建目录</span><br><span class="line">-   rm — 删除文件和目录</span><br><span class="line">-   ln — 创建硬链接和符号链接</span><br></pre></td></tr></table></figure></p>
<p>这几个命令我们最熟悉不过了。下面简单的列举了这几个的一些基本用法。</p>
<h3 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp 复制文件和目录"></a>cp 复制文件和目录</h3><p><img src="cp.png" alt="cp"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若 file2 存在，则覆盖or重写，若不存在则创建</span></span><br><span class="line">cp file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// -i 代表 info, 所以跟上面相同，只是覆盖or重写会有提示</span></span><br><span class="line">cp -i file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在</span></span><br><span class="line">cp file1 file2 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在</span></span><br><span class="line">cp dir1<span class="comment">/* dir2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 复制目录 dir1 中的内容到目录 dir2。</span></span><br><span class="line"><span class="comment">// 如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样</span></span><br><span class="line"><span class="comment">cp -r dir1 dir2</span></span><br></pre></td></tr></table></figure>
<h3 id="mv-移动和重命名文件"><a href="#mv-移动和重命名文件" class="headerlink" title="mv 移动和重命名文件"></a>mv 移动和重命名文件</h3><p><img src="mv.png" alt="mv"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 file2 存在，它的内容会被 file1 的内容重写。</span></span><br><span class="line"><span class="comment">// 如果 file2 不存在，则创建 file2。 这两种情况下，file1 都不再存在</span></span><br><span class="line">mv file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写时会提示用户</span></span><br><span class="line">mv -i file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在</span></span><br><span class="line">mv file1 file2 dir1</span><br></pre></td></tr></table></figure>
<h3 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm - 删除文件和目录"></a>rm - 删除文件和目录</h3><p><img src="rm.png" alt="rm"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默默地删除文件</span></span><br><span class="line">rm file1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样</span></span><br><span class="line">rm -i file1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件 file1, 目录 dir1，及 dir1 中的内容</span></span><br><span class="line">rm -r file1 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</span></span><br><span class="line">rm -rf file1 dir1</span><br></pre></td></tr></table></figure></p>
<p><strong>不要用 <code>rm -rf</code>, 用 <code>rm -ri</code> 吧，给自己一点后悔的余地。</strong></p>
<h3 id="ln-—-创建链接"><a href="#ln-—-创建链接" class="headerlink" title="ln — 创建链接"></a>ln — 创建链接</h3><blockquote>
<p>建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建硬链接</span></span><br><span class="line">ln file link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建符号链接（soft）</span></span><br><span class="line">ln -s 源文件 目标文件</span><br><span class="line">ln -s item link</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>关于这里我有一些实际可以用到软硬链接的场景。稍后再补充。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>书里先简单的讲了下通配符，我觉得只看例子就好了。<br><img src="tongpei.png" alt="通配符"></p>
<hr>
<h2 id="第五章：使用命令"><a href="#第五章：使用命令" class="headerlink" title="第五章：使用命令"></a>第五章：使用命令</h2><p>主要的几个有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="built_in">type</span> – 显示命令的类型</span><br><span class="line">-   <span class="built_in">which</span> – 显示一个可执行程序的位置</span><br><span class="line">-   man – 显示命令手册页</span><br><span class="line">-   apropos – 显示一系列适合的命令</span><br><span class="line">-   info – 显示命令 info</span><br><span class="line">-   whatis – 显示一个命令的简洁描述</span><br><span class="line">-   <span class="built_in">alias</span> – 创建命令别名</span><br></pre></td></tr></table></figure></p>
<p>下面举一些例子，这个更好理解一些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">type</span> 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）</span><br><span class="line"><span class="built_in">type</span> ls     =&gt; ls is an <span class="built_in">alias</span> <span class="keyword">for</span> ls -G</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span>     =&gt; <span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">type</span>   =&gt; <span class="built_in">type</span> is a shell builtins</span><br><span class="line"></span><br><span class="line">// 这个命令只对可执行程序有效，不包括内建命令和命令别名</span><br><span class="line"><span class="built_in">which</span> node  =&gt; /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line"><span class="built_in">which</span> npm   =&gt; /usr/<span class="built_in">local</span>/bin/npm</span><br><span class="line"></span><br><span class="line">// 输入“<span class="built_in">help</span>”，接着是 shell 内部命令名, 注意后面跟的一定要是 <span class="built_in">builtin</span> commands</span><br><span class="line"><span class="built_in">help</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">// --<span class="built_in">help</span> - 显示用法信息,它不要求是 <span class="built_in">builtin</span> commands, 是可执行程序即可</span><br><span class="line">mkdir --<span class="built_in">help</span> | less</span><br><span class="line">tar --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">// 许多希望被命令行使用的可执行程序</span><br><span class="line">// 提供了一个正式的文档，叫做手册或手册页(man page)。</span><br><span class="line">// 一个特殊的叫做 man 的分页程序，可用来浏览他们。</span><br><span class="line">man <span class="built_in">which</span></span><br><span class="line">man ls</span><br></pre></td></tr></table></figure></p>
<p>关于 alias 我觉得很好用，单独拿出来：</p>
<p><strong>语法是： <code>alias name=&#39;string&#39;</code>实际上我们平时写 命令 时，是可以几个一起写的，比如 <code>cd /usr; ls; cd -</code>。如果这个命令你经常用，而且不想要每次都打折三个命令，那么你可以把它做成一个别名。这样每次就可以很方便的切换了。如我们给上面一个命令起名叫 test, 在每次起别名前，记得用 type 试下，看这个别名是否被占用了。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bash: <span class="built_in">type</span>: foo: not found  可以创建为别名</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="built_in">test</span> is a shell <span class="built_in">builtin</span> 已经被使用了，不能创建了</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="built_in">test</span> 为我们的命令了</span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">test</span>=<span class="string">'cd /usr; ls; cd -'</span></span><br><span class="line"></span><br><span class="line">// 此时我们查看就会显示： foo is aliased to `<span class="built_in">cd</span> /usr; ls ; <span class="built_in">cd</span> -<span class="string">'</span></span><br><span class="line"><span class="string">type test</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第六章：重定向"><a href="#第六章：重定向" class="headerlink" title="第六章：重定向"></a>第六章：重定向</h2><blockquote>
<p>”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。</p>
</blockquote>
<p>主要的命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   cat － 连接文件</span><br><span class="line">-   sort － 排序文本行</span><br><span class="line">-   uniq － 报道或省略重复行</span><br><span class="line">-   grep － 打印匹配行</span><br><span class="line">-   wc － 打印文件中换行符，字，和字节个数</span><br><span class="line">-   head － 输出文件第一部分</span><br><span class="line">-   tail - 输出文件最后一部分</span><br><span class="line">-   tee - 从标准输入读取数据，并同时写到标准输出和文件</span><br></pre></td></tr></table></figure></p>
<h3 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l ls-output.txt</span><br><span class="line">ls -l /bin/usr &gt; ls-output.txt  不追加，每次都被从头覆盖</span><br><span class="line">ls -l /usr/bin &gt;&gt; ls-output.txt   追加到文件中</span><br><span class="line">&gt; ls-output.txt  清空某个文件</span><br></pre></td></tr></table></figure>
<h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><blockquote>
<p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 /bin/usr 不存在时报错将输出到 ls-error.txt 中</span></span><br><span class="line">ls -l /bin/usr <span class="number">2</span>&gt; ls-error.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有的时候可能我们需要重定向标准输出和错误到同一个文件</span></span><br><span class="line">ls -l /bin/usr &gt; ls-output.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向</span></span><br><span class="line"><span class="comment">// 使用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件</span></span><br><span class="line">ls -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<h3 id="处理不需要的输出"><a href="#处理不需要的输出" class="headerlink" title="处理不需要的输出"></a>处理不需要的输出</h3><p>有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，可以像下面这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 处理不需要的输出</span><br><span class="line">ls -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>上面的比较少用到，基本上我之前没有用到过。</p>
<h3 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h3><h4 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// cat 命令读取一个或多个文件</span><br><span class="line">// cat 经常被用来显示简短的文本文件不分页</span><br><span class="line">cat [file]</span><br><span class="line">cat z.txt</span><br><span class="line">cat &lt; lazy_dog.txt  将标准输入，输出到 文件中</span><br></pre></td></tr></table></figure>
<h4 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h4><blockquote>
<p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>
<p><strong>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>
<h4 id="uniq-报道或忽略重复行"><a href="#uniq-报道或忽略重复行" class="headerlink" title="uniq - 报道或忽略重复行"></a>uniq - 报道或忽略重复行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表中不包含重复句子</span></span><br><span class="line">ls /bin /usr/bin | sort | uniq | less</span><br></pre></td></tr></table></figure>
<h4 id="wc-－-打印行数、字数和字节数"><a href="#wc-－-打印行数、字数和字节数" class="headerlink" title="wc － 打印行数、字数和字节数"></a>wc － 打印行数、字数和字节数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wc（字计数）命令是用来显示文件所包含的行数、字数和字节数</span></span><br><span class="line">wc ls-output.txt</span><br><span class="line"><span class="number">7902</span> <span class="number">64566</span> <span class="number">503634</span> ls-output.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// ”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法</span></span><br><span class="line">ls /bin /usr/bin | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>
<h4 id="grep-－-打印匹配行"><a href="#grep-－-打印匹配行" class="headerlink" title="grep － 打印匹配行"></a>grep － 打印匹配行</h4><p>grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</span><br><span class="line">ls /bin /usr/bin | sort | uniq | grep zip</span><br></pre></td></tr></table></figure></p>
<h4 id="head-tail-－-打印文件开头部分-结尾部分"><a href="#head-tail-－-打印文件开头部分-结尾部分" class="headerlink" title="head / tail － 打印文件开头部分/结尾部分"></a>head / tail － 打印文件开头部分/结尾部分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 命令打印文件的前十行，而 tail 命令打印文件的后十行。 -n 用来指定</span></span><br><span class="line">head -n <span class="number">5</span> ls-output.txt</span><br><span class="line">total <span class="number">343496</span></span><br><span class="line">tail -n <span class="number">5</span> ls-output.txt</span><br><span class="line">ls /usr/bin | tail -n <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。</span></span><br><span class="line">tail -f /<span class="keyword">var</span>/log/messages</span><br></pre></td></tr></table></figure>
<p><strong>使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</strong></p>
<h4 id="tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件"><a href="#tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件" class="headerlink" title="tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件"></a>tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件</h4><p>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="从-shell-眼中看世界-Echo"><a href="#从-shell-眼中看世界-Echo" class="headerlink" title="从 shell 眼中看世界- Echo"></a>从 shell 眼中看世界- Echo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="built_in">echo</span> － 显示一行文本</span><br></pre></td></tr></table></figure>
<p>利用 echo 你可以做下面这些事情。这个 echo 跟 php 里的 echo 非常的像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span></span><br><span class="line">// this is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> *</span><br><span class="line">// Applications Desktop Documents Downloads Library Movies Music Pictures Public</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> D*</span><br><span class="line">// Desktop Documents Downloads</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> *s</span><br><span class="line">// Documents Pictures Templates Videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">// Desktop Documents Music Pictures Public Templates Videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /usr/*/share</span><br><span class="line">// /usr/a/share  /user/b/share</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ~</span><br><span class="line">// /Users/sevencai</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $((2 + 2))</span><br><span class="line">// 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $(($((5**2)) * 3))</span><br><span class="line">// 5*5 *3 = 75</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">// Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Number_&#123;1,5&#125;</span><br><span class="line">// Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">// sevencai</span><br><span class="line"></span><br><span class="line">// 查看有效变量</span><br><span class="line">printenv | less</span><br><span class="line"></span><br><span class="line">// 命令替换</span><br><span class="line"><span class="built_in">echo</span> $(ls)</span><br><span class="line">ls -l $(<span class="built_in">which</span> cp)</span><br><span class="line"></span><br><span class="line"> // 在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。由于它们把单词分为不同的参数，所以在上面的例子中， 命令行包含一个带有四个不同参数的命令。</span><br><span class="line"><span class="built_in">echo</span> this is a    <span class="built_in">test</span></span><br><span class="line">// this is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="variable">$1</span> 当做第一个变量，因为 `1` 是没有定义的变量，所以为空</span><br><span class="line"><span class="built_in">echo</span> The total is <span class="variable">$100</span>.00</span><br><span class="line">// The total is 00.00</span><br><span class="line"></span><br><span class="line">// 在双引号中，参数展开、算术表达式展开和命令替换仍然有效</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> <span class="variable">$((2+2)</span>) <span class="variable">$(cal)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"this is a    test"</span></span><br><span class="line">// this is a    <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>这里我觉得大致的了解下就行。因为真实情况下，我用到的非常非常少。</p>
<hr>
<h2 id="键盘高级技巧"><a href="#键盘高级技巧" class="headerlink" title="键盘高级技巧"></a>键盘高级技巧</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p><img src="jiqiao.png" alt="复制"></p>
<h3 id="剪切复制"><a href="#剪切复制" class="headerlink" title="剪切复制"></a>剪切复制</h3><p><img src="copy.png" alt="剪切"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天就到这里吧，我担心因为今天已经看了很多了，就后面把这个看完这本书记录下来当做任务去完成了，这样违背了我的初衷。所以有效的时间，做正确的事情。改天我再来总结后面几章节。</p>
<p>回家🌶啦，✈️明天去接我的小狗狗，可乐！！！ 嘻嘻。开心。开心。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章是我读 &lt;em&gt;The Linux Command Line&lt;/em&gt; 的读书笔记。电子版的书的地址是：&lt;a href=&quot;http://billie66.github.io/TLCL/book/index.html&quot; target=&quot;_bl
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://sevencai.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>项目总结</title>
    <link href="http://sevencai.github.io/2018/08/09/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://sevencai.github.io/2018/08/09/项目总结/</id>
    <published>2018-08-09T13:23:13.000Z</published>
    <updated>2018-08-09T14:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近一个多月加了很多班，做了一个比较紧急的项目 Nodejs + Vue全家桶，感觉自己收获多多。今天已经发布了现网版本，趁热总结和梳理下。</p>
</blockquote>
<hr>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ol>
<li><code>Nodejs koa2</code>,  <code>async await</code>用的很舒适。</li>
<li><code>Vue 全家桶</code>,<code>vue webpack vuex</code>可快速开发。</li>
<li>前后端分离，<code>Nodejs</code> 端纯做 <code>Api</code> 层。</li>
<li><code>pm2</code> 进程管理工具。又熟悉了很多命令和踩了一些坑。</li>
<li><code>log4js</code>日志打印工具。了解了部门的日志规范，用于查询问题。</li>
<li>数据库用的 <code>sequelize</code>。</li>
<li>登录用的 <code>koa-generic-session</code>。</li>
<li>了解了 ToB 的一些概念及思想。</li>
</ol>
<p>以后就抛弃 PHP 这个世界上最好的语言吧。以下主要是自己对自己问题的一些梳理。并不涉及到任何的真实项目代码⌨️🏠。</p>
<hr>
<h2 id="获取用户的IP信息"><a href="#获取用户的IP信息" class="headerlink" title="获取用户的IP信息"></a>获取用户的IP信息</h2><p>在很多种情况下，我们Nodejs层需要把用户的 ip 传给后台的 cgi, cgi 会根据这个 ip 做一些策略，如风控，营销等等。这就涉及到 ip 怎么取的概念，你可能会接触到这几个 ip:</p>
<ol>
<li>ctx.request.ip</li>
<li>ctx.headers[‘x-forwarded-for’]</li>
<li>ctx.headers[‘x-real-ip’]</li>
</ol>
<p>先来普及下 <code>x-forwarded-for</code>及 <code>x-real-ip</code>。</p>
<p><code>x-forwarded-for</code>的格式一般为：<code>X-Forwarded-For: client1, proxy1, proxy2</code>  如：<code>X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</code></p>
<blockquote>
<p>最左边（client1）是最原始客户端的IP地址, 代理服务器每成功收到一个请求，就把<strong>请求来源IP地址</strong>添加到右边。 在上面这个例子中，这个请求成功通过了三台代理服务器：proxy1, proxy2 及 proxy3。请求由client1发出，到达了proxy3（proxy3可能是请求的终点）。请求刚从client1中发出时，XFF是空的，请求被发往proxy1；通过proxy1的时候，client1被添加到XFF中，之后请求被发往proxy2;通过proxy2的时候，proxy1被添加到XFF中，之后请求被发往proxy3；通过proxy3时，proxy2被添加到XFF中，之后请求的的去向不明，如果proxy3不是请求终点，请求会被继续转发。<strong>鉴于伪造这一字段非常容易，应该谨慎使用X-Forwarded-For字段。正常情况下XFF中最后一个IP地址是最后一个代理服务器的IP地址, 这通常是一个比较可靠的信息来源。</strong> –维基百科</p>
</blockquote>
<p>而 <code>x-real-ip</code>没有相关标准，但是在反向代理和正向代理下，它的值可能不同。<strong>正向代理时，记录的是客户端的真实ip。 反向代理时，记录的是最后一级的代理ip。</strong></p>
<p>所以：<code>x-real-ip</code> 及 <code>x-forwarded-for</code>这两个 ip 就是很普通的请求头，它们是可以被篡改的。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.my.com:8089 -H <span class="string">'X-Forwarded-For: 1.1.1.1'</span> -H <span class="string">'X-Real-IP: 2.2.2.2'</span></span><br></pre></td></tr></table></figure></p>
<p>那么这两个值都容易被篡改，不可信，我们要拿到用户真实的 ip 怎么办呢？</p>
<p>一般在建立  TCP 连接时，会产生真实的 IP, 叫做 <code>Remote Address</code>。因为是建立在 TCP 中，所以这个 ip 不能被篡改。一旦篡改，握手不成功，那么后面自然就没有了。所以如果我们要取真实的 ip,应该从这个字段里取。</p>
<p>实际上应该取那个值，跟你 nginx 的配置有关系。比如一般配置 nginx 反向代理的时候可能这样配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">// 若 XFF 有值，则 <span class="variable">$proxy_add_x_forwarded_for</span> = <span class="variable">$XFF</span>, <span class="variable">$remote_addr</span>  (<span class="variable">$XFF</span>与<span class="variable">$remote_addr</span>逗号分割，<span class="variable">$remote_addr</span>在其后)</span><br><span class="line">// 若 XFF 没有值，则 <span class="variable">$proxy_add_x_forwarded_for</span> = <span class="variable">$remote_addr</span></span><br></pre></td></tr></table></figure></p>
<p>像这样赋值后，如果你是通过 nginx 反向代理来的，nginx 会把用户实际 ip （$remote_addr）赋值给 <code>X-Real-IP</code>,这时候它也是真实的用户IP了。而 XFF 也是有了用户的真实IP。</p>
<p>通过这样的 nginx 配置。整个内容就无法被篡改和构造，我们就可以从 <code>X-Real-IP</code> 和 <code>XFF</code>的最后一截 获得用户真实的 IP 了。</p>
<p>所以我最后是怎么传什么字段给后台的呢？<strong>我最后传的是 <code>x-forwarded-ip</code>， 拿到这一系列的 ip list 后，后台会去通过网段校验，判断出哪个是外网 ip, 然后把这个 ip 当成是用户真实的 ip。</strong> cgi 还是很严谨的。</p>
<p>最开始谈到的 <code>ctx.request.ip</code> 是最后一次的 ip, 所以有可能是代理机器的 ip。</p>
<p>遇到一篇好文章：<a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="noopener">x-forwarded-for-header-in-http</a></p>
<p>一个实例，判断用户IP是否正常：<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_5" target="_blank" rel="noopener">微信H5支付需判断下单IP和支付IP是否一致</a></p>
<hr>
<h2 id="关于-PM2-的-cluster-模式"><a href="#关于-PM2-的-cluster-模式" class="headerlink" title="关于 PM2 的 cluster 模式"></a>关于 PM2 的 cluster 模式</h2><p>pm2 是很好的进程管理器，有自动重启等功能，并且还自带负载均衡。我这里就不讲具体的 cluster 模式和 pm2 了。就只讲下我遇到的坑。</p>
<p>cluster 模式下，log4js 日志，无法正常打印。这个已经有相关的 issue,地址在<a href="https://github.com/log4js-node/log4js-node/issues/265" target="_blank" rel="noopener">这里</a>。大概的意思是 cluster 模式下，并没有 master 进程，而是只有多个 worker 子进程。而 log4js 只在 master 进程下，才会进行打印日志的操作。之所以这样是因为多个 worker 操作同一个日志文件（一般我们日志文件只有一套配置）可能会导致有错乱等问题。有解决问题的方法，都在那个 issue 里，但是我总觉得不太好。</p>
<p>另一个问题是，在 cluster 模式下，利用 restart 命令无法完全重启进程，fork 模式下就不会，猜测是 cluster 模式有多个 worker, 重启是否需要 restart 指定是哪个子进程才可以？还发现，如果只有一个子进程，不指定也会不能重启。我明天会去验证下。</p>
<p>遇到了一篇好文章： <a href="http://www.acuriousanimal.com/2017/08/20/using-pm2-to-manage-cluster.html" target="_blank" rel="noopener">using-pm2-to-manage-cluster</a></p>
<hr>
<h2 id="登录态验证"><a href="#登录态验证" class="headerlink" title="登录态验证"></a>登录态验证</h2><p>我们利用了<code>koa session</code>, <code>cookie session</code> 这种形式。开始的时候我把这里想复杂了，想要结合微信的登录态。但实际上纯 session cookie 这种反而更好。</p>
<blockquote>
<p>大概流程是：用户登录网站，调用微信登录，拉起授权，授权的地址调用 Nodejs 后台的一个自己封装的接口。在这个接口里获得用户的 openid ，校验用户的权限并且设置 <code>ctx.session.sessionId</code>，然后返回到前端，前端调用后台的接口，通过已经种下的 <code>sessionId</code> 即可判断出用户的权限，然后再返回给前端。前端再针对身份到对应的路由。</p>
</blockquote>
<p>那么你肯定会问，为什么不在直接设置 sessionId 的时候把用户信息返回了呢？这样也可以的，那么相当于你微信授权的回调地址要写一个前端的页面， 然后在这个页面中再来判断用户根据身份到哪个页面。这个前端页面你需要单独的也去维护。这样也是可以的。你也许会问，我不用单独再写个页面，用首页就好了。但是用首页会存在一个问题，就是最终由于授权，你的首页就带上了 code, 还要用 replaceState 什么的去掉，我觉得很不整洁。但是也是可以的。这两种方式本质上都可以。只不过第一种偷懒了，直接redirect到首页，首页再发一次请求。</p>
<p>我用的登录中间件是： <code>koa-generic-session</code>。<code>app.use</code>下面这个中间件即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelizeObj = connectDb.db[dbName]</span><br><span class="line"></span><br><span class="line">sessionConfig.options.store = <span class="keyword">new</span> SequelizeStore(sequelizeObj, &#123;</span><br><span class="line">  sync: <span class="literal">false</span>,</span><br><span class="line">  tableName: <span class="string">'t_session'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session(sessionConfig.options)</span><br></pre></td></tr></table></figure></p>
<p>存储并没有存在内存中，而是存在了数据库里，这里用的<code>koa-generic-session-sequelize</code>。<strong>不放在内存里的原因是有多台机器，存在内存中不能共享应该会有问题。</strong></p>
<p>设置 session cookie 的时候，在前端 cookie 里，就会有对应的值，然后每次请求页面，都会把这个 cookie 带上，去数据库里找对应的 session 是否失效。如果没有失效，认为ok,那么就可以跳过验证的过称了。</p>
<p>还可以加上 app.keys ，然后再对应的 options 里加上  signkeys。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>];</span><br><span class="line">app.keys = <span class="keyword">new</span> KeyGrip([<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>], <span class="string">'sha256'</span>);</span><br><span class="line"></span><br><span class="line">ctx.cookies.set(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这样，你的 cookie 的值，就会被加密了。前端看到的 cookie 可能是一个加密过的串。然后你到服务器端 get cookie 的时候，它会自动帮你解密。得到对应的值去和数据库里的session进行比对。</p>
<p>那如果前端的微信登录态过期了怎么办呢？比较简单，前端发现登录态失败，比如登录态失败的返回码是1111，那么1111时重新拉起微信登录即可。</p>
<hr>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><p>日志管理对于一个大型的项目来说，尤其是涉及到支付的非常重要，他用于帮你查看用户做了什么事情，或者系统出了什么❌。非常的重要。</p>
<p><strong>日志我这里用的 log4js, 分为了四种 category, 分别用来记录 db 操作，访问日志，开发者 debug 信息，cgi 信息日志，错误日志。这些需要放在不同的文件里，便于开发者找问题。</strong></p>
<p>你可以设置不同的 categories, 每个 categories 里设置 level 和不同的 appenders。 每一个 appenders 都可以设置不同 filename 等等。</p>
<p>那么这个 db 的操作日志，怎么打印呢？ sequelize 建立跟 db 链接时，可以传入 logging 这个 option, 在这个 logging 里设置 sequelize 的打印方法。如下面我就是把打印db的操作日志通过 log4js 打入了日志中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.options.logging = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  dbLogger.debug(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="koa2-的错误处理"><a href="#koa2-的错误处理" class="headerlink" title="koa2 的错误处理"></a>koa2 的错误处理</h2><p>这个错误处理的方法，网上到处都是的了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理中间件</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    ctx.response.status = err.statusCode || err.status || <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">      message: <span class="string">'系统繁忙，请稍后再试!'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.app.emit(<span class="string">'error'</span>, err, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js 中接收 error 事件，并且上报到错误日志中</span></span><br><span class="line">app.on(<span class="string">'error'</span>, (err, ctx) =&gt; &#123;</span><br><span class="line"> ctx.errorLogger(<span class="string">`name=<span class="subst">$&#123;err.name&#125;</span>&amp;msg=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(err.message)&#125;</span>&amp;stack=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(err.stack)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里注意如果你直接打印的是 err 对象，一般只有它的 msg 会被打印出来，如果你想要更多信息，一定要把 stack 打出来。这个我疏忽了，同事帮我提出来了，很棒很优秀。</p>
<p>我去网上查了下，这个错误处理其实是 koa2 里的默认方式，只不过我们又自己去重写了，他本身的是这样的：</p>
<p>可以看下这篇文档：<a href="https://github.com/koajs/koa/blob/master/docs/error-handling.md#default-error-handler" target="_blank" rel="noopener">error-handling.md#default-error-handler</a></p>
<p>他里面推荐了一种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// will only respond with JSON</span></span><br><span class="line">    ctx.status = err.statusCode || err.status || <span class="number">500</span>;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: err.message</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>我觉得这种写法并不是很好，因为如果你这个是数据库的某些地方出错了，可能会在 err.message 里暴露一些你机器 ip 及一些其他的信息，这个是不安全的。统一给用户一个回复，然后打到系统错误日志中，是比较好的做法。</strong></p>
<p>这里途中看到了一篇文章： <a href="http://www.52cik.com/2018/05/27/koa-error.html" target="_blank" rel="noopener">大概讲的是koa错误处理的写法</a></p>
<p>注意错误处理最好被当做最前面的一个中间件。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先写这么多，其实还有很多很小的细节。下次再整理整理，当然上面只是我自己的理解，可能也有我理解错了的。我会经常看它，然后看自己是否后面又新的认识来推翻现在的想法。这个项目是我跟着组里另外一个很多年经验的老司机一起做的，在他身上，我学习到了严谨的态度。有很多地方他都比我有经验，也给我指出了一些问题。所以说公司和老板给他那么多工资是应该的啊。优秀哈哈。👍📚</p>
<p>🌲希望下次有机会试下 Vue SSR。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一个多月加了很多班，做了一个比较紧急的项目 Nodejs + Vue全家桶，感觉自己收获多多。今天已经发布了现网版本，趁热总结和梳理下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; 
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://sevencai.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Ajax 请求后台接口【下载文件】方法</title>
    <link href="http://sevencai.github.io/2018/07/11/Ajax-%E8%AF%B7%E6%B1%82%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>http://sevencai.github.io/2018/07/11/Ajax-请求后台接口下载文件方法/</id>
    <published>2018-07-11T14:03:14.000Z</published>
    <updated>2018-07-12T12:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>你的管理台有一个功能是点击<strong>[查看文件]</strong>，下载文件到本地的功能。你可能自然的向后台接口（可能是 Nodejs 的一个 Restful Api）请求下载。但是你发现你后台的 Nodejs 虽然设置了正确的响应头（Content-position, Content-type）却还是没有弹出保存文件的框。</p>
</blockquote>
<p>原因是未经过处理的 ajax（如jquery ajax请求） 请求不能处理正确的二进制（流）类型的文件。</p>
<p>下面我总结了几种方式可以解决此问题-&gt; 📚🌲</p>
<hr>
<h2 id="利用iframe"><a href="#利用iframe" class="headerlink" title="利用iframe"></a>利用iframe</h2><p>Nodejs 端正常的设置相应头，<code>Content-disposition: attachment, filename=</code>。然后读到服务器上对应的文件赋值给 <code>ctx.body</code> 即可。下面是一种参考的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filePath = path.join(path.resolve(__dirname, <span class="string">'../uploads'</span>), $&#123;fileStamp&#125;)</span><br><span class="line"></span><br><span class="line">ctx.set(&#123;</span><br><span class="line">  <span class="string">'Content-disposition'</span>: <span class="string">`attachment; filename=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(fileStamp)&#125;</span>`</span>,</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/octet-stream'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ctx.body = fs.createReadStream(filePath)</span><br></pre></td></tr></table></figure>
<p>前端利用 iframe 的 src 属性，进行重新赋值。注意 iframe 设为 <code>display: none</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe ref=<span class="string">"downloadIframe"</span> src=<span class="string">""</span> frameborder=<span class="string">"0"</span> style=<span class="string">"display: none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击查看时执行 downloadFile</span></span><br><span class="line">downloadFile(fileStamp) &#123;</span><br><span class="line"> <span class="keyword">this</span>.$refs.downloadIframe.src = <span class="string">`/download/<span class="subst">$&#123;fileStamp&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="利用URL-createObjectURL"><a href="#利用URL-createObjectURL" class="headerlink" title="利用URL.createObjectURL"></a>利用URL.createObjectURL</h2><blockquote>
<p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>
<p>一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式。 File 接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。（HTML5新增特性）</p>
</blockquote>
<p>这种方法我已经在上篇文章刚好有用到，可以利用浏览器原生 fetch 方法，然后解析为 blob 类型。再利用a标签的 download 属性即可。参考代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span> (<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cache: <span class="string">'no-cache'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    mode: <span class="string">'cors'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里要是 response.blob()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageData</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchApi(url, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImage</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  getImageData(<span class="string">'/downloadImage'</span>, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">      <span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(response)</span><br><span class="line">      <span class="keyword">let</span> filename = <span class="string">`<span class="subst">$&#123;data.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span></span><br><span class="line"></span><br><span class="line">      a.href = url</span><br><span class="line">      a.download = filename</span><br><span class="line"></span><br><span class="line">      a.click()</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你可以不用 fetch 的这个方法，直接在 xhr 里进行封装。我看到 stackoverflow 上有个很好的文章，地址<a href="https://stackoverflow.com/questions/16086162/handle-file-download-from-ajax-post" target="_blank" rel="noopener">戳这里</a>，我觉的最高回答者已经解释的很好了，下面引用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> filename = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> disposition = xhr.getResponseHeader(<span class="string">'Content-Disposition'</span>);</span><br><span class="line">        <span class="keyword">if</span> (disposition &amp;&amp; disposition.indexOf(<span class="string">'attachment'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> filenameRegex = <span class="regexp">/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/</span>;</span><br><span class="line">            <span class="keyword">var</span> matches = filenameRegex.exec(disposition);</span><br><span class="line">            <span class="keyword">if</span> (matches != <span class="literal">null</span> &amp;&amp; matches[<span class="number">1</span>]) filename = matches[<span class="number">1</span>].replace(<span class="regexp">/['"]/g</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> type = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> blob = <span class="keyword">typeof</span> File === <span class="string">'function'</span></span><br><span class="line">            ? <span class="keyword">new</span> File([<span class="keyword">this</span>.response], filename, &#123; <span class="attr">type</span>: type &#125;)</span><br><span class="line">            : <span class="keyword">new</span> Blob([<span class="keyword">this</span>.response], &#123; <span class="attr">type</span>: type &#125;);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.navigator.msSaveBlob !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="comment">// IE workaround for "HTML7007: One or more blob URLs were revoked by closing the blob for which they were created. These URLs will no longer resolve as the data backing the URL has been freed."</span></span><br><span class="line">            <span class="built_in">window</span>.navigator.msSaveBlob(blob, filename);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">            <span class="keyword">var</span> downloadUrl = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                <span class="comment">// use HTML5 a[download] attribute to specify filename</span></span><br><span class="line">                <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">                <span class="comment">// safari doesn't support this yet</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> a.download === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                    <span class="built_in">window</span>.location = downloadUrl;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a.href = downloadUrl;</span><br><span class="line">                    a.download = filename;</span><br><span class="line">                    <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">                    a.click();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">window</span>.location = downloadUrl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; URL.revokeObjectURL(downloadUrl); &#125;, <span class="number">100</span>); <span class="comment">// cleanup</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send($.param(params));</span><br></pre></td></tr></table></figure>
<p>大概的思路是利用 <code>xhr</code> 原生对象的 <code>onload</code> 后，进行<code>new blob()</code>对象。</p>
<p>再执行<code>URL.createObjectURL(blob)</code>的操作。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实还有别的方法，如 <code>POST</code> 一个请求，但是这个会刷新当前的 <code>Url</code>。上面两种情况其实是两种思路。</p>
<p><code>POST</code> 请求跟 <code>Iframe</code> 类似,同样还可以 <code>window.open</code> 或者 <code>window.location</code> 来做这件事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你的管理台有一个功能是点击&lt;strong&gt;[查看文件]&lt;/strong&gt;，下载文件到本地的功能。你可能自然的向后台接口（可能是 Nodejs 的一个 Restful Api）请求下载。但是你发现你后台的 Nodejs 虽然设置了正确的响应头（Con
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>koa2 生成带场景值参数的带Logo二维码</title>
    <link href="http://sevencai.github.io/2018/06/21/koa2-%E7%94%9F%E6%88%90%E5%B8%A6%E5%9C%BA%E6%99%AF%E5%80%BC%E5%8F%82%E6%95%B0%E7%9A%84%E5%B8%A6Logo%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://sevencai.github.io/2018/06/21/koa2-生成带场景值参数的带Logo二维码/</id>
    <published>2018-06-21T12:14:37.000Z</published>
    <updated>2018-06-21T13:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>上次写 Koa 还是2016年刚来公司实习的时候，那时候我还在上大三。转眼见2年过去了，我也正式工作快一年了。 Koa 也从原来比较难用的 generator ，yield 变成了现在的 async await 。真好。</p>
</blockquote>
<p>这次文章的背景是，产品需要给公众号拉新。需要生成各种带参数的二维码。这个带参数的二维码可以做很多事情，比如统计新拉的关注是从哪个场景值下来的。比如关注时，不同场景值有不同的公众号回复内容。</p>
<p>在经历了好几次每次手动跟她生成后，我下定了决心，跟产品要了2天排期，给她做一个工具。自动生成带 Logo 的二维码。<strong>主要是手工去操作比较繁琐，需要经历下面几步</strong>：</p>
<ol>
<li>先去获得 access_token</li>
<li>再调用微信创建带参数值二维码的接口qrcode/create，获得 ticket</li>
<li>再拿 ticket 换二维码</li>
</ol>
<p>这其中，带参数的二维码又分为了两种，永久和临时二维码。具体接口可以<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1443433542" target="_blank" rel="noopener">参考公众号的文档</a>， 并且每次产品自己拿到 ticket 换的二维码后，还需要自己去 P logo, 大小也要自己去调。总之比较麻烦。</p>
<p><strong>所以这篇文章，主要就是用 Koa2 生成带场景值参数的公众号二维码</strong>。💗🌹</p>
<hr>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>首先我确定了 koa server 端，只做接口层。意思是只用来处理前端的请求。 GET or POST。</p>
<p>前端主要做表单验证，获取产品想要的二维码类型信息等。然后传给后台。后台根据信息，去拿 access_token, 然后调用微信二维码，再添加 logo 等。然后返回给前端。最后的效果是这样的：</p>
<p><img src="qrcode.png" alt="结果图"></p>
<p>产品可以选择，是临时还是永久，选择是只要链接还是下载图片，是否添加 Logo ，图片的大小等等。</p>
<p>最后如果图片类型选的是【我要生成图片】就可以生成类似下面二维码啦， 如果是点击的 【我只要链接】，那么我只会返回一个带ticket的链接。</p>
<p><img src="exampletest.png" alt="生成结果图片"></p>
<p>红色的笔部分是为了遮住二维码信息，因为是自己的测试号。主要用到了下面这些 npm 库： <code>koa-router, koa-static, qr-image, request-promise, stream-to-promise, image-size</code></p>
<hr>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>写起来代码没有特别的地方，用 koa-router 做路由，比如产品选择生成链接，还是生成图片，我选择了路由到两个接口。</p>
<p>在配置文件， route.js 中，配置相应路由的请求以及对应的 controller</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  &apos;post /getLink&apos;: &apos;controllers/createLink&apos;,</span><br><span class="line">  &apos;post /downloadImage&apos;: &apos;controllers/createImage&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表明：</p>
<p>当前端 post getLink 这个接口时， 用 controllers 下的 createLink 来处理。<br>当前端 post downloadImage 这个接口时，用 controllers 下的 downloadImage 来处理。</p>
<p>然后再在自己写个注册路由的 middleware<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app, router</span>) =&gt;</span> (</span><br><span class="line">  <span class="built_in">Object</span>.keys(routesConfig).forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [method, path] = route.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">const</span> controller = <span class="built_in">require</span>(<span class="string">'../'</span> + routesConfig[route])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> controller !== <span class="string">'function'</span> || <span class="keyword">typeof</span> router[method] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'post'</span>) &#123;</span><br><span class="line">      app.use(bodyParser())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.post(path, controller)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后在 入口文件中使用这个 middleware 并且注册到 koa-router 上即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routeMiddleware(App, router)</span><br><span class="line"></span><br><span class="line">App.use(router.routes()).use(router.allowedMethods())</span><br></pre></td></tr></table></figure></p>
<p>最后是对应的 controller 里处理文件, 比如如下是 downloadImage 的 controller, 把 data 传给了核心处理业务流程的类文件。然后再返回相应的图片即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二维码</span></span><br><span class="line"><span class="comment"> * @param ctx</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;void&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Core = <span class="built_in">require</span>(<span class="string">'../server/core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> core = <span class="keyword">new</span> Core(data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> core.downloadQrCodeImage()</span><br><span class="line"></span><br><span class="line">  ctx.type = <span class="string">'png'</span></span><br><span class="line">  ctx.set(<span class="string">'Content-type'</span>, <span class="string">'image/png'</span>)</span><br><span class="line">  ctx.body = result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端接受到这个 image 后，再利用 createObjectURL, revokeObjectURL 立即下载图片即可。下面展示的是前端这一部分处理的逻辑。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span> (<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cache: <span class="string">'no-cache'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    mode: <span class="string">'cors'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageData</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchApi(url, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImage</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  getImageData(<span class="string">'/downloadImage'</span>, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">      <span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(response)</span><br><span class="line">      <span class="keyword">let</span> filename = <span class="string">`<span class="subst">$&#123;data.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span></span><br><span class="line"></span><br><span class="line">      a.href = url</span><br><span class="line">      a.download = filename</span><br><span class="line"></span><br><span class="line">      a.click()</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我用的浏览器原生的 Fetch Api， 因为不想在前端还引入别的库。注意 fetchApi 返回不同的内容，要用不同的内容处理。比如上面的图片是用的 response.blob() 处理，如果是返回的json， 需要用 response.json() 处理。</p>
<hr>
<h2 id="获取-AccessToken"><a href="#获取-AccessToken" class="headerlink" title="获取 AccessToken"></a>获取 AccessToken</h2><p>注意如果没有自己的获取 AccessToken 的中控服务器，一定要缓存 accessToken, accessToken 有过期时间，并且一天有调用上限。部门内有专门的中控服务器，但是我还是自己试了下自己做缓存的流程，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</span><br><span class="line"> <span class="keyword">const</span> cachePath = <span class="string">'./cache/token.txt'</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得 access_token</span></span><br><span class="line"><span class="comment"> * 若缓存文件存在，则从缓存中读取</span></span><br><span class="line"><span class="comment"> * 若缓存文件不存在，调用 update 接口更新</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> getAccessToken () &#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(cachePath)) &#123;</span><br><span class="line">    token = <span class="built_in">JSON</span>.parse(fs.readFileSync(cachePath))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!token || token.timeout &lt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> <span class="keyword">this</span>.updateAccessToken())</span><br><span class="line"></span><br><span class="line">    res.timeout = <span class="built_in">Date</span>.now() + (res.expires_in - <span class="number">200</span>) * <span class="number">1000</span></span><br><span class="line">    fs.writeFileSync(cachePath, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新微信 Access_token</span></span><br><span class="line"><span class="comment"> * 此处有每天调用 2000 次限制</span></span><br><span class="line"><span class="comment"> * 2h 即失效</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> updateAccessToken () &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; appid, appkey &#125; = serverConfig</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;appid&#125;</span>&amp;secret=<span class="subst">$&#123;appkey&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rp.get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于每次调用后，要重新写入文件过期时间，如果过期时间到了，那么重新去更新。之所以拿 re.expires_in - 200, 是为了留点 buffer, 这个值当然可以自己去设置。</p>
<hr>
<h2 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h2><p>这里的 logo, 因为我们公众号只有一个 logo, 故直接是从文件中读取了。以后考虑把这个放在 github 的话，可能会支持用户可以自己上传 Logo。</p>
<p>还有一个地方要注意，就是计算 logo 的位置。直接除以二维码的高宽一半是不行的，还要减去 logo 的一半哦。</p>
<p>我这边在返回给前端下载的时候，也 save 到本地了，担心产品丢失信息。save 的时候，我以场景值和时间为名字，会方便日后好找一些。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加 logo</span></span><br><span class="line"><span class="comment"> * @param imageStream</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> getLogo (imageStream) &#123;</span><br><span class="line">  <span class="keyword">const</span> imgBuffer = <span class="keyword">await</span> streamToPromise(imageStream)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">width</span>: imgWidth, <span class="attr">height</span>: imgHeight &#125; = imgSize(imgBuffer)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> logoWrapper = images(<span class="string">"./static/assets/logo.png"</span>).size(imgWidth / <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> x = (imgWidth - logoWrapper.width()) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> y = (imgHeight - logoWrapper.height()) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.drawImage(imgBuffer, logoWrapper, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画图</span></span><br><span class="line"><span class="comment"> * @param imgBuffer</span></span><br><span class="line"><span class="comment"> * @param logoWrapper</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;any&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> drawImage (imgBuffer, logoWrapper, x, y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> image = images(imgBuffer)</span><br><span class="line">      .draw(logoWrapper, x, y)</span><br><span class="line">      .save(<span class="string">`./static/image/<span class="subst">$&#123;<span class="keyword">this</span>.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span>, &#123;</span><br><span class="line">        quality : <span class="number">50</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">      reject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve(image)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>入口文件跟平常的入口文件基本上没有什么大区别。比较简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line"><span class="keyword">const</span> StaticServer = <span class="built_in">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"><span class="keyword">const</span> routeMiddleware = <span class="built_in">require</span>(<span class="string">'./middleware/route'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">'./static'</span></span><br><span class="line"></span><br><span class="line">App.use(StaticServer(path.join(__dirname, staticPath)))</span><br><span class="line"></span><br><span class="line">routeMiddleware(App, router)</span><br><span class="line"></span><br><span class="line">App.use(router.routes()).use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">App.listen(config.port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;config.port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想当一个优秀的 Nodejs 工程师，但是发现自己还远远不够，比如 fs 的函数不熟。比如对 Buffer, Stream 理解的不够深入。还是写的太少了。不过总算是按时完成了。解放了劳动力。🚫</p>
<p>下一步打算优化下代码，看能不能支持 upload logo, 支持传 appid, appkey, 这样别人也可以用了。还有很多基础工作没有做，比如 async, await 的错误处理，比如 logger, pm2 等。这个会慢慢完善，基础功能已 OK。 📚🏠</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上次写 Koa 还是2016年刚来公司实习的时候，那时候我还在上大三。转眼见2年过去了，我也正式工作快一年了。 Koa 也从原来比较难用的 generator ，yield 变成了现在的 async await 。真好。&lt;/p&gt;
&lt;/blockqu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小程序内嵌复用H5并拉起微信支付解决（替代）方案</title>
    <link href="http://sevencai.github.io/2018/06/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8C%E5%A4%8D%E7%94%A8H5%E5%B9%B6%E6%8B%89%E8%B5%B7%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%A7%A3%E5%86%B3%EF%BC%88%E6%9B%BF%E4%BB%A3%EF%BC%89%E6%96%B9%E6%A1%88/"/>
    <id>http://sevencai.github.io/2018/06/13/小程序内嵌复用H5并拉起微信支付解决（替代）方案/</id>
    <published>2018-06-13T12:45:56.000Z</published>
    <updated>2018-06-13T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>自从小程序出来后，你肯定有这样的想法。小程序内部分页面好想复用以前的H5，重复的去开发浪费了大量的时间和精力。 但是内嵌在小程序中的H5不支持拉起微信支付。也就是说小程序内，小程序嵌入的H5内只能调用小程序支付。</p>
</blockquote>
<p>于是呢，我就想到了这么一个办法。有些山寨，并且不官方（官方当然是希望你直接在小程序内完成一切，下单到支付），但是却可以解决问题。O(∩_∩)O~~☁️❤️</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>我们可以用小程序的 <code>web view</code> 能力嵌入 H5, 嵌入后，在 H5 中进行支付下单，得到参数如 ： <code>timeStamp</code>, <code>nouncestr</code>, <code>signType</code>,<code>paySign</code> 等等参数。然后再通过 <code>wx.miniProgram.navigateTo</code> 跳转到一个小程序页面，在这个页面进行调用 <code>wx.requestPayment</code> 进行拉起支付。拉起支付后，可以再跳到小程序结果页。</strong></p>
<p>如果你担心通过 <code>navigateTo</code> 的 url 传参有不安全的问题，可以自己对参数进行加解密。</p>
<p>亲测是可以行得通的。下图为在 【H5 页面下的单】获得支付参数的页面。</p>
<p><img src="xiaochengxu1.png" alt="下单接口"></p>
<p>下图为图二，【在小程序内拉起的微信支付】。可以通过右上角的转发退出按钮看出是小程序拉起的支付。这样支付完成后，用户可以点击后退退到刚刚的H5页面。</p>
<p>你也可以直接支付完成，调到你自己的小程序的支付结果页等工作。在小程序的支付结果页中，你还可以设置按钮，再来引导用户是进入小程序首页，还是刚刚你跳转的H5的页面等等。</p>
<p><img src="xiaochegnxu2.png" alt="支付接口"></p>
<hr>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>我想把下单的参数以 JSON.stringfy(obj) 的形式传过去，发现参数一直很奇怪的被截断。看到其他有的开发者也遇到了类似的问题。</p>
<p>也就是说下面这种方式是有问题的，以为是特殊字符导致的，但是发现 encode 以后还是被截断。我觉得有可能是小程序本身的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H5 内</span></span><br><span class="line">wx.miniProgram.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">`/pages/wxpay/wxpay?info=<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(obj)&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序内</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="comment">// 因为被截断了，所以这里 JSON.parse 报错</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(options.info)</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="string">'timeStamp'</span>: data.time,</span><br><span class="line">      <span class="string">'nonceStr'</span>: data.nounce,</span><br><span class="line">      <span class="string">'package'</span>: data.package,</span><br><span class="line">      <span class="string">'signType'</span>: <span class="string">'MD5'</span>,</span><br><span class="line">      <span class="string">'paySign'</span>: data.sign,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wx.requestPayment(&#123;</span><br><span class="line">      ...obj,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后来老老实实的用多个参数穿参<code>sign=xxx&amp;signature=xxx&amp;noncestr=xxx</code>，发现 package 中的=后面的部分也被截断了。 <code>encodeURI, encodeURIComponent</code> 都没用。</p>
<p>这里没有想清楚。看了文档和查了资料也没弄清楚小程序在这里面做了什么事情。先放放，把方案跑不跑的通解决。</p>
<p>所以干脆就把 <code>prepay_id= xxx</code> 后面的 <code>xxx</code> 单独取出来。后面调用 <code>requestPayment</code> 再拼上。</p>
<hr>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>最后我测试通过的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H5 内</span></span><br><span class="line">wx.miniProgram.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">"/pages/wxpay/wxpay?time="</span> + info.wx_time + <span class="string">"&amp;nounce="</span> + info.wx_noncenum + <span class="string">"&amp;package="</span>+info.wx_package.split(<span class="string">"="</span>)[<span class="number">1</span>] + <span class="string">"&amp;sign="</span> + info.wx_sign</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序内</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="string">'timeStamp'</span>: options.time,</span><br><span class="line">      <span class="string">'nonceStr'</span>: options.nounce,</span><br><span class="line">      <span class="string">'package'</span>: <span class="string">"prepay_id="</span> + options.package,</span><br><span class="line">      <span class="string">'signType'</span>: <span class="string">'MD5'</span>,</span><br><span class="line">      <span class="string">'paySign'</span>: options.sign,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wx.requestPayment(&#123;</span><br><span class="line">      ...obj,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相较于正常的直接在订单页下订单，这里多了一步，就是从H5跳过来后，还要拉起小程序的一个支付页，单独拉起支付框。</p>
<p>体验当然是没有完全在小程序中，不嵌入H5好的。如果是要快速迭代开发的话，这也是一种方法。</p>
<p>总之知道了这是一种替代的解决方案，或者说一种没有办法的办法。📚🌲还是很开心的。</p>
<p>最后欢迎来到微信-&gt;钱包入口的Qb充值入口来充各种游戏币，Qb, 包月服务哦。有的时候还有优惠。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自从小程序出来后，你肯定有这样的想法。小程序内部分页面好想复用以前的H5，重复的去开发浪费了大量的时间和精力。 但是内嵌在小程序中的H5不支持拉起微信支付。也就是说小程序内，小程序嵌入的H5内只能调用小程序支付。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://sevencai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>晚来的日本之行</title>
    <link href="http://sevencai.github.io/2018/06/02/%E6%99%9A%E6%9D%A5%E7%9A%84%E6%97%A5%E6%9C%AC%E4%B9%8B%E8%A1%8C/"/>
    <id>http://sevencai.github.io/2018/06/02/晚来的日本之行/</id>
    <published>2018-06-02T06:48:05.000Z</published>
    <updated>2018-06-02T08:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实啊，旅行的意义，不一定要是路上的风景，更是你路上的同行人。 2018年5月23 到 27 我在日本。</p>
</blockquote>
<h2 id="TOP-10"><a href="#TOP-10" class="headerlink" title="TOP 10"></a>TOP 10</h2><ol>
<li>干净整洁的日本街道</li>
<li>暖心负责的领队小哥哥  💖</li>
<li>有趣有爱的同伴  🚚</li>
<li>梅田的购物中心  ❄️</li>
<li>250 的牛肉自助餐</li>
<li>大阪大学的王者荣耀</li>
<li>帅气的日本小哥哥</li>
<li>老龄化的日本  💳</li>
<li>好（第四声）吃可爱的小鹿</li>
<li>最爱的许加二和涛哥  🍒</li>
</ol>
<hr>
<h2 id="最爱的图片"><a href="#最爱的图片" class="headerlink" title="最爱的图片"></a>最爱的图片</h2><p><img src="jp4.jpg" alt="奈良的小鹿"><br>或许是太久没有机会跟动物接触了。看到她们简直不能自拔，好想一直喂她们东西吃。上网查了下，她们的点头要吃的，实际在动物界并不是表示友好的行为，越爱鞠躬的小鹿，其实攻击性就越强。但是啊，她一点头，你就不舍得不给她吃东西。</p>
<p><img src="jp1.jpg" alt="干净漂亮的房子"></p>
<p>上面这张图片，是第一天酒店起来后，我跟室友去外边逛的时候拍的。小河特别干净，房子颜色特别美。</p>
<p><img src="jp2.jpg" alt="雨中的小房子"></p>
<p>这张图片是第一天赶到酒店的时候，天下起了小雨，外边有像大熊家一样的房子🏡。觉得特别的舒服。</p>
<p><img src="jp6.jpg" alt="药妆店门口的小狗"><br>小狗过得不开心吗？为什么眼里会有悲伤和难过。</p>
<p><img src="jp5.jpg" alt="可爱的小朋友"><br>猜猜我想拍的小朋友是？</p>
<p><img src="jp3.jpg" alt="酒店的外景"><br>白色的船，蓝蓝的海，高高的树，白色的桌子和椅子，绿色的山。（原谅我的语文水平，只能描述成这种水平了）</p>
<p><img src="jp7.jpg" alt="nuonuonuoyasuolong"><br>吃相扑餐的时候，不好吃。也没有吃饱😞。但是看在送了我 索隆 的份上，5星好评。</p>
<p><img src="jp10.jpg" alt="小狗"><br>其实，印象最深的不仅仅这个小狗，还有他的主人。主人大概60岁，我看狗狗的时候，他冲我笑了下，然后说了一串我听不懂的日语。可能是在说，没关系，你可以摸摸它，他不咬人。</p>
<hr>
<h2 id="最值得的事情"><a href="#最值得的事情" class="headerlink" title="最值得的事情"></a>最值得的事情</h2><p>最值得的事情，当然就是见到徐佳2啦。看着她那个乱的跟猪圈一样的宿舍，我觉得是时候要给她爸爸打报告了，怎么越长大越乱了呢？ 以前我们宿舍4个，她还算排倒数第2的，现在肯定是倒数第1了。</p>
<p>见得时间太少了，已经尽我最大的能力去挤时间。以后要是还去日本，我一定自由行，然后每天都跟她睡。白天一起逛吃逛吃，就像我们一起大学的时候那样。</p>
<p>一个人在外，那种无助的时候，肯定很多。赶紧回国，带你吃小龙虾。💗</p>
<p>在我去日本的时候，涛哥他们部门的团，也正好在日本了，所以很不容易的，我们在日本也见到了，他们为了顺应我的时间，时间很紧张。我们的缘分，肯定还要持续很久，很久🌲。</p>
<hr>
<h2 id="路痴的我"><a href="#路痴的我" class="headerlink" title="路痴的我"></a>路痴的我</h2><p>如果是不赶的路程，我肯定是一个人慢慢悠悠的找地方玩了。就算迷路了也不要紧，反正总能找到回家的路。但是跟团不一样，一定要保证大家不会因为我耽误时间。所以整个路程我就是根本摸不清东南西北。还好有徐佳2，小智和yunhui。</p>
<p>认路这件事，有时候真的感觉无能为力。☹️</p>
<hr>
<h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>给妈妈他们买了两双鞋子，还给嫂子买了很多护肤品，还给同事带了很多护肤品。给爸爸买了个表，哥哥啥都没给买。哈哈，他肯定怀疑我不是亲妹妹。不过，我给他即将出生的小宝宝，买了衣服。给自己还买了很多面膜。<br>通过买东西这件事情，告诉了我一定要努力工作，然后赚很多钱。</p>
<p>第一天晚上，吃了很好吃的冰淇淋🍨。超级开心。还喝了很便宜很好喝的酸奶，日本的便利店🏪是个好地方。</p>
<hr>
<h2 id="路上的人儿"><a href="#路上的人儿" class="headerlink" title="路上的人儿"></a>路上的人儿</h2><p>我这次的室友不是跟我一个部门的。当我提出，能不能徐佳2跟我一起住一晚上的时候，她马上就答应了。真的好谢谢。已经是两个孩子的妈妈了，然而一点都看不出来。👍</p>
<p>我的领队，是跟我一个部门的，但是以前从来没有见过，可能是没有工作上的交集，我们通常称呼他为小智。小智非常的靠谱，也是个超级暖心的小哥哥，每次都帮大家把事情安排的很好。不知道他自己有没有玩好。每次找不到地方了，就跟他打电话。他还每次都帮我提行李。觉得好温暖。笔芯。💖</p>
<p>yunhui, 是跟我一个部门的，以前没有见过，但是有问过他问题。他非常的爱笑，感觉一笑起来，让别人也会开心。yunhui 绝对是个旅行的好伙伴，有足够的好奇心，也有足够的耐力。攻略也做的很棒，关键是也认路。📚</p>
<p>我师父，jiaqian, 飞哥，赵宣，咸鱼, amy， tina就不说了，以前都很熟了,因为他们在，让我觉得这次旅行，一点都不陌生，也不拘谨。</p>
<p>村长，第一次跟他说了话，感觉好开心，还记得他那次诸葛亮把我们整个组虐的超级难受。总算是认识真人了。</p>
<p>日本的小姐姐都说话很小声，很有礼貌。日本的学生都穿制服，感觉很好。很帅气。😊</p>
<p>日本老奶奶跟我说谢谢的时候，我好想回她不用谢。但是憋了半天，满脸通红，还是一个字都没挤出来。</p>
<p>第一天晚上的酒店的小姐姐，想把伞还给她，一路上，想了半天怎么还给她，结果到了那里，一个字都没有说出来。☹️</p>
<p>我们的导游，朴岛很温和，已经加了他微信，加了后，整个朋友圈，都是代购的消息了，哈哈。朴导萌萌哒。✈️</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很开心的一次旅行，虽然信用卡💳都没知觉了。一生会有很多旅行，但是这次肯定是独一无二的。你遇到的风景，你遇到的人，你拍的照片，你脑海里那个爷爷的微笑，你对某些人的感情，又或者是旅行中不那么顺利开心的地方，都是旅行的宝贵所在。</p>
<p>我有的时候想，人生那么不可预测，也许明天你就没有机会去体验很多事情。所以你今天做的事情，会不会是最后一天你想做的事情。不要后悔。也不要遗憾。因为上帝给你留下的路，都是有他的道理。开心的，不开心的，它都是你生活中，或者说命运中的一部分。</p>
<p>我相信 connecting the dots。 ❤️ 🚚 📚 以后有机会跟家人一起去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实啊，旅行的意义，不一定要是路上的风景，更是你路上的同行人。 2018年5月23 到 27 我在日本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TOP-10&quot;&gt;&lt;a href=&quot;#TOP-10&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="生活日志" scheme="http://sevencai.github.io/tags/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>优化代码之throttle &amp; debounce</title>
    <link href="http://sevencai.github.io/2018/06/02/%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E4%B9%8B-throttle-debounce/"/>
    <id>http://sevencai.github.io/2018/06/02/优化代码之-throttle-debounce/</id>
    <published>2018-06-02T06:09:15.000Z</published>
    <updated>2018-06-02T06:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这几天翻了下以前写的代码，发现自己以前虽然有用 debounce 或者 throttle 的意识，但是确没有把代码封装的很好。比如没有用到闭包去封装 timer, 而是把 timer 放在了 vue data 的变量里。因此就出现了这篇文章，总结下 debounce 和 throttle 运用场景以及对应的自己的实现。并且重构了以前的代码。</p>
</blockquote>
<hr>
<h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>比如我曾经在一个项目里，就两种场景都用到了。</p>
<p>第一种比如当用户在搜索框里输入了数据的时候，我会去向后台请求，搜索出来的对应结果。 但是用户的输入可能是不断的进行的，如果我每次都去请求，那么其实是无效并且浪费的。<strong>所以我们可以在用户输入最后一个字的时候，再去发请求。 用到的就是 debounce 的原理，每次的请求都延迟一段时间去发出，当有新的请求来的时候，清空上次的请求，然后重新执行延迟一段时间去请求，直到用户没有再请求的时候，执行的就是最后一次延迟请求</strong>。</p>
<p>这种只去执行最后一次的就是我们说的 debounce。可以把它理解为<code>独占型的函数</code>。</p>
<p>第二种比如当用户滚动的时候，当滑到了这个字母开头的时候，提示给用户，你已经到了 H 开头的列表内容了。正常的情况下，我们的做法是一直监听 scroll 事件，然后计算当前的 li 是不是到了对应 H 字母开头了，到了则设置相应的提示。</p>
<p><strong>但是要知道 scroll 事件，每次都会触发很多次，如果每次进行相应的计算，就会很卡顿，尤其在一些老的机器上。 那么这个时候我们就可以用 throttle 了，每一段事件，比如 500 ms 去执行一次计算，而不是每次 scroll 都执行。</strong></p>
<p>可以把 throttle 理解为<code>节制型</code>的函数。</p>
<p>上面两个是我遇到过的两个场景，具体其他场景还可以参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 onresize 的时候，我们只想知道最后一次的大小</span></span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(caculate, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户一段时间频繁点击时，只以最后一次为标准</span></span><br><span class="line">button.onclick = debounce(sendMail, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// onscroll 时定位元素</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(caculatePosition, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动，mousemove 事件</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = throttle(getElement, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>在 underscore lodash 里，都有相应的实现了。但是我感觉不太好理解额，所以按照自己的理解，写出了适应自己的 debounce 和 throttle。 具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * debounce</span><br><span class="line"> * @param fn</span><br><span class="line"> * @param wait</span><br><span class="line"> * @param leading</span><br><span class="line"> * @returns &#123;Function&#125;</span><br><span class="line"> */</span><br><span class="line">function debounce(fn, wait, &#123; leading = false &#125;) &#123;</span><br><span class="line">    let context,</span><br><span class="line">      args = arguments,</span><br><span class="line">      timer = null,</span><br><span class="line">      firstInvoke = true</span><br><span class="line"></span><br><span class="line">    function excute() &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">      context = this</span><br><span class="line"></span><br><span class="line">      if (firstInvoke &amp;&amp; leading) &#123;</span><br><span class="line">        excute()</span><br><span class="line">        firstInvoke = false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = setTimeout(excute, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leading 参数用于控制第一次是否需要在最开始就触发一次。主要的思想就是只要重新有调用，就把原来的那个被延迟执行了的方法取消。 取消的方法是设置 timer 为 null。firstInvoke 用于标识方法知否被执行了一次了。</p>
<p>下面是 throttle 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* throttle</span><br><span class="line">* @param fn</span><br><span class="line">* @param wait</span><br><span class="line">* @param leading</span><br><span class="line">* @param trailing</span><br><span class="line">* @returns &#123;Function&#125;</span><br><span class="line">*/</span><br><span class="line">function throttle(fn, wait, &#123; leading = true, trailing = true &#125;) &#123;</span><br><span class="line">    let context, lastExec = 0, timer, args, firstInvoke = true</span><br><span class="line"></span><br><span class="line">    function excute() &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line"></span><br><span class="line">      lastExec = +new Date()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function (...arg) &#123;</span><br><span class="line">      let now = +new Date()</span><br><span class="line"></span><br><span class="line">      args = arg</span><br><span class="line"></span><br><span class="line">      context = this</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">      if (firstInvoke &amp;&amp; leading) &#123;</span><br><span class="line">        excute()</span><br><span class="line">        firstInvoke = false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!lastExec) &#123;</span><br><span class="line">        lastExec = now</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!!wait &amp;&amp; (now - lastExec) &gt;= wait) &#123;</span><br><span class="line">        excute()</span><br><span class="line">      &#125; else if (trailing) &#123;</span><br><span class="line">        timer = setTimeout(excute, wait)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>throttle 因为是按频率触发，所以每次的时间间隔是相同的。所以当没到该执行的时间点的时候，就把剩余的时间重新设置给 setTimeout 。wait 即为多少秒执行一次的时间。看了 underscroll 里的源码，它还设置了 trailing 这些参数。trailing 表示当最后一次没到执行时间时，你不想要延迟执行这个函数了。也就是最后一次调用将被忽略。</p>
<p>下面贴一下 underscroll 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Returns a function, that, when invoked, will only be triggered at most once</span><br><span class="line">// during a given window of time. Normally, the throttled function will run</span><br><span class="line">// as much as it can, without ever going more than once per `wait` duration;</span><br><span class="line">// but if you&apos;d like to disable the execution on the leading edge, pass</span><br><span class="line">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">  var timeout, context, args, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function() &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : _.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    if (!timeout) context = args = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function() &#123;</span><br><span class="line">    var now = _.now();</span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = function() &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = 0;</span><br><span class="line">    timeout = context = args = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>underscore 把 throttle 和 debounce 分开来实现了，但是有些别的封装的库则是用一个函数实现。下面是 underscore debounce 的实现</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Returns a function, that, as long as it continues to be invoked, will not</span><br><span class="line">  // be triggered. The function will be called after it stops being called for</span><br><span class="line">  // N milliseconds. If `immediate` is passed, trigger the function on the</span><br><span class="line">  // leading edge, instead of the trailing.</span><br><span class="line">  _.debounce = function(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var later = function(context, args) &#123;</span><br><span class="line">      timeout = null;</span><br><span class="line">      if (args) result = func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var debounced = restArguments(function(args) &#123;</span><br><span class="line">      if (timeout) clearTimeout(timeout);</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        var callNow = !timeout;</span><br><span class="line">        timeout = setTimeout(later, wait);</span><br><span class="line">        if (callNow) result = func.apply(this, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        timeout = _.delay(later, wait, this, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剩下的时间就是去优化代码啦。看了下别人的源码，然后自己又按照自己的方式实现了下，还是很有收获的。</p>
<p>不过，如果 underscore 已经有这么成熟的东西，实际上，我觉得可以不用重复的去做这个工作。用别人成熟的内容就好了。自己了解了原理，自己可以实现，有问题知道怎么去查就好。</p>
<p><img src="xixi.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天翻了下以前写的代码，发现自己以前虽然有用 debounce 或者 throttle 的意识，但是确没有把代码封装的很好。比如没有用到闭包去封装 timer, 而是把 timer 放在了 vue data 的变量里。因此就出现了这篇文章，总结下
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>解决webpack编译后导致-webkit-box被强制去除了的问题</title>
    <link href="http://sevencai.github.io/2018/05/11/%E8%A7%A3%E5%86%B3webpack%E7%BC%96%E8%AF%91%E5%90%8E%E5%AF%BC%E8%87%B4-webkit-box%E8%A2%AB%E5%BC%BA%E5%88%B6%E5%8E%BB%E9%99%A4%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sevencai.github.io/2018/05/11/解决webpack编译后导致-webkit-box被强制去除了的问题/</id>
    <published>2018-05-11T12:12:36.000Z</published>
    <updated>2018-05-11T12:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天遇到了一个问题，发现重构同事的 dist css 在我这里有兼容性问题。我只引用了他的源文件，未经过任何更改。排处了由于 Dom 结构不同的原因之外，唯一的不一样的地方，就是我引入他的文件后，在本地还进行了webpack 编译。那么问题只能出在了这里了。</p>
<p>经过对比两份文件发现，对比如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 重构同事的css</span><br><span class="line"><span class="selector-class">.detail-title</span>&#123;</span><br><span class="line">	<span class="attribute">-ms-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">-webkit-box-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">box-flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">// 我编译后的文件</span><br><span class="line"><span class="selector-class">.detail-title</span>&#123;</span><br><span class="line">	<span class="attribute">-ms-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">box-flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咦， <code>-webkit-box-flex</code> 竟然被自动去除了。难道说在某种 webpack 插件下， <code>-webkit-box</code> 会自动被去除吗？</p>
<p>在网上搜了下，发现确实是有这种情况。有些插件的机制判断这个内容是不需要的，强行被去除了。可以看这个 <a href="https://github.com/webpack/webpack/issues/2543" target="_blank" rel="noopener">issue</a>。</p>
<p>即使你是使用了 postCss, autoprefix 去添加了前缀，但是你用了去除的插件也会被去除。</p>
<hr>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>首先看下是什么插件导致了你的代码被强制的去除了。</p>
<p>大概的原因可能有以下几种：</p>
<p><strong>最开始可能是由于 <code>UglifyJsPlugin</code> 中默认把 <code>minimize = true</code> 开启了， 而这个字段在<code>css-loader</code>和<code>postcss-loader</code>中设置成 <code>true</code> 会开启优化模式，所以会对代码进行优化压缩。<br>但 <code>css-loader</code> 中又会使用 <code>cssnano</code> 进行压缩， 而 <code>cssnano</code>中又会进行无关前缀的清理。</strong></p>
<p>为什么插件竟然会影响到loader ? 可以关注下这个 <a href="https://github.com/ShowJoy-com/showjoy-blog/issues/31" target="_blank" rel="noopener">issue</a>。</p>
<p>这个插件(UglifyJsPlugin) 在 webpack2.x 貌似已经修复了。 <code>css-loader</code>及<code>autoprefixer</code>也已经做了相应的优化处理。如果你没有升级，你可以设置下面的方式试试：</p>
<ol>
<li><p>css-loader 传递参数：<code>?minimize&amp;-autoprefixer</code></p>
</li>
<li><p>向 <code>autoprefixer</code> 传递参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postcss: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [autoprefixer, cssnano(&#123; <span class="attr">safe</span>: <span class="literal">true</span> &#125;)];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果还有问题，再检查下，代码里有没有用到其他的去除优化工具。</p>
<p>我这边出的问题就是在这里。用了<code>OptimizeCSSPlugin</code>,  它默认把前缀给去掉了。所以这里我直接把这个 plugin 删除了。之所以我这里可以直接删除，是因为重构同事给到的就是去除压缩好了的。没有必要再去压缩去除一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">// duplicated CSS from different components can be deduped.</span><br><span class="line"></span><br><span class="line">new OptimizeCSSPlugin(&#123;</span><br><span class="line">  cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">    ? &#123; safe: true, map: &#123; inline: false &#125; &#125;</span><br><span class="line">    : &#123; safe: true &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>再来看下为什么用了<code>OptimizeCSSPlugin</code>去除了prefix呢？看了下源码，也是又引入了<code>cssnano</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.options.cssProcessor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.options.cssProcessor = <span class="built_in">require</span>(<span class="string">'cssnano'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引申问题-ssi-找不到定义的变量"><a href="#引申问题-ssi-找不到定义的变量" class="headerlink" title="引申问题 - ssi 找不到定义的变量"></a>引申问题 - ssi 找不到定义的变量</h1><p><strong>由这个打包的问题，想到了前几天的另一个 webpack 的问题， index.shtml 文件中引入的 ssi, 如果变量用 ${variable} 读取，而不是$variable 读取，webpack 编译时就会报错。</strong>但实际上，这两种语法都是可以被 server 端解析的。探究了下会被报错的原因：</p>
<p>webpack 的 HtmlWebpackPlugin 在编译模板的时候，用的是 lodash 的 template 方式, 也就是 <code>${variable}</code> 的形式。</p>
<p>所以你用了 ${variable} 的形式的话，他就会去编译这个变量，但是呢，这个 variable 你是从 ssi 上读的，又没有定义，它找不到，所以就会报错了。</p>
<p>所以就老老实实的，如果你用的 htmlWebpackPlugin 就用 <code>$varialbe</code> 的形式吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// correct</span><br><span class="line">&lt;!--#include virtual=&quot;xxx.cgi?refresh_token=$wxRefreshToken&amp;appid=$wxAppid&quot; --&gt;&apos;;</span><br><span class="line"></span><br><span class="line">// wrong: wxAppid is not defined</span><br><span class="line">&lt;!--#include virtual=&quot;xxx.cgi?refresh_token=$wxRefreshToken&amp;appid=$&#123;wxAppid&#125;&quot; --&gt;&apos;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ol>
<li><a href="https://github.com/webpack/webpack/issues/283" target="_blank" rel="noopener">issue1: # Why does the UglifyJsPlugin affect other loaders?</a></li>
<li><a href="https://github.com/ShowJoy-com/showjoy-blog/issues/31" target="_blank" rel="noopener">issue2: # 「前端」从UglifyJSPlugin强制开启css压缩探究webpack插件运行机制</a></li>
<li><a href="https://github.com/webpack/webpack/issues/2543" target="_blank" rel="noopener">issue3: # Using plugin “webpack.optimize.UglifyJsPlugin” led to remove the style “display: -webkit-flex;</a></li>
</ol>
<p>觉得略坑。还是花了大概一下午看这个问题，呜呜呜(ಥ _ ಥ)!</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天遇到了一个问题，发现重构同事的 dist css 在我这里有兼容性问题。我只引用了他的源文件，未经过任何更改。排处了由于 Do
    
    </summary>
    
    
      <category term="工具" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>小程序支持分包加载和无需用户授权获得头像</title>
    <link href="http://sevencai.github.io/2018/04/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%85%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%97%A0%E9%9C%80%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E8%8E%B7%E5%BE%97%E5%A4%B4%E5%83%8F/"/>
    <id>http://sevencai.github.io/2018/04/23/小程序支持分包加载和无需用户授权获得头像/</id>
    <published>2018-04-23T06:56:06.000Z</published>
    <updated>2018-04-23T07:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>结论：增加了分包加载特性，速度快了很多。修改了用户授权逻辑，使用 open-data 能力改为了完全不用用户授权即可获得昵称头像群名称等。</p>
</blockquote>
<hr>
<h1 id="改版效果"><a href="#改版效果" class="headerlink" title="改版效果"></a>改版效果</h1><p>星期六的时候把手边的小程序改为了分包加载。产品是没有提这个需求的，但是心想下次做小程序的需求估计要很久以后了，就星期六加了下班。效果还是很好的。</p>
<blockquote>
<p>首屏加载时间由： 7.95s 减少到了 5.00s<br>平均 cpu 占比右：19.19% 减少到了 4.77%</p>
</blockquote>
<p>我并不知道很清楚这个平均 cpu 占比是怎么被算出来的。如果这个数据的变化能够微信团队能够解释的更详细些就好了。</p>
<p>在分包的加载过程中，比如首页是一个 packageA， 到列表页是一个 packageB, 这个过程在第一次访问列表页的时候，会再去下载代码。微信在这个过程中帮助了开发者显示了提示： 类似于页面加载中。 这个还是很友好的。</p>
<p>但是使用分包加载给开发者带来的成本也很大，基本上目录都被更改了。结构也被更改了。其实我是觉得如果能够不更改目录，只在 json 里面配置好打包的方案是最好的。其实仔细想想不更改目录也是行的吧？</p>
<blockquote>
<p>小程序经历过几次的“改版”，最开始的 pages, 后来的 component, 先在的 subPackage, 虽然一直再变得更好，但是对于一开始就开发小程序的开发者来说，或者至少对我来说，是不那么友好的。以后等这里逐渐更加成熟了，应该会好的。</p>
</blockquote>
<hr>
<h1 id="怎么开发分包加载"><a href="#怎么开发分包加载" class="headerlink" title="怎么开发分包加载?"></a>怎么开发分包加载?</h1><p>首先开始把目录结构定好，配置在 app.json 里，这个配置实际就是小程序会怎么分包加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/index/index"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>: &#123;</span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>: <span class="string">"light"</span>,</span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#3b8cff"</span>,</span><br><span class="line">    <span class="string">"backgroundColor"</span>: <span class="string">"#3b8cff"</span>,</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"腾讯充值"</span>,</span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>: <span class="string">"light"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"subPackages"</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="string">"root"</span>: <span class="string">"result"</span>,</span><br><span class="line">	  <span class="string">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/result/result"</span></span><br><span class="line">	  ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"root"</span>: <span class="string">"userCenter"</span>,</span><br><span class="line">	  <span class="string">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/user_center/user_center"</span></span><br><span class="line">	  ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的目录结构，除了个人中心以及结果页以外的内容都是会在第一次下载了。 待页面跳转到 result 结果页，相关代码才会被下载并加载。</p>
<p>注意由于页面的目录发生了变化，以前如果是通过相对路径引用如 util 里的文件，那么路径都是要更改的。建议这里都使用 <code>/images/a.png</code> or <code>/utils/a.js</code>这种绝对路径比较好。</p>
<hr>
<h1 id="怎么获得昵称还不需要用户授权？"><a href="#怎么获得昵称还不需要用户授权？" class="headerlink" title="怎么获得昵称还不需要用户授权？"></a>怎么获得昵称还不需要用户授权？</h1><p>前天微信发布了新的文章，地址<a href="https://mp.weixin.qq.com/s/FTVGVXHSWPlYN1oQTzj-mA" target="_blank" rel="noopener">戳这里</a>,里面讲到了：</p>
<blockquote>
<p> 用户在没有任何操作的情况直接弹出授权的登录方式将逐渐不再支持，受影响的有 wx.getUserInfo 接口，以及 wx.authorize 接口传入 scope=”scope.userInfo” 的情况。</p>
</blockquote>
<p>它推荐了两种做法：</p>
<blockquote>
<p>1、按钮组件的登录方式，用户主动点击按钮可以拉起用户授权弹框，获取用户头像、昵称等信息；<br>2、在不获取用户信息的情况下，可展示用户头像昵称。</p>
</blockquote>
<p>第一种用于你真的是需要获得到昵称和图标，做一些其他的工作，比如存储的工作。这种情况，开发者是可以得到昵称和图标的值的。但是它也需要用户去触发，比如你点击个人中心的时候，是一个 btn, 这个 button, 会调用 getUserInfo 这种操作。</p>
<p><code>&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;userInfoHandler&quot;&gt;微信登录&lt;/button&gt;</code></p>
<p>注意既然还是调用了授权，那么一定还是会弹框提示用户是否允许授权，如果用户拒绝了也是得不到的。</p>
<p>第二种，如果你只是需要用户的昵称和头像展示在页面里，而不是真正的需要获得这些数据存储在某个地方或者向后台接口传递这些值。那么就告别<code>wx.authorize</code>和<code>wx.getUserInfo</code>吧。</p>
<p>我仔细想了下我们的充值页面，存储的都是 openid，没有需要去真正的用到 nickName 和 avatar 这些。只是为了再页面展示而已，所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;open-data type=&quot;groupName&quot; open-gid=&quot;xxxxxx&quot;&gt;&lt;/open-data&gt;</span><br><span class="line">&lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt;</span><br><span class="line">&lt;open-data type=&quot;userGender&quot; lang=&quot;zh_CN&quot;&gt;&lt;/open-data&gt;</span><br></pre></td></tr></table></figure>
<p>利用 open-data 既可以完美的解决啦。 也可以给它加入 class, 跟正常的 view 是类似的。</p>
<p>这样就完美啦，以后再也不需要用户授权啦。嘿嘿嘿。（产品开心，我也开心）</p>
<p>对了这里注意，open-data 只能在真机上试出来，我的目前版本的开发者工具是展示不出来的。如果你开发者工具上出不来，就试试真机。可能是版本原因。</p>
<hr>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote>
<p>微信 6.6 客户端，1.7.3 及以上基础库开始支持，请更新至最新客户端版本，开发者工具请使用 1.01.1712150 及以上版本</p>
</blockquote>
<p>注意这里的分包加载必须在1.7.3及以上开始支持。为了能够在 1.7.3 以下至少页面正常。你可以兼容。或者再微信公众平台后面来设置，最低版本为 1.7.3,这种情况下：</p>
<blockquote>
<p>若用户使用的基础库版本低于设置的最低版本要求，则无法正常使用小程序，并提示更新微信版本。</p>
</blockquote>
<p>open-data 是在 1.4.4 以上，好像，所以如果你设置了分包加载的，那么这个肯定也没问题啦。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要是代码目录结构改变了，导致比如以前代码里的 <code>navigateTo({url: &#39;../../result/result&#39;})</code>路径都需要改变，这些话费了时间重构。但是看到结果上是快了这么多的就好。</p>
<p>还有就是为什么 page 里不能用 behavior? 只有 component 里面能用？ 这个我感觉不太合理。vue 里面 每个 page 也是一个 component 来着。</p>
<p>其实插件的功能我也想试试，但是现在还没有想到可以使用的场景。也许是以后可以像交易记录这种做成小程序，别的外部业务就可加了吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;结论：增加了分包加载特性，速度快了很多。修改了用户授权逻辑，使用 open-data 能力改为了完全不用用户授权即可获得昵称头像群名称等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;改版效果&quot;&gt;&lt;a href=&quot;#改版效果&quot; c
    
    </summary>
    
    
      <category term="小程序" scheme="http://sevencai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>长列表图片优化方式</title>
    <link href="http://sevencai.github.io/2018/03/22/%E9%95%BF%E5%88%97%E8%A1%A8%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://sevencai.github.io/2018/03/22/长列表图片优化方式/</id>
    <published>2018-03-22T09:57:50.000Z</published>
    <updated>2018-03-22T11:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在的一个项目中，本来不长的列表页变得很长很长。并且每个<code>li</code>都会有一个图片。这就迫使我必须要想办法优化这个长列表了。以前总以为是不是对于长列表而言性能的瓶颈更多在与 dom 和js, 但是实际上图片仍然也占很大一部分。为了用户考虑，怎么样减少图片带来的流量，对于节省带宽及用户的电池十分重要。</p>
</blockquote>
<p>长列表可以从以下这几个方面去优化：</p>
<hr>
<h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>图片懒加载，长列表最大的问题就是图片太多，如果一次性把图片全部请求了，那么页面渲染速度会很慢，如果用户点不到，还会造成很大的浪费，甚至会有性能瓶颈。</p>
<p>为什么要使用懒加载呢？为了加速页面的加载速度，减少不必要的请求，我们可以将未出现在可视区域的图片先不做加载，等到滚动到可视区域以后再去加载。这样提升了性能和提高了用户体验。</p>
<p>那么原理就很简单了：<strong>一开始时，所有图片都有一个默认的 src, 指向本地的一个 <code>default.png</code> ,并且把img的真实的地址放在 <code>data-src</code>上。当滚动时，判断元素是否在可视区域，如果在可视区域,那么再把 <code>data-src</code> 上的值写入真正的 src 中。</strong></p>
<hr>
<h1 id="从图片本身优化"><a href="#从图片本身优化" class="headerlink" title="从图片本身优化"></a>从图片本身优化</h1><p>第二种思路就是从图片的本身去优化，比如更换图片格式。由 png,jpg,jpeg,gif 转换为更好的 webp。</p>
<blockquote>
<p><strong>WebP 的优势在与它更好的图像数据压缩算法，能够将图片转换为更小的体积，具有无损和有损的压缩模式。如果是选择了有损压缩，也拥有肉眼无法识别差异的图像质量。虽然它在页面渲染的时候浏览器比jpg会花稍长的时间解析它的算法，但是权衡它所带来的体积的减少来看，WebP 还是最优秀的。</strong></p>
</blockquote>
<p>关于它的有损和无损来说，无损的体积减少会稍微小一些，而有损的体积会减少的非常多。如果不是对图片质量要求很多，对于一般的图片，用有损就很好了。<strong>webp无损压缩可以减少图片一半的大小而达到同样无损的效果。</strong>可以看下面一份数据：</p>
<blockquote>
<p>YouTube的视频缩略图采用WebP后，网页加载速度提升了10%；谷歌网上应用商店采用WebP后，每天可节省几TB的带宽，页面平均加载时间大约减少1/3；谷歌移动应用市场采用WebP图片格式后，每天节省了50TB的存储空间；2014年腾讯新闻客户端应用了WebP后，流量峰值带宽降低9GB，网络连接延时不变的前提下，平均图片延时和数据下载延时降低了100ms；2014年空间装扮也全量转换成WebP，带宽上也有显著降低。</p>
</blockquote>
<p>但是 WebP 不是每个浏览器都支持。所以要实践的话可以从下面两个方面考虑：</p>
<p>从服务端考虑：<br>如果浏览器支持 WebP ,那么会在 request header  accept里，发送<code>image/webp</code>, 服务器收到以后根据这个来去返回给客户端图片。请求头里有，则发送webp的，如果没有，就发送普通jpg的。</p>
<p>不过这个对服务器要求比较高，并且现在图片大多放在 <code>CDN</code> 上，<code>CDN</code>去做这种策略可能会稍微麻烦点。</p>
<p>从前端考虑：<br>前端去检测浏览器是否支持 WebP, 支持就发送 WebP 的图片请求，不支持就发送 JPG,PNG 等的。下面是一行代码判断是否支持WebP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isSupportWebp = !!\[\].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;</span><br></pre></td></tr></table></figure>
<p><code>!!\[\].map</code>主要是判断是否是IE9+，以免<code>toDataURL</code>方法会挂掉。如果你直接对数组原型扩展了map方法，则需要使用<code>!!\[\].map</code>以外的方法进行判断，例如<code>!!window.addEventListener</code>等。</p>
<p>哈哈，这个我是偶然在zhangxinxu的博客上看到的，感觉这个要比其他的方法更加简洁和好。<a href="http://www.zhangxinxu.com/php/microCodeDetail.php?id=3" target="_blank" rel="noopener">地址在这里。</a></p>
<p>最后我没有做这一层优化，因为图片太多，已经被发到了CDN 上，图片源可能都不在了，没有让他们去把图片变成 WebP。 如果一开始就问 CDC 的同事要两种图片格式就好了。sad。</p>
<hr>
<h1 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h1><p>首先有两种判断元素是否在可视区域的方法：</p>
<ol>
<li>offsetTop - scrollTop &lt; clientHeight ，代表在可视区。</li>
<li>IntersectionObserver，这个 Api 可以直接来判断。</li>
</ol>
<p>注意可以用 throttle 防止请求次数过高，在一定的时间范围内只请求1次。下面的代码是随意写的，没有跑过。可以当做伪码来看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const checkVisible = (ele) =&gt; &#123;</span><br><span class="line">  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">  let clientHeight = document.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">  return ele.offsetTop - scrollTop &lt; clientHeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let imgs = document.getElementsByTagName(&quot;img&quot;), nums = imgs.length</span><br><span class="line"></span><br><span class="line">const lazyLoad = () =&gt; &#123;</span><br><span class="line">  for (let i = 0; i &lt; nums; i++) &#123;</span><br><span class="line">    if (checkVisible(imgs[i]) &amp;&amp; imgs[i].getAttribute(&quot;src&quot;) === &quot;default.png&quot;) &#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(&quot;data-src&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const throttle = (action, delay) =&gt; &#123;</span><br><span class="line">  let timeout = null</span><br><span class="line">  let lastRun = 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (timeout) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let elapsed = Date.now() - lastRun</span><br><span class="line">    let context = this</span><br><span class="line">    let args = arguments</span><br><span class="line">    let runCallback = function () &#123;</span><br><span class="line">      lastRun = Date.now()</span><br><span class="line">      timeout = false</span><br><span class="line">      action.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">    if (elapsed &gt;= delay) &#123;</span><br><span class="line">      runCallback()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout = setTimeout(runCallback, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;scroll&quot;, throttle(lazyLoad, 1000))</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h1><p>因为项目本身是Vue写的，所以我也去在网上找了相应的<code>directives</code>, 已经有了很好的一些实现。他们的比较完整，比如下面这个：<a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">https://github.com/hilongjw/vue-lazyload</a>，用法很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  attempt: 2,</span><br><span class="line">  listenEvents: [&quot;scroll&quot;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后再 img 标签上，使用这个 <code>directive</code>， <code>v-lazy</code> 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;mod-service__pic&quot; v-lazy=&quot;list.icon&quot; aria-hidden=&quot;true&quot; v-bind:alt=&quot;list.name&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在做这个过程中，我还看了一些其他的内容，比如 png8, png24, svg,这些。也去看了下vue-lazyload这个库的源码。收货多多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在的一个项目中，本来不长的列表页变得很长很长。并且每个&lt;code&gt;li&lt;/code&gt;都会有一个图片。这就迫使我必须要想办法优化这个长列表了。以前总以为是不是对于长列表而言性能的瓶颈更多在与 dom 和js, 但是实际上图片仍然也占很大一部分。为
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>isObjEmpty/once function/template rendering/cdn的实现和解释</title>
    <link href="http://sevencai.github.io/2018/03/21/isObjEmpty-once-function-template-rendering-cdn%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%A7%A3%E9%87%8A/"/>
    <id>http://sevencai.github.io/2018/03/21/isObjEmpty-once-function-template-rendering-cdn的实现和解释/</id>
    <published>2018-03-21T03:03:57.000Z</published>
    <updated>2018-03-21T03:18:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>总结了几种判断 Object 是否为空的方法<br>总结 once function (只执行一次函数代码)<br>实现两种简单的字符串模板替换方法<br>重新归纳总结了下CDN和DNS的名词解释</p>
</blockquote>
<hr>
<h1 id="once-function-让函数只执行一次"><a href="#once-function-让函数只执行一次" class="headerlink" title="once function 让函数只执行一次"></a>once function 让函数只执行一次</h1><p>这里利用了闭包很好的保存了内层函数的返回值内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">const once = (fn, context) =&gt; &#123;</span><br><span class="line"> var result</span><br><span class="line"></span><br><span class="line"> return function () &#123;</span><br><span class="line">  if (fn) &#123;</span><br><span class="line">   result = fn.apply(context || this, arguments)</span><br><span class="line">   fn = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let logOnce = once(function () &#123;</span><br><span class="line"> return Array.prototype.slice.call(arguments)[0]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logOnce(4,5)  // get 4</span><br><span class="line">logOnce(6,7)  // get 4</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="实现简单的模板字符串替换"><a href="#实现简单的模板字符串替换" class="headerlink" title="实现简单的模板字符串替换"></a>实现简单的模板字符串替换</h1><p>经常会有下面的需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let template = `我叫&#123;&#123;name&#125;&#125;, 我的性别是&#123;&#123;sex&#125;&#125;`</span><br><span class="line">let person = &#123;</span><br><span class="line"> name: &apos;Seven&apos;,</span><br><span class="line"> sex: &apos;female&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;我叫Seven, 我的性别是female&apos;)</span><br></pre></td></tr></table></figure></p>
<p>下面是一种简单的实现，把模板和对象，结合为目标字符串，方法1如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const parseTemplateByRegFunc = (obj, template) =&gt; &#123;</span><br><span class="line"> return template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; obj[key.trim()])</span><br><span class="line">&#125;</span><br><span class="line">parseTemplateByRegFunc(&#123;name: &apos;seven&apos;&#125;, &apos;我叫&#123;&#123; name&#125;&#125;&apos;) // 我叫seven</span><br></pre></td></tr></table></figure></p>
<p>方法2比较容易想到，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const parseTemplateByObjectKeys = (obj, template) =&gt; &#123;</span><br><span class="line"> Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">  template = template.replace(new RegExp(`&#123;&#123;\\s*$&#123;key&#125;\\s*&#125;&#125;`, &apos;g&apos;), obj[key])</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> return template</span><br><span class="line">&#125;</span><br><span class="line">parseTemplateByObjectKeys(&#123;name: &apos;seven&apos;&#125;, &apos;我叫&#123;&#123; name&#125;&#125;&apos;) // 我叫seven</span><br></pre></td></tr></table></figure></p>
<p>简单的把 obj 里面每个key 都替换一次。方法1用到的是replace的特性。</p>
<hr>
<h1 id="关于-CDN"><a href="#关于-CDN" class="headerlink" title="关于 CDN"></a>关于 CDN</h1><p>DNS 是域名解析系统，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。其中有一项技术是会找到一个合适的IP给用户。这种根据每台机器的负载量，该机器离用户地理位置的距离等等，返回合适的IP的技术称之为 DNS 重定向。CDN就是利用的DNS重定向技术。</p>
<blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，<strong>CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</strong>。</p>
</blockquote>
<p>上面的内容以前是知道的，这里重新归纳了下。</p>
<hr>
<h1 id="isObjEmpty-的实现（判断对象是否为空）"><a href="#isObjEmpty-的实现（判断对象是否为空）" class="headerlink" title="isObjEmpty 的实现（判断对象是否为空）"></a>isObjEmpty 的实现（判断对象是否为空）</h1><p>使用 for … in，如果进入了循坏，代表对象不为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let key in obj) &#123;</span><br><span class="line"> if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">  return false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br></pre></td></tr></table></figure></p>
<p>使用 Object keys， 得到空数组，则代表对象为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Object.keys(obj).length === 0</span><br></pre></td></tr></table></figure></p>
<p>使用 JSON.stringify 和 空对象对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return JSON.stringify(obj) === JSON.stringify(&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总结了几种判断 Object 是否为空的方法&lt;br&gt;总结 once function (只执行一次函数代码)&lt;br&gt;实现两种简单的字符串模板替换方法&lt;br&gt;重新归纳总结了下CDN和DNS的名词解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
</feed>
