<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seven&#39;s Blog</title>
  <subtitle>Share, Learn, Enjoy, Keep</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sevencai.github.io/"/>
  <updated>2018-08-17T09:29:08.000Z</updated>
  <id>http://sevencai.github.io/</id>
  
  <author>
    <name>Seven Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Linux Command Line 读书笔记（二）</title>
    <link href="http://sevencai.github.io/2018/08/17/The-Linux-Command-Line-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://sevencai.github.io/2018/08/17/The-Linux-Command-Line-读书笔记（二）/</id>
    <published>2018-08-17T09:11:25.000Z</published>
    <updated>2018-08-17T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-权限管理🏫"><a href="#第九章-权限管理🏫" class="headerlink" title="第九章-权限管理🏫"></a>第九章-权限管理🏫</h1><blockquote>
<p>Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统，区别在于它们不仅是多任务系统，而且也是 多用户系统。这到底意味着什么？它意味着多个用户可以在同一时间使用同一台计算机。<br>为了使多用户特性付诸实践，那么必须发明一种方法来<strong>阻止用户彼此之间受到影响</strong>。毕竟，一个 用户的行为不能导致计算机崩溃，也不能乱动属于另一个用户的文件。</p>
</blockquote>
<p>主要的命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id – 显示用户身份号（每个用户都会有个 id）</span><br><span class="line">chmod – 更改文件模式</span><br><span class="line"><span class="built_in">umask</span> – 设置默认的文件权限 (这个我基本不会用到，暂时忽略)</span><br><span class="line">su – 以另一个用户的身份来运行 shell</span><br><span class="line">sudo – 以另一个用户的身份来执行命令</span><br><span class="line">chown – 更改文件所有者</span><br><span class="line">chgrp – 更改文件组所有权</span><br><span class="line">passwd – 更改用户密码</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="chmod-更改文件模式"><a href="#chmod-更改文件模式" class="headerlink" title="chmod-更改文件模式"></a>chmod-更改文件模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--    1 sevencai  TENCENT\Domain Users     523  8 15 15:36 README.md</span><br></pre></td></tr></table></figure>
<p><strong>列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。</strong></p>
<p>具体可能有的值有：</p>
<p><img src="firstletter.png" alt="first letter"></p>
<p><strong>剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。</strong></p>
<p><img src="filemode.png" alt="filemode"></p>
<p><img src="attribute.png" alt="attribute"></p>
<p>如<code>-rwxr-xr-x</code>标识的含义是：一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。</p>
<p><strong>我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。</strong></p>
<p>对应的值为：</p>
<p><img src="otcal.png" alt="octal"></p>
<p>通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 foo.txt</span><br><span class="line">chmod 755 shell.sh</span><br></pre></td></tr></table></figure>
<p>通过传递参数 “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有 权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r–)，和 0 (—)。</p>
<p>chmod 命令还支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定 要影响的对象，如下所示：</p>
<p><img src="ugoa.png" alt="ugoa"></p>
<p><strong>如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。</strong></p>
<p>有下面这些例子（我感觉这种我应该不会经常用，先前一直用上面的二进制模式比较多）：</p>
<p><img src="other.png" alt="ugoa+-"></p>
<hr>
<h2 id="su-及-sudo"><a href="#su-及-sudo" class="headerlink" title="su 及 sudo"></a>su 及 sudo</h2><blockquote>
<p>su － 以其他用户身份和组 ID 运行一个 shell<br>语法类似： su [-[l]] [user]</p>
</blockquote>
<p>如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。</p>
<p>因此为了启动超级用户我们可能会这样执行<code>su -</code>。</p>
<p>如果以<code>su -c &#39;command&#39;</code>这样的方式启动一个 shell, 是可以执行单个的<code>command</code>命令，而不是重新启动了一个可以交互的shell。注意 command 要用 引号引起来。如<code>su -c &#39;ls -l /root/*&#39;</code>。</p>
<p><strong>sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。</strong></p>
<p>执行 <code>sudo -l</code>可以看当前被赋予了哪些权限如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  midas-welfare git:(master) sudo -l</span><br><span class="line">Password:</span><br><span class="line">Matching Defaults entries for sevencai on SEVENCAI-MB2:</span><br><span class="line">    env_reset ......</span><br><span class="line">User sevencai may run the following commands on SEVENCAI-MB2:</span><br><span class="line">    (ALL) ALL</span><br></pre></td></tr></table></figure></p>
<p>所以这里总结下 su 和 sudo 的区别和联系：</p>
<ol>
<li><code>sudo</code> 命令需要输入当前用户的密码，<code>su</code> 命令需要输入 root 用户的密码。</li>
<li><code>sudo</code> 命令只允许使用提升的权限运行单个命令，而 <code>su</code> 命令会启动一个新的 shell，同时允许使用 root 权限运行尽可能多的命令，直到明确退出登录</li>
</ol>
<p><strong>所以根据第一条，我们可以知道就安全性而言，<code>sudo</code> 比 <code>su</code> 更好。<code>su</code>意味着要与其他用户共享 root 密码，这是一件比较危险的事情。并且对于 <code>su</code> 而言如果要撤销特定用户的超级（root）权限，唯一的办法就是更改 root 密码，然后再告知其他用户。很麻烦。但是 <code>sudo</code> 就不一样了,如果想要阻止某个用户访问 root 权限，只需要调整 <code>sudoers</code> 这个文件中的配置即可。</strong></p>
<p>The key difference between <code>sudo</code> and <code>su</code> is <code>sudo</code> runs a command as root, whereas <code>su</code> makes you root.</p>
<hr>
<h2 id="chown-－-更改文件所有者和用户组"><a href="#chown-－-更改文件所有者和用户组" class="headerlink" title="chown － 更改文件所有者和用户组"></a>chown － 更改文件所有者和用户组</h2><p><strong>chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [owner][:[group]] file...</span><br></pre></td></tr></table></figure>
<p><img src="chown.png" alt="chown"></p>
<p>下面这个例子比较实用，有两个用户，janet拥有超级用户访问权限，而 tony 没有。用户 janet 想要从 她的家目录复制一个文件到用户 tony 的家目录。因为用户 janet 想要 tony 能够编辑这个文件， janet 把这个文件的所有者更改为 tony:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[janet@linuxbox ~]$ sudo cp myfile.txt ~tony</span><br><span class="line">Password:</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root  root <span class="number">8031</span> <span class="number">2008</span><span class="number">-03</span><span class="number">-20</span> <span class="number">14</span>:<span class="number">30</span> /home/tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt</span><br><span class="line">[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> tony  tony <span class="number">8031</span> <span class="number">2008</span><span class="number">-03</span><span class="number">-20</span> <span class="number">14</span>:<span class="number">30</span> /home/tony/myfile.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="更改用户密码"><a href="#更改用户密码" class="headerlink" title="更改用户密码"></a>更改用户密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd [user]</span><br><span class="line">sudo passwd root 更改 root 用户的密码</span><br></pre></td></tr></table></figure>
<p>passwd 命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前相似的密码、 字典中的单词作为密码或者是太容易猜到的密码。</p>
<hr>
<h1 id="第十章：进程🚓"><a href="#第十章：进程🚓" class="headerlink" title="第十章：进程🚓"></a>第十章：进程🚓</h1><p>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   ps – 报告当前进程快照</span><br><span class="line">-   top – 显示任务</span><br><span class="line">-   <span class="built_in">jobs</span> – 列出活跃的任务</span><br><span class="line">-   <span class="built_in">bg</span> – 把一个任务放到后台执行</span><br><span class="line">-   <span class="built_in">fg</span> – 把一个任务放到前台执行</span><br><span class="line">-   <span class="built_in">kill</span> – 给一个进程发送信号</span><br><span class="line">-   killall – 杀死指定名字的进程</span><br><span class="line">-   shutdown – 关机或重启系统</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>查看进程，最常使用地命令（有几个命令）是 ps(process)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br><span class="line"></span><br><span class="line">  PID TTY           TIME CMD</span><br><span class="line">54944 ttys000    0:00.14 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp sevencai</span><br><span class="line">55003 ttys000    0:00.61 -zsh</span><br><span class="line">10488 ttys001    0:00.27 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp sevencai</span><br><span class="line">10492 ttys001    0:02.66 -zsh</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。为了得到更多信息， 我们需要加上一些选项。TTY 是 “Teletype”(直译电传打字机) 的简写，是指进程的控制终端。TIME 字段表示 进程所消耗的 CPU 时间数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上 “x” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以 看到我们所拥有的每个进程的信息。</span></span><br><span class="line">ps x</span><br><span class="line">ps x | less</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够显示属于每个用户的进程信息。使用这个选项，可以唤醒 “BSD 风格” 的输出结果。</span></span><br><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="用-top-命令动态查看进程"><a href="#用-top-命令动态查看进程" class="headerlink" title="用 top 命令动态查看进程"></a>用 top 命令动态查看进程</h2><p><strong>虽然 ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照。 为了看到更多动态的信息，我们使用 <code>top</code> 命令。</strong></p>
<p>top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。</p>
<hr>
<h2 id="通过-kill-命令给进程发送信号"><a href="#通过-kill-命令给进程发送信号" class="headerlink" title="通过 kill 命令给进程发送信号"></a>通过 kill 命令给进程发送信号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-signal] PID...</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -1 13546</span><br><span class="line"><span class="built_in">kill</span> -9 pid (我经常用)</span><br></pre></td></tr></table></figure>
<p>具体的 <code>-signal</code> 的可选值，如下所示：</p>
<p><img src="kill.png" alt="kill"></p>
<hr>
<h1 id="总结🌹"><a href="#总结🌹" class="headerlink" title="总结🌹"></a>总结🌹</h1><p>加上这篇文章，<code>The Linux Command Line</code> 的第一章就结束了。我零零散散的花的时间去整理的，中间也去除了一些我基本上不怎么用到的，着重加强了下我经常用到的一些命令。</p>
<p>比如 kill ，我以前经常用到 kill -9, 但是其实一直不知道这个 -9 是什么东西。现在进行稍微系统一点的学习，打命令不再依靠熟悉和曾经用过，而是有理解的。📚❄️</p>
<p>包括还有  sudo 及 su, 以前一直有用过，但是模拟两可，并不知道两者的区别。现在都大致的有了解。以后看运维同学敲命令，我看它敲 su or sudo 就知道它是大概的区别是什么了。想要做什么事情。🐶</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第九章-权限管理🏫&quot;&gt;&lt;a href=&quot;#第九章-权限管理🏫&quot; class=&quot;headerlink&quot; title=&quot;第九章-权限管理🏫&quot;&gt;&lt;/a&gt;第九章-权限管理🏫&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Unix 传统中的操作系统不同于那些 MS-DOS
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://sevencai.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>The Linux Command Line 读书笔记（一）</title>
    <link href="http://sevencai.github.io/2018/08/10/The-Linux-Command-Line-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sevencai.github.io/2018/08/10/The-Linux-Command-Line-读书笔记（一）/</id>
    <published>2018-08-10T12:54:15.000Z</published>
    <updated>2018-08-10T13:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章是我读 <em>The Linux Command Line</em> 的读书笔记。电子版的书的地址是：<a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">TLCL</a>。相比于鸟叔，这本书好在比较少，重点比较突出，大部分里面的命令都是我会经常用到的。缺点是也存在少量冗余的内容。不便于我查找和学习。因此我把我需要的东西从中抽取出来，总结并且提炼，以便日后的查找和学习。此篇笔记📒是书的第一章到第九章。</p>
</blockquote>
<h2 id="第一章：什么是-shell🏠"><a href="#第一章：什么是-shell🏠" class="headerlink" title="第一章：什么是 shell🏠"></a>第一章：什么是 shell🏠</h2><p>shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。“bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。</p>
<blockquote>
<p>[me@linuxbox ~]$</p>
</blockquote>
<ol>
<li>代表 username@machinename ，后面可能是 $ or #，其中 # 代表了你有 root 权限， 对应的 $ 可能代表的就是普通的用户。</li>
<li>一些简单的命令如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date  当前时间</span><br><span class="line">cal  日期</span><br><span class="line">df  查看磁盘剩余空间的数量</span><br><span class="line"><span class="built_in">exit</span>  终止会话</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第二章：文件系统中跳转"><a href="#第二章：文件系统中跳转" class="headerlink" title="第二章：文件系统中跳转"></a>第二章：文件系统中跳转</h2><p>相关命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 打印出当前工作目录名</span><br><span class="line"><span class="built_in">cd</span>  dir 更改目录</span><br><span class="line">ls  列出目录内容，不包括带 . 的隐藏目录</span><br><span class="line">ls  -a 可以列出带 . 隐藏的目录</span><br><span class="line"><span class="built_in">cd</span>  更改工作目录到你的家目录</span><br><span class="line"><span class="built_in">cd</span>  - 更改工作目录到先前的工作目录</span><br><span class="line"><span class="built_in">cd</span>  ~user_name 更改工作目录到用户家目录</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="第三章：探究操作系统"><a href="#第三章：探究操作系统" class="headerlink" title="第三章：探究操作系统"></a>第三章：探究操作系统</h2><p>相关命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls    列出目录内容</span><br><span class="line">file   确定文件类型</span><br><span class="line">less   浏览文件内容</span><br><span class="line"></span><br><span class="line">ls -l    使用 ls 命令的“-l”选项，则结果以长模式输出 === ll</span><br><span class="line">ls -lt   <span class="string">"t"</span>选项按文件修改时间的先后来排序</span><br><span class="line">file filename   查看文件的类型</span><br></pre></td></tr></table></figure></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote>
<p>命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> -options arguments</span><br><span class="line">ls -lt --reverse</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><code>options</code> : 选项, 一般是 -l  这种形式，也支持长选项，长选项由两个中划线加上一个字组成。如 <code>--reverse</code>。 当然也有两种合并的。如上。</p>
<p>下面这张图来源于书里的对ls的命令的一部分列举，红色的框是我经常用的：</p>
<p><img src="ls.png" alt="ls"></p>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less 命令是一个用来浏览文本文件的程序,less 程序允许你前后滚动文件。</p>
<blockquote>
<p>格式为： less filename<br>如 less a.log<br>如 ps -ef | less 以分页的形式查看当前进程 (这个好用)</p>
</blockquote>
<p><img src="less.png" alt="less"></p>
<p>上面这个图里是不是感觉跟 vim 命令很像，我再补充几个，是我经常用到的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-   /字符串：向下搜索<span class="string">"字符串"</span>的功能</span><br><span class="line">-   ?字符串：向上搜索<span class="string">"字符串"</span>的功能</span><br><span class="line">-   n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-   N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-   b 向后翻一页</span><br><span class="line">-   d 向后翻半页</span><br><span class="line">-   空格键 滚动一页</span><br><span class="line">-   回车键 滚动一行</span><br><span class="line">-   u 向前滚动半页</span><br><span class="line">-   y 向前滚动一行</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四章：操作文件和目录"><a href="#第四章：操作文件和目录" class="headerlink" title="第四章：操作文件和目录"></a>第四章：操作文件和目录</h2><p>主要命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-   cp — 复制文件和目录</span><br><span class="line">-   mv — 移动/重命名文件和目录</span><br><span class="line">-   mkdir — 创建目录</span><br><span class="line">-   rm — 删除文件和目录</span><br><span class="line">-   ln — 创建硬链接和符号链接</span><br></pre></td></tr></table></figure></p>
<p>这几个命令我们最熟悉不过了。下面简单的列举了这几个的一些基本用法。</p>
<h3 id="cp-复制文件和目录"><a href="#cp-复制文件和目录" class="headerlink" title="cp 复制文件和目录"></a>cp 复制文件和目录</h3><p><img src="cp.png" alt="cp"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若 file2 存在，则覆盖or重写，若不存在则创建</span></span><br><span class="line">cp file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// -i 代表 info, 所以跟上面相同，只是覆盖or重写会有提示</span></span><br><span class="line">cp -i file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在</span></span><br><span class="line">cp file1 file2 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在</span></span><br><span class="line">cp dir1<span class="comment">/* dir2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 复制目录 dir1 中的内容到目录 dir2。</span></span><br><span class="line"><span class="comment">// 如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样</span></span><br><span class="line"><span class="comment">cp -r dir1 dir2</span></span><br></pre></td></tr></table></figure>
<h3 id="mv-移动和重命名文件"><a href="#mv-移动和重命名文件" class="headerlink" title="mv 移动和重命名文件"></a>mv 移动和重命名文件</h3><p><img src="mv.png" alt="mv"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 file2 存在，它的内容会被 file1 的内容重写。</span></span><br><span class="line"><span class="comment">// 如果 file2 不存在，则创建 file2。 这两种情况下，file1 都不再存在</span></span><br><span class="line">mv file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写时会提示用户</span></span><br><span class="line">mv -i file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在</span></span><br><span class="line">mv file1 file2 dir1</span><br></pre></td></tr></table></figure>
<h3 id="rm-删除文件和目录"><a href="#rm-删除文件和目录" class="headerlink" title="rm - 删除文件和目录"></a>rm - 删除文件和目录</h3><p><img src="rm.png" alt="rm"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默默地删除文件</span></span><br><span class="line">rm file1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样</span></span><br><span class="line">rm -i file1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件 file1, 目录 dir1，及 dir1 中的内容</span></span><br><span class="line">rm -r file1 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。</span></span><br><span class="line">rm -rf file1 dir1</span><br></pre></td></tr></table></figure></p>
<p><strong>不要用 <code>rm -rf</code>, 用 <code>rm -ri</code> 吧，给自己一点后悔的余地。</strong></p>
<h3 id="ln-—-创建链接"><a href="#ln-—-创建链接" class="headerlink" title="ln — 创建链接"></a>ln — 创建链接</h3><blockquote>
<p>建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建硬链接</span></span><br><span class="line">ln file link</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建符号链接（soft）</span></span><br><span class="line">ln -s 源文件 目标文件</span><br><span class="line">ln -s item link</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>关于这里我有一些实际可以用到软硬链接的场景。稍后再补充。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>书里先简单的讲了下通配符，我觉得只看例子就好了。<br><img src="tongpei.png" alt="通配符"></p>
<hr>
<h2 id="第五章：使用命令"><a href="#第五章：使用命令" class="headerlink" title="第五章：使用命令"></a>第五章：使用命令</h2><p>主要的几个有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="built_in">type</span> – 显示命令的类型</span><br><span class="line">-   <span class="built_in">which</span> – 显示一个可执行程序的位置</span><br><span class="line">-   man – 显示命令手册页</span><br><span class="line">-   apropos – 显示一系列适合的命令</span><br><span class="line">-   info – 显示命令 info</span><br><span class="line">-   whatis – 显示一个命令的简洁描述</span><br><span class="line">-   <span class="built_in">alias</span> – 创建命令别名</span><br></pre></td></tr></table></figure></p>
<p>下面举一些例子，这个更好理解一些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">type</span> 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）</span><br><span class="line"><span class="built_in">type</span> ls     =&gt; ls is an <span class="built_in">alias</span> <span class="keyword">for</span> ls -G</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span>     =&gt; <span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">type</span>   =&gt; <span class="built_in">type</span> is a shell builtins</span><br><span class="line"></span><br><span class="line">// 这个命令只对可执行程序有效，不包括内建命令和命令别名</span><br><span class="line"><span class="built_in">which</span> node  =&gt; /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line"><span class="built_in">which</span> npm   =&gt; /usr/<span class="built_in">local</span>/bin/npm</span><br><span class="line"></span><br><span class="line">// 输入“<span class="built_in">help</span>”，接着是 shell 内部命令名, 注意后面跟的一定要是 <span class="built_in">builtin</span> commands</span><br><span class="line"><span class="built_in">help</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">// --<span class="built_in">help</span> - 显示用法信息,它不要求是 <span class="built_in">builtin</span> commands, 是可执行程序即可</span><br><span class="line">mkdir --<span class="built_in">help</span> | less</span><br><span class="line">tar --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">// 许多希望被命令行使用的可执行程序</span><br><span class="line">// 提供了一个正式的文档，叫做手册或手册页(man page)。</span><br><span class="line">// 一个特殊的叫做 man 的分页程序，可用来浏览他们。</span><br><span class="line">man <span class="built_in">which</span></span><br><span class="line">man ls</span><br></pre></td></tr></table></figure></p>
<p>关于 alias 我觉得很好用，单独拿出来：</p>
<p><strong>语法是： <code>alias name=&#39;string&#39;</code>实际上我们平时写 命令 时，是可以几个一起写的，比如 <code>cd /usr; ls; cd -</code>。如果这个命令你经常用，而且不想要每次都打折三个命令，那么你可以把它做成一个别名。这样每次就可以很方便的切换了。如我们给上面一个命令起名叫 test, 在每次起别名前，记得用 type 试下，看这个别名是否被占用了。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bash: <span class="built_in">type</span>: foo: not found  可以创建为别名</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="built_in">test</span> is a shell <span class="built_in">builtin</span> 已经被使用了，不能创建了</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="built_in">test</span> 为我们的命令了</span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">test</span>=<span class="string">'cd /usr; ls; cd -'</span></span><br><span class="line"></span><br><span class="line">// 此时我们查看就会显示： foo is aliased to `<span class="built_in">cd</span> /usr; ls ; <span class="built_in">cd</span> -<span class="string">'</span></span><br><span class="line"><span class="string">type test</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第六章：重定向"><a href="#第六章：重定向" class="headerlink" title="第六章：重定向"></a>第六章：重定向</h2><blockquote>
<p>”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。</p>
</blockquote>
<p>主要的命令有：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   cat － 连接文件</span><br><span class="line">-   sort － 排序文本行</span><br><span class="line">-   uniq － 报道或省略重复行</span><br><span class="line">-   grep － 打印匹配行</span><br><span class="line">-   wc － 打印文件中换行符，字，和字节个数</span><br><span class="line">-   head － 输出文件第一部分</span><br><span class="line">-   tail - 输出文件最后一部分</span><br><span class="line">-   tee - 从标准输入读取数据，并同时写到标准输出和文件</span><br></pre></td></tr></table></figure></p>
<h3 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -l ls-output.txt</span><br><span class="line">ls -l /bin/usr &gt; ls-output.txt  不追加，每次都被从头覆盖</span><br><span class="line">ls -l /usr/bin &gt;&gt; ls-output.txt   追加到文件中</span><br><span class="line">&gt; ls-output.txt  清空某个文件</span><br></pre></td></tr></table></figure>
<h3 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h3><blockquote>
<p>标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 /bin/usr 不存在时报错将输出到 ls-error.txt 中</span></span><br><span class="line">ls -l /bin/usr <span class="number">2</span>&gt; ls-error.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有的时候可能我们需要重定向标准输出和错误到同一个文件</span></span><br><span class="line">ls -l /bin/usr &gt; ls-output.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向</span></span><br><span class="line"><span class="comment">// 使用单单一个表示法 &amp;&gt; 来重定向标准输出和错误到文件</span></span><br><span class="line">ls -l /bin/usr &amp;&gt; ls-output.txt</span><br></pre></td></tr></table></figure>
<h3 id="处理不需要的输出"><a href="#处理不需要的输出" class="headerlink" title="处理不需要的输出"></a>处理不需要的输出</h3><p>有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，可以像下面这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 处理不需要的输出</span><br><span class="line">ls -l /bin/usr 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>上面的比较少用到，基本上我之前没有用到过。</p>
<h3 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h3><h4 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// cat 命令读取一个或多个文件</span><br><span class="line">// cat 经常被用来显示简短的文本文件不分页</span><br><span class="line">cat [file]</span><br><span class="line">cat z.txt</span><br><span class="line">cat &lt; lazy_dog.txt  将标准输入，输出到 文件中</span><br></pre></td></tr></table></figure>
<h4 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h4><blockquote>
<p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">ls -l /usr/bin | less</span><br></pre></td></tr></table></figure>
<p><strong>管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /bin /usr/bin | sort | less</span><br></pre></td></tr></table></figure>
<h4 id="uniq-报道或忽略重复行"><a href="#uniq-报道或忽略重复行" class="headerlink" title="uniq - 报道或忽略重复行"></a>uniq - 报道或忽略重复行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表中不包含重复句子</span></span><br><span class="line">ls /bin /usr/bin | sort | uniq | less</span><br></pre></td></tr></table></figure>
<h4 id="wc-－-打印行数、字数和字节数"><a href="#wc-－-打印行数、字数和字节数" class="headerlink" title="wc － 打印行数、字数和字节数"></a>wc － 打印行数、字数和字节数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wc（字计数）命令是用来显示文件所包含的行数、字数和字节数</span></span><br><span class="line">wc ls-output.txt</span><br><span class="line"><span class="number">7902</span> <span class="number">64566</span> <span class="number">503634</span> ls-output.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// ”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法</span></span><br><span class="line">ls /bin /usr/bin | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>
<h4 id="grep-－-打印匹配行"><a href="#grep-－-打印匹配行" class="headerlink" title="grep － 打印匹配行"></a>grep － 打印匹配行</h4><p>grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。</span><br><span class="line">ls /bin /usr/bin | sort | uniq | grep zip</span><br></pre></td></tr></table></figure></p>
<h4 id="head-tail-－-打印文件开头部分-结尾部分"><a href="#head-tail-－-打印文件开头部分-结尾部分" class="headerlink" title="head / tail － 打印文件开头部分/结尾部分"></a>head / tail － 打印文件开头部分/结尾部分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 命令打印文件的前十行，而 tail 命令打印文件的后十行。 -n 用来指定</span></span><br><span class="line">head -n <span class="number">5</span> ls-output.txt</span><br><span class="line">total <span class="number">343496</span></span><br><span class="line">tail -n <span class="number">5</span> ls-output.txt</span><br><span class="line">ls /usr/bin | tail -n <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。</span></span><br><span class="line">tail -f /<span class="keyword">var</span>/log/messages</span><br></pre></td></tr></table></figure>
<p><strong>使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。</strong></p>
<h4 id="tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件"><a href="#tee-－-从-Stdin-读取数据，并同时输出到-Stdout-和文件" class="headerlink" title="tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件"></a>tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件</h4><p>为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="从-shell-眼中看世界-Echo"><a href="#从-shell-眼中看世界-Echo" class="headerlink" title="从 shell 眼中看世界- Echo"></a>从 shell 眼中看世界- Echo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="built_in">echo</span> － 显示一行文本</span><br></pre></td></tr></table></figure>
<p>利用 echo 你可以做下面这些事情。这个 echo 跟 php 里的 echo 非常的像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span></span><br><span class="line">// this is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> *</span><br><span class="line">// Applications Desktop Documents Downloads Library Movies Music Pictures Public</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> D*</span><br><span class="line">// Desktop Documents Downloads</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> *s</span><br><span class="line">// Documents Pictures Templates Videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">// Desktop Documents Music Pictures Public Templates Videos</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /usr/*/share</span><br><span class="line">// /usr/a/share  /user/b/share</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> ~</span><br><span class="line">// /Users/sevencai</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $((2 + 2))</span><br><span class="line">// 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $(($((5**2)) * 3))</span><br><span class="line">// 5*5 *3 = 75</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">// Front-A-Back Front-B-Back Front-C-Back</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Number_&#123;1,5&#125;</span><br><span class="line">// Number_1 Number_2 Number_3 Number_4 Number_5</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">// sevencai</span><br><span class="line"></span><br><span class="line">// 查看有效变量</span><br><span class="line">printenv | less</span><br><span class="line"></span><br><span class="line">// 命令替换</span><br><span class="line"><span class="built_in">echo</span> $(ls)</span><br><span class="line">ls -l $(<span class="built_in">which</span> cp)</span><br><span class="line"></span><br><span class="line"> // 在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。由于它们把单词分为不同的参数，所以在上面的例子中， 命令行包含一个带有四个不同参数的命令。</span><br><span class="line"><span class="built_in">echo</span> this is a    <span class="built_in">test</span></span><br><span class="line">// this is a <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// <span class="variable">$1</span> 当做第一个变量，因为 `1` 是没有定义的变量，所以为空</span><br><span class="line"><span class="built_in">echo</span> The total is <span class="variable">$100</span>.00</span><br><span class="line">// The total is 00.00</span><br><span class="line"></span><br><span class="line">// 在双引号中，参数展开、算术表达式展开和命令替换仍然有效</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$USER</span> <span class="variable">$((2+2)</span>) <span class="variable">$(cal)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"this is a    test"</span></span><br><span class="line">// this is a    <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>这里我觉得大致的了解下就行。因为真实情况下，我用到的非常非常少。</p>
<hr>
<h2 id="键盘高级技巧"><a href="#键盘高级技巧" class="headerlink" title="键盘高级技巧"></a>键盘高级技巧</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p><img src="jiqiao.png" alt="复制"></p>
<h3 id="剪切复制"><a href="#剪切复制" class="headerlink" title="剪切复制"></a>剪切复制</h3><p><img src="copy.png" alt="剪切"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天就到这里吧，我担心因为今天已经看了很多了，就后面把这个看完这本书记录下来当做任务去完成了，这样违背了我的初衷。所以有效的时间，做正确的事情。改天我再来总结后面几章节。</p>
<p>回家🌶啦，✈️明天去接我的小狗狗，可乐！！！ 嘻嘻。开心。开心。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章是我读 &lt;em&gt;The Linux Command Line&lt;/em&gt; 的读书笔记。电子版的书的地址是：&lt;a href=&quot;http://billie66.github.io/TLCL/book/index.html&quot; target=&quot;_bl
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://sevencai.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>项目总结</title>
    <link href="http://sevencai.github.io/2018/08/09/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://sevencai.github.io/2018/08/09/项目总结/</id>
    <published>2018-08-09T13:23:13.000Z</published>
    <updated>2018-08-09T14:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近一个多月加了很多班，做了一个比较紧急的项目 Nodejs + Vue全家桶，感觉自己收获多多。今天已经发布了现网版本，趁热总结和梳理下。</p>
</blockquote>
<hr>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ol>
<li><code>Nodejs koa2</code>,  <code>async await</code>用的很舒适。</li>
<li><code>Vue 全家桶</code>,<code>vue webpack vuex</code>可快速开发。</li>
<li>前后端分离，<code>Nodejs</code> 端纯做 <code>Api</code> 层。</li>
<li><code>pm2</code> 进程管理工具。又熟悉了很多命令和踩了一些坑。</li>
<li><code>log4js</code>日志打印工具。了解了部门的日志规范，用于查询问题。</li>
<li>数据库用的 <code>sequelize</code>。</li>
<li>登录用的 <code>koa-generic-session</code>。</li>
<li>了解了 ToB 的一些概念及思想。</li>
</ol>
<p>以后就抛弃 PHP 这个世界上最好的语言吧。以下主要是自己对自己问题的一些梳理。并不涉及到任何的真实项目代码⌨️🏠。</p>
<hr>
<h2 id="获取用户的IP信息"><a href="#获取用户的IP信息" class="headerlink" title="获取用户的IP信息"></a>获取用户的IP信息</h2><p>在很多种情况下，我们Nodejs层需要把用户的 ip 传给后台的 cgi, cgi 会根据这个 ip 做一些策略，如风控，营销等等。这就涉及到 ip 怎么取的概念，你可能会接触到这几个 ip:</p>
<ol>
<li>ctx.request.ip</li>
<li>ctx.headers[‘x-forwarded-for’]</li>
<li>ctx.headers[‘x-real-ip’]</li>
</ol>
<p>先来普及下 <code>x-forwarded-for</code>及 <code>x-real-ip</code>。</p>
<p><code>x-forwarded-for</code>的格式一般为：<code>X-Forwarded-For: client1, proxy1, proxy2</code>  如：<code>X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</code></p>
<blockquote>
<p>最左边（client1）是最原始客户端的IP地址, 代理服务器每成功收到一个请求，就把<strong>请求来源IP地址</strong>添加到右边。 在上面这个例子中，这个请求成功通过了三台代理服务器：proxy1, proxy2 及 proxy3。请求由client1发出，到达了proxy3（proxy3可能是请求的终点）。请求刚从client1中发出时，XFF是空的，请求被发往proxy1；通过proxy1的时候，client1被添加到XFF中，之后请求被发往proxy2;通过proxy2的时候，proxy1被添加到XFF中，之后请求被发往proxy3；通过proxy3时，proxy2被添加到XFF中，之后请求的的去向不明，如果proxy3不是请求终点，请求会被继续转发。<strong>鉴于伪造这一字段非常容易，应该谨慎使用X-Forwarded-For字段。正常情况下XFF中最后一个IP地址是最后一个代理服务器的IP地址, 这通常是一个比较可靠的信息来源。</strong> –维基百科</p>
</blockquote>
<p>而 <code>x-real-ip</code>没有相关标准，但是在反向代理和正向代理下，它的值可能不同。<strong>正向代理时，记录的是客户端的真实ip。 反向代理时，记录的是最后一级的代理ip。</strong></p>
<p>所以：<code>x-real-ip</code> 及 <code>x-forwarded-for</code>这两个 ip 就是很普通的请求头，它们是可以被篡改的。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.my.com:8089 -H <span class="string">'X-Forwarded-For: 1.1.1.1'</span> -H <span class="string">'X-Real-IP: 2.2.2.2'</span></span><br></pre></td></tr></table></figure></p>
<p>那么这两个值都容易被篡改，不可信，我们要拿到用户真实的 ip 怎么办呢？</p>
<p>一般在建立  TCP 连接时，会产生真实的 IP, 叫做 <code>Remote Address</code>。因为是建立在 TCP 中，所以这个 ip 不能被篡改。一旦篡改，握手不成功，那么后面自然就没有了。所以如果我们要取真实的 ip,应该从这个字段里取。</p>
<p>实际上应该取那个值，跟你 nginx 的配置有关系。比如一般配置 nginx 反向代理的时候可能这样配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">// 若 XFF 有值，则 <span class="variable">$proxy_add_x_forwarded_for</span> = <span class="variable">$XFF</span>, <span class="variable">$remote_addr</span>  (<span class="variable">$XFF</span>与<span class="variable">$remote_addr</span>逗号分割，<span class="variable">$remote_addr</span>在其后)</span><br><span class="line">// 若 XFF 没有值，则 <span class="variable">$proxy_add_x_forwarded_for</span> = <span class="variable">$remote_addr</span></span><br></pre></td></tr></table></figure></p>
<p>像这样赋值后，如果你是通过 nginx 反向代理来的，nginx 会把用户实际 ip （$remote_addr）赋值给 <code>X-Real-IP</code>,这时候它也是真实的用户IP了。而 XFF 也是有了用户的真实IP。</p>
<p>通过这样的 nginx 配置。整个内容就无法被篡改和构造，我们就可以从 <code>X-Real-IP</code> 和 <code>XFF</code>的最后一截 获得用户真实的 IP 了。</p>
<p>所以我最后是怎么传什么字段给后台的呢？<strong>我最后传的是 <code>x-forwarded-ip</code>， 拿到这一系列的 ip list 后，后台会去通过网段校验，判断出哪个是外网 ip, 然后把这个 ip 当成是用户真实的 ip。</strong> cgi 还是很严谨的。</p>
<p>最开始谈到的 <code>ctx.request.ip</code> 是最后一次的 ip, 所以有可能是代理机器的 ip。</p>
<p>遇到一篇好文章：<a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="noopener">x-forwarded-for-header-in-http</a></p>
<p>一个实例，判断用户IP是否正常：<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_5" target="_blank" rel="noopener">微信H5支付需判断下单IP和支付IP是否一致</a></p>
<hr>
<h2 id="关于-PM2-的-cluster-模式"><a href="#关于-PM2-的-cluster-模式" class="headerlink" title="关于 PM2 的 cluster 模式"></a>关于 PM2 的 cluster 模式</h2><p>pm2 是很好的进程管理器，有自动重启等功能，并且还自带负载均衡。我这里就不讲具体的 cluster 模式和 pm2 了。就只讲下我遇到的坑。</p>
<p>cluster 模式下，log4js 日志，无法正常打印。这个已经有相关的 issue,地址在<a href="https://github.com/log4js-node/log4js-node/issues/265" target="_blank" rel="noopener">这里</a>。大概的意思是 cluster 模式下，并没有 master 进程，而是只有多个 worker 子进程。而 log4js 只在 master 进程下，才会进行打印日志的操作。之所以这样是因为多个 worker 操作同一个日志文件（一般我们日志文件只有一套配置）可能会导致有错乱等问题。有解决问题的方法，都在那个 issue 里，但是我总觉得不太好。</p>
<p>另一个问题是，在 cluster 模式下，利用 restart 命令无法完全重启进程，fork 模式下就不会，猜测是 cluster 模式有多个 worker, 重启是否需要 restart 指定是哪个子进程才可以？还发现，如果只有一个子进程，不指定也会不能重启。我明天会去验证下。</p>
<p>遇到了一篇好文章： <a href="http://www.acuriousanimal.com/2017/08/20/using-pm2-to-manage-cluster.html" target="_blank" rel="noopener">using-pm2-to-manage-cluster</a></p>
<hr>
<h2 id="登录态验证"><a href="#登录态验证" class="headerlink" title="登录态验证"></a>登录态验证</h2><p>我们利用了<code>koa session</code>, <code>cookie session</code> 这种形式。开始的时候我把这里想复杂了，想要结合微信的登录态。但实际上纯 session cookie 这种反而更好。</p>
<blockquote>
<p>大概流程是：用户登录网站，调用微信登录，拉起授权，授权的地址调用 Nodejs 后台的一个自己封装的接口。在这个接口里获得用户的 openid ，校验用户的权限并且设置 <code>ctx.session.sessionId</code>，然后返回到前端，前端调用后台的接口，通过已经种下的 <code>sessionId</code> 即可判断出用户的权限，然后再返回给前端。前端再针对身份到对应的路由。</p>
</blockquote>
<p>那么你肯定会问，为什么不在直接设置 sessionId 的时候把用户信息返回了呢？这样也可以的，那么相当于你微信授权的回调地址要写一个前端的页面， 然后在这个页面中再来判断用户根据身份到哪个页面。这个前端页面你需要单独的也去维护。这样也是可以的。你也许会问，我不用单独再写个页面，用首页就好了。但是用首页会存在一个问题，就是最终由于授权，你的首页就带上了 code, 还要用 replaceState 什么的去掉，我觉得很不整洁。但是也是可以的。这两种方式本质上都可以。只不过第一种偷懒了，直接redirect到首页，首页再发一次请求。</p>
<p>我用的登录中间件是： <code>koa-generic-session</code>。<code>app.use</code>下面这个中间件即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelizeObj = connectDb.db[dbName]</span><br><span class="line"></span><br><span class="line">sessionConfig.options.store = <span class="keyword">new</span> SequelizeStore(sequelizeObj, &#123;</span><br><span class="line">  sync: <span class="literal">false</span>,</span><br><span class="line">  tableName: <span class="string">'t_session'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session(sessionConfig.options)</span><br></pre></td></tr></table></figure></p>
<p>存储并没有存在内存中，而是存在了数据库里，这里用的<code>koa-generic-session-sequelize</code>。<strong>不放在内存里的原因是有多台机器，存在内存中不能共享应该会有问题。</strong></p>
<p>设置 session cookie 的时候，在前端 cookie 里，就会有对应的值，然后每次请求页面，都会把这个 cookie 带上，去数据库里找对应的 session 是否失效。如果没有失效，认为ok,那么就可以跳过验证的过称了。</p>
<p>还可以加上 app.keys ，然后再对应的 options 里加上  signkeys。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>];</span><br><span class="line">app.keys = <span class="keyword">new</span> KeyGrip([<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>], <span class="string">'sha256'</span>);</span><br><span class="line"></span><br><span class="line">ctx.cookies.set(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>这样，你的 cookie 的值，就会被加密了。前端看到的 cookie 可能是一个加密过的串。然后你到服务器端 get cookie 的时候，它会自动帮你解密。得到对应的值去和数据库里的session进行比对。</p>
<p>那如果前端的微信登录态过期了怎么办呢？比较简单，前端发现登录态失败，比如登录态失败的返回码是1111，那么1111时重新拉起微信登录即可。</p>
<hr>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><p>日志管理对于一个大型的项目来说，尤其是涉及到支付的非常重要，他用于帮你查看用户做了什么事情，或者系统出了什么❌。非常的重要。</p>
<p><strong>日志我这里用的 log4js, 分为了四种 category, 分别用来记录 db 操作，访问日志，开发者 debug 信息，cgi 信息日志，错误日志。这些需要放在不同的文件里，便于开发者找问题。</strong></p>
<p>你可以设置不同的 categories, 每个 categories 里设置 level 和不同的 appenders。 每一个 appenders 都可以设置不同 filename 等等。</p>
<p>那么这个 db 的操作日志，怎么打印呢？ sequelize 建立跟 db 链接时，可以传入 logging 这个 option, 在这个 logging 里设置 sequelize 的打印方法。如下面我就是把打印db的操作日志通过 log4js 打入了日志中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.options.logging = <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  dbLogger.debug(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="koa2-的错误处理"><a href="#koa2-的错误处理" class="headerlink" title="koa2 的错误处理"></a>koa2 的错误处理</h2><p>这个错误处理的方法，网上到处都是的了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理中间件</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    ctx.response.status = err.statusCode || err.status || <span class="number">500</span></span><br><span class="line"></span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">      message: <span class="string">'系统繁忙，请稍后再试!'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.app.emit(<span class="string">'error'</span>, err, ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js 中接收 error 事件，并且上报到错误日志中</span></span><br><span class="line">app.on(<span class="string">'error'</span>, (err, ctx) =&gt; &#123;</span><br><span class="line"> ctx.errorLogger(<span class="string">`name=<span class="subst">$&#123;err.name&#125;</span>&amp;msg=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(err.message)&#125;</span>&amp;stack=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(err.stack)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里注意如果你直接打印的是 err 对象，一般只有它的 msg 会被打印出来，如果你想要更多信息，一定要把 stack 打出来。这个我疏忽了，同事帮我提出来了，很棒很优秀。</p>
<p>我去网上查了下，这个错误处理其实是 koa2 里的默认方式，只不过我们又自己去重写了，他本身的是这样的：</p>
<p>可以看下这篇文档：<a href="https://github.com/koajs/koa/blob/master/docs/error-handling.md#default-error-handler" target="_blank" rel="noopener">error-handling.md#default-error-handler</a></p>
<p>他里面推荐了一种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// will only respond with JSON</span></span><br><span class="line">    ctx.status = err.statusCode || err.status || <span class="number">500</span>;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: err.message</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>我觉得这种写法并不是很好，因为如果你这个是数据库的某些地方出错了，可能会在 err.message 里暴露一些你机器 ip 及一些其他的信息，这个是不安全的。统一给用户一个回复，然后打到系统错误日志中，是比较好的做法。</strong></p>
<p>这里途中看到了一篇文章： <a href="http://www.52cik.com/2018/05/27/koa-error.html" target="_blank" rel="noopener">大概讲的是koa错误处理的写法</a></p>
<p>注意错误处理最好被当做最前面的一个中间件。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先写这么多，其实还有很多很小的细节。下次再整理整理，当然上面只是我自己的理解，可能也有我理解错了的。我会经常看它，然后看自己是否后面又新的认识来推翻现在的想法。这个项目是我跟着组里另外一个很多年经验的老司机一起做的，在他身上，我学习到了严谨的态度。有很多地方他都比我有经验，也给我指出了一些问题。所以说公司和老板给他那么多工资是应该的啊。优秀哈哈。👍📚</p>
<p>🌲希望下次有机会试下 Vue SSR。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一个多月加了很多班，做了一个比较紧急的项目 Nodejs + Vue全家桶，感觉自己收获多多。今天已经发布了现网版本，趁热总结和梳理下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; 
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://sevencai.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Ajax 请求后台接口【下载文件】方法</title>
    <link href="http://sevencai.github.io/2018/07/11/Ajax-%E8%AF%B7%E6%B1%82%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>http://sevencai.github.io/2018/07/11/Ajax-请求后台接口下载文件方法/</id>
    <published>2018-07-11T14:03:14.000Z</published>
    <updated>2018-07-12T12:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>你的管理台有一个功能是点击<strong>[查看文件]</strong>，下载文件到本地的功能。你可能自然的向后台接口（可能是 Nodejs 的一个 Restful Api）请求下载。但是你发现你后台的 Nodejs 虽然设置了正确的响应头（Content-position, Content-type）却还是没有弹出保存文件的框。</p>
</blockquote>
<p>原因是未经过处理的 ajax（如jquery ajax请求） 请求不能处理正确的二进制（流）类型的文件。</p>
<p>下面我总结了几种方式可以解决此问题-&gt; 📚🌲</p>
<hr>
<h2 id="利用iframe"><a href="#利用iframe" class="headerlink" title="利用iframe"></a>利用iframe</h2><p>Nodejs 端正常的设置相应头，<code>Content-disposition: attachment, filename=</code>。然后读到服务器上对应的文件赋值给 <code>ctx.body</code> 即可。下面是一种参考的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filePath = path.join(path.resolve(__dirname, <span class="string">'../uploads'</span>), $&#123;fileStamp&#125;)</span><br><span class="line"></span><br><span class="line">ctx.set(&#123;</span><br><span class="line">  <span class="string">'Content-disposition'</span>: <span class="string">`attachment; filename=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(fileStamp)&#125;</span>`</span>,</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/octet-stream'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ctx.body = fs.createReadStream(filePath)</span><br></pre></td></tr></table></figure>
<p>前端利用 iframe 的 src 属性，进行重新赋值。注意 iframe 设为 <code>display: none</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe ref=<span class="string">"downloadIframe"</span> src=<span class="string">""</span> frameborder=<span class="string">"0"</span> style=<span class="string">"display: none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击查看时执行 downloadFile</span></span><br><span class="line">downloadFile(fileStamp) &#123;</span><br><span class="line"> <span class="keyword">this</span>.$refs.downloadIframe.src = <span class="string">`/download/<span class="subst">$&#123;fileStamp&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="利用URL-createObjectURL"><a href="#利用URL-createObjectURL" class="headerlink" title="利用URL.createObjectURL"></a>利用URL.createObjectURL</h2><blockquote>
<p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>
<p>一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式。 File 接口基于Blob，继承 blob功能并将其扩展为支持用户系统上的文件。（HTML5新增特性）</p>
</blockquote>
<p>这种方法我已经在上篇文章刚好有用到，可以利用浏览器原生 fetch 方法，然后解析为 blob 类型。再利用a标签的 download 属性即可。参考代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span> (<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cache: <span class="string">'no-cache'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    mode: <span class="string">'cors'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里要是 response.blob()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageData</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchApi(url, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImage</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  getImageData(<span class="string">'/downloadImage'</span>, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">      <span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(response)</span><br><span class="line">      <span class="keyword">let</span> filename = <span class="string">`<span class="subst">$&#123;data.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span></span><br><span class="line"></span><br><span class="line">      a.href = url</span><br><span class="line">      a.download = filename</span><br><span class="line"></span><br><span class="line">      a.click()</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你可以不用 fetch 的这个方法，直接在 xhr 里进行封装。我看到 stackoverflow 上有个很好的文章，地址<a href="https://stackoverflow.com/questions/16086162/handle-file-download-from-ajax-post" target="_blank" rel="noopener">戳这里</a>，我觉的最高回答者已经解释的很好了，下面引用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.responseType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> filename = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> disposition = xhr.getResponseHeader(<span class="string">'Content-Disposition'</span>);</span><br><span class="line">        <span class="keyword">if</span> (disposition &amp;&amp; disposition.indexOf(<span class="string">'attachment'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> filenameRegex = <span class="regexp">/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/</span>;</span><br><span class="line">            <span class="keyword">var</span> matches = filenameRegex.exec(disposition);</span><br><span class="line">            <span class="keyword">if</span> (matches != <span class="literal">null</span> &amp;&amp; matches[<span class="number">1</span>]) filename = matches[<span class="number">1</span>].replace(<span class="regexp">/['"]/g</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> type = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> blob = <span class="keyword">typeof</span> File === <span class="string">'function'</span></span><br><span class="line">            ? <span class="keyword">new</span> File([<span class="keyword">this</span>.response], filename, &#123; <span class="attr">type</span>: type &#125;)</span><br><span class="line">            : <span class="keyword">new</span> Blob([<span class="keyword">this</span>.response], &#123; <span class="attr">type</span>: type &#125;);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.navigator.msSaveBlob !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="comment">// IE workaround for "HTML7007: One or more blob URLs were revoked by closing the blob for which they were created. These URLs will no longer resolve as the data backing the URL has been freed."</span></span><br><span class="line">            <span class="built_in">window</span>.navigator.msSaveBlob(blob, filename);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> URL = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">            <span class="keyword">var</span> downloadUrl = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                <span class="comment">// use HTML5 a[download] attribute to specify filename</span></span><br><span class="line">                <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">                <span class="comment">// safari doesn't support this yet</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> a.download === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                    <span class="built_in">window</span>.location = downloadUrl;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a.href = downloadUrl;</span><br><span class="line">                    a.download = filename;</span><br><span class="line">                    <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">                    a.click();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">window</span>.location = downloadUrl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; URL.revokeObjectURL(downloadUrl); &#125;, <span class="number">100</span>); <span class="comment">// cleanup</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send($.param(params));</span><br></pre></td></tr></table></figure>
<p>大概的思路是利用 <code>xhr</code> 原生对象的 <code>onload</code> 后，进行<code>new blob()</code>对象。</p>
<p>再执行<code>URL.createObjectURL(blob)</code>的操作。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实还有别的方法，如 <code>POST</code> 一个请求，但是这个会刷新当前的 <code>Url</code>。上面两种情况其实是两种思路。</p>
<p><code>POST</code> 请求跟 <code>Iframe</code> 类似,同样还可以 <code>window.open</code> 或者 <code>window.location</code> 来做这件事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你的管理台有一个功能是点击&lt;strong&gt;[查看文件]&lt;/strong&gt;，下载文件到本地的功能。你可能自然的向后台接口（可能是 Nodejs 的一个 Restful Api）请求下载。但是你发现你后台的 Nodejs 虽然设置了正确的响应头（Con
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>koa2 生成带场景值参数的带Logo二维码</title>
    <link href="http://sevencai.github.io/2018/06/21/koa2-%E7%94%9F%E6%88%90%E5%B8%A6%E5%9C%BA%E6%99%AF%E5%80%BC%E5%8F%82%E6%95%B0%E7%9A%84%E5%B8%A6Logo%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://sevencai.github.io/2018/06/21/koa2-生成带场景值参数的带Logo二维码/</id>
    <published>2018-06-21T12:14:37.000Z</published>
    <updated>2018-06-21T13:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>上次写 Koa 还是2016年刚来公司实习的时候，那时候我还在上大三。转眼见2年过去了，我也正式工作快一年了。 Koa 也从原来比较难用的 generator ，yield 变成了现在的 async await 。真好。</p>
</blockquote>
<p>这次文章的背景是，产品需要给公众号拉新。需要生成各种带参数的二维码。这个带参数的二维码可以做很多事情，比如统计新拉的关注是从哪个场景值下来的。比如关注时，不同场景值有不同的公众号回复内容。</p>
<p>在经历了好几次每次手动跟她生成后，我下定了决心，跟产品要了2天排期，给她做一个工具。自动生成带 Logo 的二维码。<strong>主要是手工去操作比较繁琐，需要经历下面几步</strong>：</p>
<ol>
<li>先去获得 access_token</li>
<li>再调用微信创建带参数值二维码的接口qrcode/create，获得 ticket</li>
<li>再拿 ticket 换二维码</li>
</ol>
<p>这其中，带参数的二维码又分为了两种，永久和临时二维码。具体接口可以<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1443433542" target="_blank" rel="noopener">参考公众号的文档</a>， 并且每次产品自己拿到 ticket 换的二维码后，还需要自己去 P logo, 大小也要自己去调。总之比较麻烦。</p>
<p><strong>所以这篇文章，主要就是用 Koa2 生成带场景值参数的公众号二维码</strong>。💗🌹</p>
<hr>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>首先我确定了 koa server 端，只做接口层。意思是只用来处理前端的请求。 GET or POST。</p>
<p>前端主要做表单验证，获取产品想要的二维码类型信息等。然后传给后台。后台根据信息，去拿 access_token, 然后调用微信二维码，再添加 logo 等。然后返回给前端。最后的效果是这样的：</p>
<p><img src="qrcode.png" alt="结果图"></p>
<p>产品可以选择，是临时还是永久，选择是只要链接还是下载图片，是否添加 Logo ，图片的大小等等。</p>
<p>最后如果图片类型选的是【我要生成图片】就可以生成类似下面二维码啦， 如果是点击的 【我只要链接】，那么我只会返回一个带ticket的链接。</p>
<p><img src="exampletest.png" alt="生成结果图片"></p>
<p>红色的笔部分是为了遮住二维码信息，因为是自己的测试号。主要用到了下面这些 npm 库： <code>koa-router, koa-static, qr-image, request-promise, stream-to-promise, image-size</code></p>
<hr>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>写起来代码没有特别的地方，用 koa-router 做路由，比如产品选择生成链接，还是生成图片，我选择了路由到两个接口。</p>
<p>在配置文件， route.js 中，配置相应路由的请求以及对应的 controller</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  &apos;post /getLink&apos;: &apos;controllers/createLink&apos;,</span><br><span class="line">  &apos;post /downloadImage&apos;: &apos;controllers/createImage&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表明：</p>
<p>当前端 post getLink 这个接口时， 用 controllers 下的 createLink 来处理。<br>当前端 post downloadImage 这个接口时，用 controllers 下的 downloadImage 来处理。</p>
<p>然后再在自己写个注册路由的 middleware<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app, router</span>) =&gt;</span> (</span><br><span class="line">  <span class="built_in">Object</span>.keys(routesConfig).forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [method, path] = route.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">const</span> controller = <span class="built_in">require</span>(<span class="string">'../'</span> + routesConfig[route])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> controller !== <span class="string">'function'</span> || <span class="keyword">typeof</span> router[method] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'post'</span>) &#123;</span><br><span class="line">      app.use(bodyParser())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.post(path, controller)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后在 入口文件中使用这个 middleware 并且注册到 koa-router 上即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routeMiddleware(App, router)</span><br><span class="line"></span><br><span class="line">App.use(router.routes()).use(router.allowedMethods())</span><br></pre></td></tr></table></figure></p>
<p>最后是对应的 controller 里处理文件, 比如如下是 downloadImage 的 controller, 把 data 传给了核心处理业务流程的类文件。然后再返回相应的图片即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二维码</span></span><br><span class="line"><span class="comment"> * @param ctx</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;void&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Core = <span class="built_in">require</span>(<span class="string">'../server/core'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> core = <span class="keyword">new</span> Core(data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> core.downloadQrCodeImage()</span><br><span class="line"></span><br><span class="line">  ctx.type = <span class="string">'png'</span></span><br><span class="line">  ctx.set(<span class="string">'Content-type'</span>, <span class="string">'image/png'</span>)</span><br><span class="line">  ctx.body = result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端接受到这个 image 后，再利用 createObjectURL, revokeObjectURL 立即下载图片即可。下面展示的是前端这一部分处理的逻辑。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchApi</span> (<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cache: <span class="string">'no-cache'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    mode: <span class="string">'cors'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageData</span>(<span class="params">url, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchApi(url, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImage</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  getImageData(<span class="string">'/downloadImage'</span>, data)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>)</span><br><span class="line">      <span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(response)</span><br><span class="line">      <span class="keyword">let</span> filename = <span class="string">`<span class="subst">$&#123;data.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span></span><br><span class="line"></span><br><span class="line">      a.href = url</span><br><span class="line">      a.download = filename</span><br><span class="line"></span><br><span class="line">      a.click()</span><br><span class="line">      <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我用的浏览器原生的 Fetch Api， 因为不想在前端还引入别的库。注意 fetchApi 返回不同的内容，要用不同的内容处理。比如上面的图片是用的 response.blob() 处理，如果是返回的json， 需要用 response.json() 处理。</p>
<hr>
<h2 id="获取-AccessToken"><a href="#获取-AccessToken" class="headerlink" title="获取 AccessToken"></a>获取 AccessToken</h2><p>注意如果没有自己的获取 AccessToken 的中控服务器，一定要缓存 accessToken, accessToken 有过期时间，并且一天有调用上限。部门内有专门的中控服务器，但是我还是自己试了下自己做缓存的流程，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>)</span><br><span class="line"> <span class="keyword">const</span> cachePath = <span class="string">'./cache/token.txt'</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得 access_token</span></span><br><span class="line"><span class="comment"> * 若缓存文件存在，则从缓存中读取</span></span><br><span class="line"><span class="comment"> * 若缓存文件不存在，调用 update 接口更新</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> getAccessToken () &#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(cachePath)) &#123;</span><br><span class="line">    token = <span class="built_in">JSON</span>.parse(fs.readFileSync(cachePath))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!token || token.timeout &lt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> <span class="keyword">this</span>.updateAccessToken())</span><br><span class="line"></span><br><span class="line">    res.timeout = <span class="built_in">Date</span>.now() + (res.expires_in - <span class="number">200</span>) * <span class="number">1000</span></span><br><span class="line">    fs.writeFileSync(cachePath, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新微信 Access_token</span></span><br><span class="line"><span class="comment"> * 此处有每天调用 2000 次限制</span></span><br><span class="line"><span class="comment"> * 2h 即失效</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> updateAccessToken () &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; appid, appkey &#125; = serverConfig</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;appid&#125;</span>&amp;secret=<span class="subst">$&#123;appkey&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rp.get(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于每次调用后，要重新写入文件过期时间，如果过期时间到了，那么重新去更新。之所以拿 re.expires_in - 200, 是为了留点 buffer, 这个值当然可以自己去设置。</p>
<hr>
<h2 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h2><p>这里的 logo, 因为我们公众号只有一个 logo, 故直接是从文件中读取了。以后考虑把这个放在 github 的话，可能会支持用户可以自己上传 Logo。</p>
<p>还有一个地方要注意，就是计算 logo 的位置。直接除以二维码的高宽一半是不行的，还要减去 logo 的一半哦。</p>
<p>我这边在返回给前端下载的时候，也 save 到本地了，担心产品丢失信息。save 的时候，我以场景值和时间为名字，会方便日后好找一些。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加 logo</span></span><br><span class="line"><span class="comment"> * @param imageStream</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> getLogo (imageStream) &#123;</span><br><span class="line">  <span class="keyword">const</span> imgBuffer = <span class="keyword">await</span> streamToPromise(imageStream)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">width</span>: imgWidth, <span class="attr">height</span>: imgHeight &#125; = imgSize(imgBuffer)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> logoWrapper = images(<span class="string">"./static/assets/logo.png"</span>).size(imgWidth / <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> x = (imgWidth - logoWrapper.width()) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> y = (imgHeight - logoWrapper.height()) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.drawImage(imgBuffer, logoWrapper, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画图</span></span><br><span class="line"><span class="comment"> * @param imgBuffer</span></span><br><span class="line"><span class="comment"> * @param logoWrapper</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> * @returns &#123;Promise&lt;any&gt;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> drawImage (imgBuffer, logoWrapper, x, y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> image = images(imgBuffer)</span><br><span class="line">      .draw(logoWrapper, x, y)</span><br><span class="line">      .save(<span class="string">`./static/image/<span class="subst">$&#123;<span class="keyword">this</span>.scene&#125;</span>-<span class="subst">$&#123;+<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>.png`</span>, &#123;</span><br><span class="line">        quality : <span class="number">50</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">      reject()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve(image)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>入口文件跟平常的入口文件基本上没有什么大区别。比较简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line"><span class="keyword">const</span> StaticServer = <span class="built_in">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"><span class="keyword">const</span> routeMiddleware = <span class="built_in">require</span>(<span class="string">'./middleware/route'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">'./static'</span></span><br><span class="line"></span><br><span class="line">App.use(StaticServer(path.join(__dirname, staticPath)))</span><br><span class="line"></span><br><span class="line">routeMiddleware(App, router)</span><br><span class="line"></span><br><span class="line">App.use(router.routes()).use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">App.listen(config.port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;config.port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想当一个优秀的 Nodejs 工程师，但是发现自己还远远不够，比如 fs 的函数不熟。比如对 Buffer, Stream 理解的不够深入。还是写的太少了。不过总算是按时完成了。解放了劳动力。🚫</p>
<p>下一步打算优化下代码，看能不能支持 upload logo, 支持传 appid, appkey, 这样别人也可以用了。还有很多基础工作没有做，比如 async, await 的错误处理，比如 logger, pm2 等。这个会慢慢完善，基础功能已 OK。 📚🏠</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上次写 Koa 还是2016年刚来公司实习的时候，那时候我还在上大三。转眼见2年过去了，我也正式工作快一年了。 Koa 也从原来比较难用的 generator ，yield 变成了现在的 async await 。真好。&lt;/p&gt;
&lt;/blockqu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小程序内嵌复用H5并拉起微信支付解决（替代）方案</title>
    <link href="http://sevencai.github.io/2018/06/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E5%B5%8C%E5%A4%8D%E7%94%A8H5%E5%B9%B6%E6%8B%89%E8%B5%B7%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%A7%A3%E5%86%B3%EF%BC%88%E6%9B%BF%E4%BB%A3%EF%BC%89%E6%96%B9%E6%A1%88/"/>
    <id>http://sevencai.github.io/2018/06/13/小程序内嵌复用H5并拉起微信支付解决（替代）方案/</id>
    <published>2018-06-13T12:45:56.000Z</published>
    <updated>2018-06-13T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>自从小程序出来后，你肯定有这样的想法。小程序内部分页面好想复用以前的H5，重复的去开发浪费了大量的时间和精力。 但是内嵌在小程序中的H5不支持拉起微信支付。也就是说小程序内，小程序嵌入的H5内只能调用小程序支付。</p>
</blockquote>
<p>于是呢，我就想到了这么一个办法。有些山寨，并且不官方（官方当然是希望你直接在小程序内完成一切，下单到支付），但是却可以解决问题。O(∩_∩)O~~☁️❤️</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>我们可以用小程序的 <code>web view</code> 能力嵌入 H5, 嵌入后，在 H5 中进行支付下单，得到参数如 ： <code>timeStamp</code>, <code>nouncestr</code>, <code>signType</code>,<code>paySign</code> 等等参数。然后再通过 <code>wx.miniProgram.navigateTo</code> 跳转到一个小程序页面，在这个页面进行调用 <code>wx.requestPayment</code> 进行拉起支付。拉起支付后，可以再跳到小程序结果页。</strong></p>
<p>如果你担心通过 <code>navigateTo</code> 的 url 传参有不安全的问题，可以自己对参数进行加解密。</p>
<p>亲测是可以行得通的。下图为在 【H5 页面下的单】获得支付参数的页面。</p>
<p><img src="xiaochengxu1.png" alt="下单接口"></p>
<p>下图为图二，【在小程序内拉起的微信支付】。可以通过右上角的转发退出按钮看出是小程序拉起的支付。这样支付完成后，用户可以点击后退退到刚刚的H5页面。</p>
<p>你也可以直接支付完成，调到你自己的小程序的支付结果页等工作。在小程序的支付结果页中，你还可以设置按钮，再来引导用户是进入小程序首页，还是刚刚你跳转的H5的页面等等。</p>
<p><img src="xiaochegnxu2.png" alt="支付接口"></p>
<hr>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>我想把下单的参数以 JSON.stringfy(obj) 的形式传过去，发现参数一直很奇怪的被截断。看到其他有的开发者也遇到了类似的问题。</p>
<p>也就是说下面这种方式是有问题的，以为是特殊字符导致的，但是发现 encode 以后还是被截断。我觉得有可能是小程序本身的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H5 内</span></span><br><span class="line">wx.miniProgram.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">`/pages/wxpay/wxpay?info=<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(obj)&#125;</span>`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序内</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="comment">// 因为被截断了，所以这里 JSON.parse 报错</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(options.info)</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="string">'timeStamp'</span>: data.time,</span><br><span class="line">      <span class="string">'nonceStr'</span>: data.nounce,</span><br><span class="line">      <span class="string">'package'</span>: data.package,</span><br><span class="line">      <span class="string">'signType'</span>: <span class="string">'MD5'</span>,</span><br><span class="line">      <span class="string">'paySign'</span>: data.sign,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wx.requestPayment(&#123;</span><br><span class="line">      ...obj,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后来老老实实的用多个参数穿参<code>sign=xxx&amp;signature=xxx&amp;noncestr=xxx</code>，发现 package 中的=后面的部分也被截断了。 <code>encodeURI, encodeURIComponent</code> 都没用。</p>
<p>这里没有想清楚。看了文档和查了资料也没弄清楚小程序在这里面做了什么事情。先放放，把方案跑不跑的通解决。</p>
<p>所以干脆就把 <code>prepay_id= xxx</code> 后面的 <code>xxx</code> 单独取出来。后面调用 <code>requestPayment</code> 再拼上。</p>
<hr>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>最后我测试通过的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// H5 内</span></span><br><span class="line">wx.miniProgram.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">"/pages/wxpay/wxpay?time="</span> + info.wx_time + <span class="string">"&amp;nounce="</span> + info.wx_noncenum + <span class="string">"&amp;package="</span>+info.wx_package.split(<span class="string">"="</span>)[<span class="number">1</span>] + <span class="string">"&amp;sign="</span> + info.wx_sign</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小程序内</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="string">'timeStamp'</span>: options.time,</span><br><span class="line">      <span class="string">'nonceStr'</span>: options.nounce,</span><br><span class="line">      <span class="string">'package'</span>: <span class="string">"prepay_id="</span> + options.package,</span><br><span class="line">      <span class="string">'signType'</span>: <span class="string">'MD5'</span>,</span><br><span class="line">      <span class="string">'paySign'</span>: options.sign,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wx.requestPayment(&#123;</span><br><span class="line">      ...obj,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>, res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相较于正常的直接在订单页下订单，这里多了一步，就是从H5跳过来后，还要拉起小程序的一个支付页，单独拉起支付框。</p>
<p>体验当然是没有完全在小程序中，不嵌入H5好的。如果是要快速迭代开发的话，这也是一种方法。</p>
<p>总之知道了这是一种替代的解决方案，或者说一种没有办法的办法。📚🌲还是很开心的。</p>
<p>最后欢迎来到微信-&gt;钱包入口的Qb充值入口来充各种游戏币，Qb, 包月服务哦。有的时候还有优惠。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自从小程序出来后，你肯定有这样的想法。小程序内部分页面好想复用以前的H5，重复的去开发浪费了大量的时间和精力。 但是内嵌在小程序中的H5不支持拉起微信支付。也就是说小程序内，小程序嵌入的H5内只能调用小程序支付。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://sevencai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>晚来的日本之行</title>
    <link href="http://sevencai.github.io/2018/06/02/%E6%99%9A%E6%9D%A5%E7%9A%84%E6%97%A5%E6%9C%AC%E4%B9%8B%E8%A1%8C/"/>
    <id>http://sevencai.github.io/2018/06/02/晚来的日本之行/</id>
    <published>2018-06-02T06:48:05.000Z</published>
    <updated>2018-06-02T08:18:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实啊，旅行的意义，不一定要是路上的风景，更是你路上的同行人。 2018年5月23 到 27 我在日本。</p>
</blockquote>
<h2 id="TOP-10"><a href="#TOP-10" class="headerlink" title="TOP 10"></a>TOP 10</h2><ol>
<li>干净整洁的日本街道</li>
<li>暖心负责的领队小哥哥  💖</li>
<li>有趣有爱的同伴  🚚</li>
<li>梅田的购物中心  ❄️</li>
<li>250 的牛肉自助餐</li>
<li>大阪大学的王者荣耀</li>
<li>帅气的日本小哥哥</li>
<li>老龄化的日本  💳</li>
<li>好（第四声）吃可爱的小鹿</li>
<li>最爱的许加二和涛哥  🍒</li>
</ol>
<hr>
<h2 id="最爱的图片"><a href="#最爱的图片" class="headerlink" title="最爱的图片"></a>最爱的图片</h2><p><img src="jp4.jpg" alt="奈良的小鹿"><br>或许是太久没有机会跟动物接触了。看到她们简直不能自拔，好想一直喂她们东西吃。上网查了下，她们的点头要吃的，实际在动物界并不是表示友好的行为，越爱鞠躬的小鹿，其实攻击性就越强。但是啊，她一点头，你就不舍得不给她吃东西。</p>
<p><img src="jp1.jpg" alt="干净漂亮的房子"></p>
<p>上面这张图片，是第一天酒店起来后，我跟室友去外边逛的时候拍的。小河特别干净，房子颜色特别美。</p>
<p><img src="jp2.jpg" alt="雨中的小房子"></p>
<p>这张图片是第一天赶到酒店的时候，天下起了小雨，外边有像大熊家一样的房子🏡。觉得特别的舒服。</p>
<p><img src="jp6.jpg" alt="药妆店门口的小狗"><br>小狗过得不开心吗？为什么眼里会有悲伤和难过。</p>
<p><img src="jp5.jpg" alt="可爱的小朋友"><br>猜猜我想拍的小朋友是？</p>
<p><img src="jp3.jpg" alt="酒店的外景"><br>白色的船，蓝蓝的海，高高的树，白色的桌子和椅子，绿色的山。（原谅我的语文水平，只能描述成这种水平了）</p>
<p><img src="jp7.jpg" alt="nuonuonuoyasuolong"><br>吃相扑餐的时候，不好吃。也没有吃饱😞。但是看在送了我 索隆 的份上，5星好评。</p>
<p><img src="jp10.jpg" alt="小狗"><br>其实，印象最深的不仅仅这个小狗，还有他的主人。主人大概60岁，我看狗狗的时候，他冲我笑了下，然后说了一串我听不懂的日语。可能是在说，没关系，你可以摸摸它，他不咬人。</p>
<hr>
<h2 id="最值得的事情"><a href="#最值得的事情" class="headerlink" title="最值得的事情"></a>最值得的事情</h2><p>最值得的事情，当然就是见到徐佳2啦。看着她那个乱的跟猪圈一样的宿舍，我觉得是时候要给她爸爸打报告了，怎么越长大越乱了呢？ 以前我们宿舍4个，她还算排倒数第2的，现在肯定是倒数第1了。</p>
<p>见得时间太少了，已经尽我最大的能力去挤时间。以后要是还去日本，我一定自由行，然后每天都跟她睡。白天一起逛吃逛吃，就像我们一起大学的时候那样。</p>
<p>一个人在外，那种无助的时候，肯定很多。赶紧回国，带你吃小龙虾。💗</p>
<p>在我去日本的时候，涛哥他们部门的团，也正好在日本了，所以很不容易的，我们在日本也见到了，他们为了顺应我的时间，时间很紧张。我们的缘分，肯定还要持续很久，很久🌲。</p>
<hr>
<h2 id="路痴的我"><a href="#路痴的我" class="headerlink" title="路痴的我"></a>路痴的我</h2><p>如果是不赶的路程，我肯定是一个人慢慢悠悠的找地方玩了。就算迷路了也不要紧，反正总能找到回家的路。但是跟团不一样，一定要保证大家不会因为我耽误时间。所以整个路程我就是根本摸不清东南西北。还好有徐佳2，小智和yunhui。</p>
<p>认路这件事，有时候真的感觉无能为力。☹️</p>
<hr>
<h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>给妈妈他们买了两双鞋子，还给嫂子买了很多护肤品，还给同事带了很多护肤品。给爸爸买了个表，哥哥啥都没给买。哈哈，他肯定怀疑我不是亲妹妹。不过，我给他即将出生的小宝宝，买了衣服。给自己还买了很多面膜。<br>通过买东西这件事情，告诉了我一定要努力工作，然后赚很多钱。</p>
<p>第一天晚上，吃了很好吃的冰淇淋🍨。超级开心。还喝了很便宜很好喝的酸奶，日本的便利店🏪是个好地方。</p>
<hr>
<h2 id="路上的人儿"><a href="#路上的人儿" class="headerlink" title="路上的人儿"></a>路上的人儿</h2><p>我这次的室友不是跟我一个部门的。当我提出，能不能徐佳2跟我一起住一晚上的时候，她马上就答应了。真的好谢谢。已经是两个孩子的妈妈了，然而一点都看不出来。👍</p>
<p>我的领队，是跟我一个部门的，但是以前从来没有见过，可能是没有工作上的交集，我们通常称呼他为小智。小智非常的靠谱，也是个超级暖心的小哥哥，每次都帮大家把事情安排的很好。不知道他自己有没有玩好。每次找不到地方了，就跟他打电话。他还每次都帮我提行李。觉得好温暖。笔芯。💖</p>
<p>yunhui, 是跟我一个部门的，以前没有见过，但是有问过他问题。他非常的爱笑，感觉一笑起来，让别人也会开心。yunhui 绝对是个旅行的好伙伴，有足够的好奇心，也有足够的耐力。攻略也做的很棒，关键是也认路。📚</p>
<p>我师父，jiaqian, 飞哥，赵宣，咸鱼, amy， tina就不说了，以前都很熟了,因为他们在，让我觉得这次旅行，一点都不陌生，也不拘谨。</p>
<p>村长，第一次跟他说了话，感觉好开心，还记得他那次诸葛亮把我们整个组虐的超级难受。总算是认识真人了。</p>
<p>日本的小姐姐都说话很小声，很有礼貌。日本的学生都穿制服，感觉很好。很帅气。😊</p>
<p>日本老奶奶跟我说谢谢的时候，我好想回她不用谢。但是憋了半天，满脸通红，还是一个字都没挤出来。</p>
<p>第一天晚上的酒店的小姐姐，想把伞还给她，一路上，想了半天怎么还给她，结果到了那里，一个字都没有说出来。☹️</p>
<p>我们的导游，朴岛很温和，已经加了他微信，加了后，整个朋友圈，都是代购的消息了，哈哈。朴导萌萌哒。✈️</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很开心的一次旅行，虽然信用卡💳都没知觉了。一生会有很多旅行，但是这次肯定是独一无二的。你遇到的风景，你遇到的人，你拍的照片，你脑海里那个爷爷的微笑，你对某些人的感情，又或者是旅行中不那么顺利开心的地方，都是旅行的宝贵所在。</p>
<p>我有的时候想，人生那么不可预测，也许明天你就没有机会去体验很多事情。所以你今天做的事情，会不会是最后一天你想做的事情。不要后悔。也不要遗憾。因为上帝给你留下的路，都是有他的道理。开心的，不开心的，它都是你生活中，或者说命运中的一部分。</p>
<p>我相信 connecting the dots。 ❤️ 🚚 📚 以后有机会跟家人一起去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实啊，旅行的意义，不一定要是路上的风景，更是你路上的同行人。 2018年5月23 到 27 我在日本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TOP-10&quot;&gt;&lt;a href=&quot;#TOP-10&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="生活日志" scheme="http://sevencai.github.io/tags/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>优化代码之throttle &amp; debounce</title>
    <link href="http://sevencai.github.io/2018/06/02/%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E4%B9%8B-throttle-debounce/"/>
    <id>http://sevencai.github.io/2018/06/02/优化代码之-throttle-debounce/</id>
    <published>2018-06-02T06:09:15.000Z</published>
    <updated>2018-06-02T06:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这几天翻了下以前写的代码，发现自己以前虽然有用 debounce 或者 throttle 的意识，但是确没有把代码封装的很好。比如没有用到闭包去封装 timer, 而是把 timer 放在了 vue data 的变量里。因此就出现了这篇文章，总结下 debounce 和 throttle 运用场景以及对应的自己的实现。并且重构了以前的代码。</p>
</blockquote>
<hr>
<h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>比如我曾经在一个项目里，就两种场景都用到了。</p>
<p>第一种比如当用户在搜索框里输入了数据的时候，我会去向后台请求，搜索出来的对应结果。 但是用户的输入可能是不断的进行的，如果我每次都去请求，那么其实是无效并且浪费的。<strong>所以我们可以在用户输入最后一个字的时候，再去发请求。 用到的就是 debounce 的原理，每次的请求都延迟一段时间去发出，当有新的请求来的时候，清空上次的请求，然后重新执行延迟一段时间去请求，直到用户没有再请求的时候，执行的就是最后一次延迟请求</strong>。</p>
<p>这种只去执行最后一次的就是我们说的 debounce。可以把它理解为<code>独占型的函数</code>。</p>
<p>第二种比如当用户滚动的时候，当滑到了这个字母开头的时候，提示给用户，你已经到了 H 开头的列表内容了。正常的情况下，我们的做法是一直监听 scroll 事件，然后计算当前的 li 是不是到了对应 H 字母开头了，到了则设置相应的提示。</p>
<p><strong>但是要知道 scroll 事件，每次都会触发很多次，如果每次进行相应的计算，就会很卡顿，尤其在一些老的机器上。 那么这个时候我们就可以用 throttle 了，每一段事件，比如 500 ms 去执行一次计算，而不是每次 scroll 都执行。</strong></p>
<p>可以把 throttle 理解为<code>节制型</code>的函数。</p>
<p>上面两个是我遇到过的两个场景，具体其他场景还可以参考：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 onresize 的时候，我们只想知道最后一次的大小</span></span><br><span class="line"><span class="built_in">window</span>.onresize = debounce(caculate, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户一段时间频繁点击时，只以最后一次为标准</span></span><br><span class="line">button.onclick = debounce(sendMail, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// onscroll 时定位元素</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(caculatePosition, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动，mousemove 事件</span></span><br><span class="line"><span class="built_in">window</span>.onmousemove = throttle(getElement, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>在 underscore lodash 里，都有相应的实现了。但是我感觉不太好理解额，所以按照自己的理解，写出了适应自己的 debounce 和 throttle。 具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * debounce</span><br><span class="line"> * @param fn</span><br><span class="line"> * @param wait</span><br><span class="line"> * @param leading</span><br><span class="line"> * @returns &#123;Function&#125;</span><br><span class="line"> */</span><br><span class="line">function debounce(fn, wait, &#123; leading = false &#125;) &#123;</span><br><span class="line">    let context,</span><br><span class="line">      args = arguments,</span><br><span class="line">      timer = null,</span><br><span class="line">      firstInvoke = true</span><br><span class="line"></span><br><span class="line">    function excute() &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">      context = this</span><br><span class="line"></span><br><span class="line">      if (firstInvoke &amp;&amp; leading) &#123;</span><br><span class="line">        excute()</span><br><span class="line">        firstInvoke = false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = setTimeout(excute, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leading 参数用于控制第一次是否需要在最开始就触发一次。主要的思想就是只要重新有调用，就把原来的那个被延迟执行了的方法取消。 取消的方法是设置 timer 为 null。firstInvoke 用于标识方法知否被执行了一次了。</p>
<p>下面是 throttle 的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* throttle</span><br><span class="line">* @param fn</span><br><span class="line">* @param wait</span><br><span class="line">* @param leading</span><br><span class="line">* @param trailing</span><br><span class="line">* @returns &#123;Function&#125;</span><br><span class="line">*/</span><br><span class="line">function throttle(fn, wait, &#123; leading = true, trailing = true &#125;) &#123;</span><br><span class="line">    let context, lastExec = 0, timer, args, firstInvoke = true</span><br><span class="line"></span><br><span class="line">    function excute() &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line"></span><br><span class="line">      lastExec = +new Date()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function (...arg) &#123;</span><br><span class="line">      let now = +new Date()</span><br><span class="line"></span><br><span class="line">      args = arg</span><br><span class="line"></span><br><span class="line">      context = this</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">      if (firstInvoke &amp;&amp; leading) &#123;</span><br><span class="line">        excute()</span><br><span class="line">        firstInvoke = false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!lastExec) &#123;</span><br><span class="line">        lastExec = now</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!!wait &amp;&amp; (now - lastExec) &gt;= wait) &#123;</span><br><span class="line">        excute()</span><br><span class="line">      &#125; else if (trailing) &#123;</span><br><span class="line">        timer = setTimeout(excute, wait)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>throttle 因为是按频率触发，所以每次的时间间隔是相同的。所以当没到该执行的时间点的时候，就把剩余的时间重新设置给 setTimeout 。wait 即为多少秒执行一次的时间。看了 underscroll 里的源码，它还设置了 trailing 这些参数。trailing 表示当最后一次没到执行时间时，你不想要延迟执行这个函数了。也就是最后一次调用将被忽略。</p>
<p>下面贴一下 underscroll 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Returns a function, that, when invoked, will only be triggered at most once</span><br><span class="line">// during a given window of time. Normally, the throttled function will run</span><br><span class="line">// as much as it can, without ever going more than once per `wait` duration;</span><br><span class="line">// but if you&apos;d like to disable the execution on the leading edge, pass</span><br><span class="line">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">  var timeout, context, args, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function() &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : _.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    if (!timeout) context = args = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function() &#123;</span><br><span class="line">    var now = _.now();</span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = function() &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = 0;</span><br><span class="line">    timeout = context = args = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>underscore 把 throttle 和 debounce 分开来实现了，但是有些别的封装的库则是用一个函数实现。下面是 underscore debounce 的实现</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Returns a function, that, as long as it continues to be invoked, will not</span><br><span class="line">  // be triggered. The function will be called after it stops being called for</span><br><span class="line">  // N milliseconds. If `immediate` is passed, trigger the function on the</span><br><span class="line">  // leading edge, instead of the trailing.</span><br><span class="line">  _.debounce = function(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var later = function(context, args) &#123;</span><br><span class="line">      timeout = null;</span><br><span class="line">      if (args) result = func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var debounced = restArguments(function(args) &#123;</span><br><span class="line">      if (timeout) clearTimeout(timeout);</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        var callNow = !timeout;</span><br><span class="line">        timeout = setTimeout(later, wait);</span><br><span class="line">        if (callNow) result = func.apply(this, args);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        timeout = _.delay(later, wait, this, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剩下的时间就是去优化代码啦。看了下别人的源码，然后自己又按照自己的方式实现了下，还是很有收获的。</p>
<p>不过，如果 underscore 已经有这么成熟的东西，实际上，我觉得可以不用重复的去做这个工作。用别人成熟的内容就好了。自己了解了原理，自己可以实现，有问题知道怎么去查就好。</p>
<p><img src="xixi.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天翻了下以前写的代码，发现自己以前虽然有用 debounce 或者 throttle 的意识，但是确没有把代码封装的很好。比如没有用到闭包去封装 timer, 而是把 timer 放在了 vue data 的变量里。因此就出现了这篇文章，总结下
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>解决webpack编译后导致-webkit-box被强制去除了的问题</title>
    <link href="http://sevencai.github.io/2018/05/11/%E8%A7%A3%E5%86%B3webpack%E7%BC%96%E8%AF%91%E5%90%8E%E5%AF%BC%E8%87%B4-webkit-box%E8%A2%AB%E5%BC%BA%E5%88%B6%E5%8E%BB%E9%99%A4%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sevencai.github.io/2018/05/11/解决webpack编译后导致-webkit-box被强制去除了的问题/</id>
    <published>2018-05-11T12:12:36.000Z</published>
    <updated>2018-05-11T12:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天遇到了一个问题，发现重构同事的 dist css 在我这里有兼容性问题。我只引用了他的源文件，未经过任何更改。排处了由于 Dom 结构不同的原因之外，唯一的不一样的地方，就是我引入他的文件后，在本地还进行了webpack 编译。那么问题只能出在了这里了。</p>
<p>经过对比两份文件发现，对比如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 重构同事的css</span><br><span class="line"><span class="selector-class">.detail-title</span>&#123;</span><br><span class="line">	<span class="attribute">-ms-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">-webkit-box-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">box-flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">// 我编译后的文件</span><br><span class="line"><span class="selector-class">.detail-title</span>&#123;</span><br><span class="line">	<span class="attribute">-ms-flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="attribute">box-flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>咦， <code>-webkit-box-flex</code> 竟然被自动去除了。难道说在某种 webpack 插件下， <code>-webkit-box</code> 会自动被去除吗？</p>
<p>在网上搜了下，发现确实是有这种情况。有些插件的机制判断这个内容是不需要的，强行被去除了。可以看这个 <a href="https://github.com/webpack/webpack/issues/2543" target="_blank" rel="noopener">issue</a>。</p>
<p>即使你是使用了 postCss, autoprefix 去添加了前缀，但是你用了去除的插件也会被去除。</p>
<hr>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>首先看下是什么插件导致了你的代码被强制的去除了。</p>
<p>大概的原因可能有以下几种：</p>
<p><strong>最开始可能是由于 <code>UglifyJsPlugin</code> 中默认把 <code>minimize = true</code> 开启了， 而这个字段在<code>css-loader</code>和<code>postcss-loader</code>中设置成 <code>true</code> 会开启优化模式，所以会对代码进行优化压缩。<br>但 <code>css-loader</code> 中又会使用 <code>cssnano</code> 进行压缩， 而 <code>cssnano</code>中又会进行无关前缀的清理。</strong></p>
<p>为什么插件竟然会影响到loader ? 可以关注下这个 <a href="https://github.com/ShowJoy-com/showjoy-blog/issues/31" target="_blank" rel="noopener">issue</a>。</p>
<p>这个插件(UglifyJsPlugin) 在 webpack2.x 貌似已经修复了。 <code>css-loader</code>及<code>autoprefixer</code>也已经做了相应的优化处理。如果你没有升级，你可以设置下面的方式试试：</p>
<ol>
<li><p>css-loader 传递参数：<code>?minimize&amp;-autoprefixer</code></p>
</li>
<li><p>向 <code>autoprefixer</code> 传递参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postcss: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [autoprefixer, cssnano(&#123; <span class="attr">safe</span>: <span class="literal">true</span> &#125;)];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果还有问题，再检查下，代码里有没有用到其他的去除优化工具。</p>
<p>我这边出的问题就是在这里。用了<code>OptimizeCSSPlugin</code>,  它默认把前缀给去掉了。所以这里我直接把这个 plugin 删除了。之所以我这里可以直接删除，是因为重构同事给到的就是去除压缩好了的。没有必要再去压缩去除一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">// duplicated CSS from different components can be deduped.</span><br><span class="line"></span><br><span class="line">new OptimizeCSSPlugin(&#123;</span><br><span class="line">  cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">    ? &#123; safe: true, map: &#123; inline: false &#125; &#125;</span><br><span class="line">    : &#123; safe: true &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>再来看下为什么用了<code>OptimizeCSSPlugin</code>去除了prefix呢？看了下源码，也是又引入了<code>cssnano</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.options.cssProcessor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.options.cssProcessor = <span class="built_in">require</span>(<span class="string">'cssnano'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="引申问题-ssi-找不到定义的变量"><a href="#引申问题-ssi-找不到定义的变量" class="headerlink" title="引申问题 - ssi 找不到定义的变量"></a>引申问题 - ssi 找不到定义的变量</h1><p><strong>由这个打包的问题，想到了前几天的另一个 webpack 的问题， index.shtml 文件中引入的 ssi, 如果变量用 ${variable} 读取，而不是$variable 读取，webpack 编译时就会报错。</strong>但实际上，这两种语法都是可以被 server 端解析的。探究了下会被报错的原因：</p>
<p>webpack 的 HtmlWebpackPlugin 在编译模板的时候，用的是 lodash 的 template 方式, 也就是 <code>${variable}</code> 的形式。</p>
<p>所以你用了 ${variable} 的形式的话，他就会去编译这个变量，但是呢，这个 variable 你是从 ssi 上读的，又没有定义，它找不到，所以就会报错了。</p>
<p>所以就老老实实的，如果你用的 htmlWebpackPlugin 就用 <code>$varialbe</code> 的形式吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// correct</span><br><span class="line">&lt;!--#include virtual=&quot;xxx.cgi?refresh_token=$wxRefreshToken&amp;appid=$wxAppid&quot; --&gt;&apos;;</span><br><span class="line"></span><br><span class="line">// wrong: wxAppid is not defined</span><br><span class="line">&lt;!--#include virtual=&quot;xxx.cgi?refresh_token=$wxRefreshToken&amp;appid=$&#123;wxAppid&#125;&quot; --&gt;&apos;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ol>
<li><a href="https://github.com/webpack/webpack/issues/283" target="_blank" rel="noopener">issue1: # Why does the UglifyJsPlugin affect other loaders?</a></li>
<li><a href="https://github.com/ShowJoy-com/showjoy-blog/issues/31" target="_blank" rel="noopener">issue2: # 「前端」从UglifyJSPlugin强制开启css压缩探究webpack插件运行机制</a></li>
<li><a href="https://github.com/webpack/webpack/issues/2543" target="_blank" rel="noopener">issue3: # Using plugin “webpack.optimize.UglifyJsPlugin” led to remove the style “display: -webkit-flex;</a></li>
</ol>
<p>觉得略坑。还是花了大概一下午看这个问题，呜呜呜(ಥ _ ಥ)!</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天遇到了一个问题，发现重构同事的 dist css 在我这里有兼容性问题。我只引用了他的源文件，未经过任何更改。排处了由于 Do
    
    </summary>
    
    
      <category term="工具" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>小程序支持分包加载和无需用户授权获得头像</title>
    <link href="http://sevencai.github.io/2018/04/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%85%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%97%A0%E9%9C%80%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E8%8E%B7%E5%BE%97%E5%A4%B4%E5%83%8F/"/>
    <id>http://sevencai.github.io/2018/04/23/小程序支持分包加载和无需用户授权获得头像/</id>
    <published>2018-04-23T06:56:06.000Z</published>
    <updated>2018-04-23T07:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>结论：增加了分包加载特性，速度快了很多。修改了用户授权逻辑，使用 open-data 能力改为了完全不用用户授权即可获得昵称头像群名称等。</p>
</blockquote>
<hr>
<h1 id="改版效果"><a href="#改版效果" class="headerlink" title="改版效果"></a>改版效果</h1><p>星期六的时候把手边的小程序改为了分包加载。产品是没有提这个需求的，但是心想下次做小程序的需求估计要很久以后了，就星期六加了下班。效果还是很好的。</p>
<blockquote>
<p>首屏加载时间由： 7.95s 减少到了 5.00s<br>平均 cpu 占比右：19.19% 减少到了 4.77%</p>
</blockquote>
<p>我并不知道很清楚这个平均 cpu 占比是怎么被算出来的。如果这个数据的变化能够微信团队能够解释的更详细些就好了。</p>
<p>在分包的加载过程中，比如首页是一个 packageA， 到列表页是一个 packageB, 这个过程在第一次访问列表页的时候，会再去下载代码。微信在这个过程中帮助了开发者显示了提示： 类似于页面加载中。 这个还是很友好的。</p>
<p>但是使用分包加载给开发者带来的成本也很大，基本上目录都被更改了。结构也被更改了。其实我是觉得如果能够不更改目录，只在 json 里面配置好打包的方案是最好的。其实仔细想想不更改目录也是行的吧？</p>
<blockquote>
<p>小程序经历过几次的“改版”，最开始的 pages, 后来的 component, 先在的 subPackage, 虽然一直再变得更好，但是对于一开始就开发小程序的开发者来说，或者至少对我来说，是不那么友好的。以后等这里逐渐更加成熟了，应该会好的。</p>
</blockquote>
<hr>
<h1 id="怎么开发分包加载"><a href="#怎么开发分包加载" class="headerlink" title="怎么开发分包加载?"></a>怎么开发分包加载?</h1><p>首先开始把目录结构定好，配置在 app.json 里，这个配置实际就是小程序会怎么分包加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/index/index"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>: &#123;</span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>: <span class="string">"light"</span>,</span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#3b8cff"</span>,</span><br><span class="line">    <span class="string">"backgroundColor"</span>: <span class="string">"#3b8cff"</span>,</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"腾讯充值"</span>,</span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>: <span class="string">"light"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"subPackages"</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">      <span class="string">"root"</span>: <span class="string">"result"</span>,</span><br><span class="line">	  <span class="string">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/result/result"</span></span><br><span class="line">	  ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"root"</span>: <span class="string">"userCenter"</span>,</span><br><span class="line">	  <span class="string">"pages"</span>: [</span><br><span class="line">        <span class="string">"pages/user_center/user_center"</span></span><br><span class="line">	  ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的目录结构，除了个人中心以及结果页以外的内容都是会在第一次下载了。 待页面跳转到 result 结果页，相关代码才会被下载并加载。</p>
<p>注意由于页面的目录发生了变化，以前如果是通过相对路径引用如 util 里的文件，那么路径都是要更改的。建议这里都使用 <code>/images/a.png</code> or <code>/utils/a.js</code>这种绝对路径比较好。</p>
<hr>
<h1 id="怎么获得昵称还不需要用户授权？"><a href="#怎么获得昵称还不需要用户授权？" class="headerlink" title="怎么获得昵称还不需要用户授权？"></a>怎么获得昵称还不需要用户授权？</h1><p>前天微信发布了新的文章，地址<a href="https://mp.weixin.qq.com/s/FTVGVXHSWPlYN1oQTzj-mA" target="_blank" rel="noopener">戳这里</a>,里面讲到了：</p>
<blockquote>
<p> 用户在没有任何操作的情况直接弹出授权的登录方式将逐渐不再支持，受影响的有 wx.getUserInfo 接口，以及 wx.authorize 接口传入 scope=”scope.userInfo” 的情况。</p>
</blockquote>
<p>它推荐了两种做法：</p>
<blockquote>
<p>1、按钮组件的登录方式，用户主动点击按钮可以拉起用户授权弹框，获取用户头像、昵称等信息；<br>2、在不获取用户信息的情况下，可展示用户头像昵称。</p>
</blockquote>
<p>第一种用于你真的是需要获得到昵称和图标，做一些其他的工作，比如存储的工作。这种情况，开发者是可以得到昵称和图标的值的。但是它也需要用户去触发，比如你点击个人中心的时候，是一个 btn, 这个 button, 会调用 getUserInfo 这种操作。</p>
<p><code>&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;userInfoHandler&quot;&gt;微信登录&lt;/button&gt;</code></p>
<p>注意既然还是调用了授权，那么一定还是会弹框提示用户是否允许授权，如果用户拒绝了也是得不到的。</p>
<p>第二种，如果你只是需要用户的昵称和头像展示在页面里，而不是真正的需要获得这些数据存储在某个地方或者向后台接口传递这些值。那么就告别<code>wx.authorize</code>和<code>wx.getUserInfo</code>吧。</p>
<p>我仔细想了下我们的充值页面，存储的都是 openid，没有需要去真正的用到 nickName 和 avatar 这些。只是为了再页面展示而已，所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;open-data type=&quot;groupName&quot; open-gid=&quot;xxxxxx&quot;&gt;&lt;/open-data&gt;</span><br><span class="line">&lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt;</span><br><span class="line">&lt;open-data type=&quot;userGender&quot; lang=&quot;zh_CN&quot;&gt;&lt;/open-data&gt;</span><br></pre></td></tr></table></figure>
<p>利用 open-data 既可以完美的解决啦。 也可以给它加入 class, 跟正常的 view 是类似的。</p>
<p>这样就完美啦，以后再也不需要用户授权啦。嘿嘿嘿。（产品开心，我也开心）</p>
<p>对了这里注意，open-data 只能在真机上试出来，我的目前版本的开发者工具是展示不出来的。如果你开发者工具上出不来，就试试真机。可能是版本原因。</p>
<hr>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote>
<p>微信 6.6 客户端，1.7.3 及以上基础库开始支持，请更新至最新客户端版本，开发者工具请使用 1.01.1712150 及以上版本</p>
</blockquote>
<p>注意这里的分包加载必须在1.7.3及以上开始支持。为了能够在 1.7.3 以下至少页面正常。你可以兼容。或者再微信公众平台后面来设置，最低版本为 1.7.3,这种情况下：</p>
<blockquote>
<p>若用户使用的基础库版本低于设置的最低版本要求，则无法正常使用小程序，并提示更新微信版本。</p>
</blockquote>
<p>open-data 是在 1.4.4 以上，好像，所以如果你设置了分包加载的，那么这个肯定也没问题啦。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要是代码目录结构改变了，导致比如以前代码里的 <code>navigateTo({url: &#39;../../result/result&#39;})</code>路径都需要改变，这些话费了时间重构。但是看到结果上是快了这么多的就好。</p>
<p>还有就是为什么 page 里不能用 behavior? 只有 component 里面能用？ 这个我感觉不太合理。vue 里面 每个 page 也是一个 component 来着。</p>
<p>其实插件的功能我也想试试，但是现在还没有想到可以使用的场景。也许是以后可以像交易记录这种做成小程序，别的外部业务就可加了吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;结论：增加了分包加载特性，速度快了很多。修改了用户授权逻辑，使用 open-data 能力改为了完全不用用户授权即可获得昵称头像群名称等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;改版效果&quot;&gt;&lt;a href=&quot;#改版效果&quot; c
    
    </summary>
    
    
      <category term="小程序" scheme="http://sevencai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>长列表图片优化方式</title>
    <link href="http://sevencai.github.io/2018/03/22/%E9%95%BF%E5%88%97%E8%A1%A8%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>http://sevencai.github.io/2018/03/22/长列表图片优化方式/</id>
    <published>2018-03-22T09:57:50.000Z</published>
    <updated>2018-03-22T11:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在的一个项目中，本来不长的列表页变得很长很长。并且每个<code>li</code>都会有一个图片。这就迫使我必须要想办法优化这个长列表了。以前总以为是不是对于长列表而言性能的瓶颈更多在与 dom 和js, 但是实际上图片仍然也占很大一部分。为了用户考虑，怎么样减少图片带来的流量，对于节省带宽及用户的电池十分重要。</p>
</blockquote>
<p>长列表可以从以下这几个方面去优化：</p>
<hr>
<h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>图片懒加载，长列表最大的问题就是图片太多，如果一次性把图片全部请求了，那么页面渲染速度会很慢，如果用户点不到，还会造成很大的浪费，甚至会有性能瓶颈。</p>
<p>为什么要使用懒加载呢？为了加速页面的加载速度，减少不必要的请求，我们可以将未出现在可视区域的图片先不做加载，等到滚动到可视区域以后再去加载。这样提升了性能和提高了用户体验。</p>
<p>那么原理就很简单了：<strong>一开始时，所有图片都有一个默认的 src, 指向本地的一个 <code>default.png</code> ,并且把img的真实的地址放在 <code>data-src</code>上。当滚动时，判断元素是否在可视区域，如果在可视区域,那么再把 <code>data-src</code> 上的值写入真正的 src 中。</strong></p>
<hr>
<h1 id="从图片本身优化"><a href="#从图片本身优化" class="headerlink" title="从图片本身优化"></a>从图片本身优化</h1><p>第二种思路就是从图片的本身去优化，比如更换图片格式。由 png,jpg,jpeg,gif 转换为更好的 webp。</p>
<blockquote>
<p><strong>WebP 的优势在与它更好的图像数据压缩算法，能够将图片转换为更小的体积，具有无损和有损的压缩模式。如果是选择了有损压缩，也拥有肉眼无法识别差异的图像质量。虽然它在页面渲染的时候浏览器比jpg会花稍长的时间解析它的算法，但是权衡它所带来的体积的减少来看，WebP 还是最优秀的。</strong></p>
</blockquote>
<p>关于它的有损和无损来说，无损的体积减少会稍微小一些，而有损的体积会减少的非常多。如果不是对图片质量要求很多，对于一般的图片，用有损就很好了。<strong>webp无损压缩可以减少图片一半的大小而达到同样无损的效果。</strong>可以看下面一份数据：</p>
<blockquote>
<p>YouTube的视频缩略图采用WebP后，网页加载速度提升了10%；谷歌网上应用商店采用WebP后，每天可节省几TB的带宽，页面平均加载时间大约减少1/3；谷歌移动应用市场采用WebP图片格式后，每天节省了50TB的存储空间；2014年腾讯新闻客户端应用了WebP后，流量峰值带宽降低9GB，网络连接延时不变的前提下，平均图片延时和数据下载延时降低了100ms；2014年空间装扮也全量转换成WebP，带宽上也有显著降低。</p>
</blockquote>
<p>但是 WebP 不是每个浏览器都支持。所以要实践的话可以从下面两个方面考虑：</p>
<p>从服务端考虑：<br>如果浏览器支持 WebP ,那么会在 request header  accept里，发送<code>image/webp</code>, 服务器收到以后根据这个来去返回给客户端图片。请求头里有，则发送webp的，如果没有，就发送普通jpg的。</p>
<p>不过这个对服务器要求比较高，并且现在图片大多放在 <code>CDN</code> 上，<code>CDN</code>去做这种策略可能会稍微麻烦点。</p>
<p>从前端考虑：<br>前端去检测浏览器是否支持 WebP, 支持就发送 WebP 的图片请求，不支持就发送 JPG,PNG 等的。下面是一行代码判断是否支持WebP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isSupportWebp = !!\[\].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;</span><br></pre></td></tr></table></figure>
<p><code>!!\[\].map</code>主要是判断是否是IE9+，以免<code>toDataURL</code>方法会挂掉。如果你直接对数组原型扩展了map方法，则需要使用<code>!!\[\].map</code>以外的方法进行判断，例如<code>!!window.addEventListener</code>等。</p>
<p>哈哈，这个我是偶然在zhangxinxu的博客上看到的，感觉这个要比其他的方法更加简洁和好。<a href="http://www.zhangxinxu.com/php/microCodeDetail.php?id=3" target="_blank" rel="noopener">地址在这里。</a></p>
<p>最后我没有做这一层优化，因为图片太多，已经被发到了CDN 上，图片源可能都不在了，没有让他们去把图片变成 WebP。 如果一开始就问 CDC 的同事要两种图片格式就好了。sad。</p>
<hr>
<h1 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h1><p>首先有两种判断元素是否在可视区域的方法：</p>
<ol>
<li>offsetTop - scrollTop &lt; clientHeight ，代表在可视区。</li>
<li>IntersectionObserver，这个 Api 可以直接来判断。</li>
</ol>
<p>注意可以用 throttle 防止请求次数过高，在一定的时间范围内只请求1次。下面的代码是随意写的，没有跑过。可以当做伪码来看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const checkVisible = (ele) =&gt; &#123;</span><br><span class="line">  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">  let clientHeight = document.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">  return ele.offsetTop - scrollTop &lt; clientHeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let imgs = document.getElementsByTagName(&quot;img&quot;), nums = imgs.length</span><br><span class="line"></span><br><span class="line">const lazyLoad = () =&gt; &#123;</span><br><span class="line">  for (let i = 0; i &lt; nums; i++) &#123;</span><br><span class="line">    if (checkVisible(imgs[i]) &amp;&amp; imgs[i].getAttribute(&quot;src&quot;) === &quot;default.png&quot;) &#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(&quot;data-src&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const throttle = (action, delay) =&gt; &#123;</span><br><span class="line">  let timeout = null</span><br><span class="line">  let lastRun = 0</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (timeout) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let elapsed = Date.now() - lastRun</span><br><span class="line">    let context = this</span><br><span class="line">    let args = arguments</span><br><span class="line">    let runCallback = function () &#123;</span><br><span class="line">      lastRun = Date.now()</span><br><span class="line">      timeout = false</span><br><span class="line">      action.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">    if (elapsed &gt;= delay) &#123;</span><br><span class="line">      runCallback()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout = setTimeout(runCallback, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&quot;scroll&quot;, throttle(lazyLoad, 1000))</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h1><p>因为项目本身是Vue写的，所以我也去在网上找了相应的<code>directives</code>, 已经有了很好的一些实现。他们的比较完整，比如下面这个：<a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">https://github.com/hilongjw/vue-lazyload</a>，用法很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  attempt: 2,</span><br><span class="line">  listenEvents: [&quot;scroll&quot;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后再 img 标签上，使用这个 <code>directive</code>， <code>v-lazy</code> 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;mod-service__pic&quot; v-lazy=&quot;list.icon&quot; aria-hidden=&quot;true&quot; v-bind:alt=&quot;list.name&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在做这个过程中，我还看了一些其他的内容，比如 png8, png24, svg,这些。也去看了下vue-lazyload这个库的源码。收货多多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在的一个项目中，本来不长的列表页变得很长很长。并且每个&lt;code&gt;li&lt;/code&gt;都会有一个图片。这就迫使我必须要想办法优化这个长列表了。以前总以为是不是对于长列表而言性能的瓶颈更多在与 dom 和js, 但是实际上图片仍然也占很大一部分。为
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>isObjEmpty/once function/template rendering/cdn的实现和解释</title>
    <link href="http://sevencai.github.io/2018/03/21/isObjEmpty-once-function-template-rendering-cdn%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%A7%A3%E9%87%8A/"/>
    <id>http://sevencai.github.io/2018/03/21/isObjEmpty-once-function-template-rendering-cdn的实现和解释/</id>
    <published>2018-03-21T03:03:57.000Z</published>
    <updated>2018-03-21T03:18:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>总结了几种判断 Object 是否为空的方法<br>总结 once function (只执行一次函数代码)<br>实现两种简单的字符串模板替换方法<br>重新归纳总结了下CDN和DNS的名词解释</p>
</blockquote>
<hr>
<h1 id="once-function-让函数只执行一次"><a href="#once-function-让函数只执行一次" class="headerlink" title="once function 让函数只执行一次"></a>once function 让函数只执行一次</h1><p>这里利用了闭包很好的保存了内层函数的返回值内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">const once = (fn, context) =&gt; &#123;</span><br><span class="line"> var result</span><br><span class="line"></span><br><span class="line"> return function () &#123;</span><br><span class="line">  if (fn) &#123;</span><br><span class="line">   result = fn.apply(context || this, arguments)</span><br><span class="line">   fn = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">let logOnce = once(function () &#123;</span><br><span class="line"> return Array.prototype.slice.call(arguments)[0]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">logOnce(4,5)  // get 4</span><br><span class="line">logOnce(6,7)  // get 4</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="实现简单的模板字符串替换"><a href="#实现简单的模板字符串替换" class="headerlink" title="实现简单的模板字符串替换"></a>实现简单的模板字符串替换</h1><p>经常会有下面的需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let template = `我叫&#123;&#123;name&#125;&#125;, 我的性别是&#123;&#123;sex&#125;&#125;`</span><br><span class="line">let person = &#123;</span><br><span class="line"> name: &apos;Seven&apos;,</span><br><span class="line"> sex: &apos;female&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;我叫Seven, 我的性别是female&apos;)</span><br></pre></td></tr></table></figure></p>
<p>下面是一种简单的实现，把模板和对象，结合为目标字符串，方法1如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const parseTemplateByRegFunc = (obj, template) =&gt; &#123;</span><br><span class="line"> return template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g, (match, key) =&gt; obj[key.trim()])</span><br><span class="line">&#125;</span><br><span class="line">parseTemplateByRegFunc(&#123;name: &apos;seven&apos;&#125;, &apos;我叫&#123;&#123; name&#125;&#125;&apos;) // 我叫seven</span><br></pre></td></tr></table></figure></p>
<p>方法2比较容易想到，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const parseTemplateByObjectKeys = (obj, template) =&gt; &#123;</span><br><span class="line"> Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">  template = template.replace(new RegExp(`&#123;&#123;\\s*$&#123;key&#125;\\s*&#125;&#125;`, &apos;g&apos;), obj[key])</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> return template</span><br><span class="line">&#125;</span><br><span class="line">parseTemplateByObjectKeys(&#123;name: &apos;seven&apos;&#125;, &apos;我叫&#123;&#123; name&#125;&#125;&apos;) // 我叫seven</span><br></pre></td></tr></table></figure></p>
<p>简单的把 obj 里面每个key 都替换一次。方法1用到的是replace的特性。</p>
<hr>
<h1 id="关于-CDN"><a href="#关于-CDN" class="headerlink" title="关于 CDN"></a>关于 CDN</h1><p>DNS 是域名解析系统，它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。其中有一项技术是会找到一个合适的IP给用户。这种根据每台机器的负载量，该机器离用户地理位置的距离等等，返回合适的IP的技术称之为 DNS 重定向。CDN就是利用的DNS重定向技术。</p>
<blockquote>
<p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，<strong>CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</strong>。</p>
</blockquote>
<p>上面的内容以前是知道的，这里重新归纳了下。</p>
<hr>
<h1 id="isObjEmpty-的实现（判断对象是否为空）"><a href="#isObjEmpty-的实现（判断对象是否为空）" class="headerlink" title="isObjEmpty 的实现（判断对象是否为空）"></a>isObjEmpty 的实现（判断对象是否为空）</h1><p>使用 for … in，如果进入了循坏，代表对象不为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let key in obj) &#123;</span><br><span class="line"> if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">  return false</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br></pre></td></tr></table></figure></p>
<p>使用 Object keys， 得到空数组，则代表对象为空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Object.keys(obj).length === 0</span><br></pre></td></tr></table></figure></p>
<p>使用 JSON.stringify 和 空对象对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return JSON.stringify(obj) === JSON.stringify(&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;总结了几种判断 Object 是否为空的方法&lt;br&gt;总结 once function (只执行一次函数代码)&lt;br&gt;实现两种简单的字符串模板替换方法&lt;br&gt;重新归纳总结了下CDN和DNS的名词解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>进阶我的Vim</title>
    <link href="http://sevencai.github.io/2018/03/15/%E8%BF%9B%E9%98%B6%E6%88%91%E7%9A%84Vim/"/>
    <id>http://sevencai.github.io/2018/03/15/进阶我的Vim/</id>
    <published>2018-03-15T13:02:14.000Z</published>
    <updated>2018-03-15T13:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这两天做了一个很繁琐的需求，简单的来说，就是把一个产品配置的复杂的excel表，转入为json, 然后再用 javascript 脚本拼接为对应 php 页面可执行代码。繁琐的是配置多且杂，并且产品的归类excel 转换为的 json 并不可用。于是我还需要在他们的excel表里，进行更改。其实这个工作应该做一个配置台，让产品去维护。 以后就不用开发手动维护这个配置表。</p>
</blockquote>
<p>总之是提前做完了，虽然做的过程中, 不是怀着非常愉快的心情做的。晚上剩了点多的时间，把 vim 稍微进阶了一点。以前的基本命令都已经熟练使用了。现在总结下用的不是很熟的几个地方。</p>
<hr>
<h1 id="几个还没有用熟练的指令"><a href="#几个还没有用熟练的指令" class="headerlink" title="几个还没有用熟练的指令"></a>几个还没有用熟练的指令</h1><p><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符, 不同于<code>a,i,o</code>哦。</p>
<p><code>0,$,^,g_</code> 的区别和联系。<code>0,$</code>是到行头和行尾，<code>^,g_</code>到非blank字符位置。</p>
<p><code>ctrl+r</code> 和 <code>u</code>, 因为 WebStorm 里这些都还可以用以前的 <code>ctrl+z</code> 之类的执行。所以这两个命令有点被我忽略了。其实应该改过来。</p>
<p><code>w</code> 到下一个单词的开头。<code>e</code>  到下一个单词的结尾。如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。</p>
<hr>
<h1 id="查找超能力"><a href="#查找超能力" class="headerlink" title="查找超能力"></a>查找超能力</h1><ol>
<li><code>fa</code>  到下一个为a的字符处，你也可以fs到下一个为s的字符。</li>
<li><code>t,</code>  到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li><code>3fa</code>  在当前行查找第三个出现的a。</li>
<li><code>F和T</code> 和 <code>f和t</code> 一样，只不过是相反方向。</li>
<li><code>/pattern</code>  搜索 <code>pattern</code>  的字符串, 如果又多个，按n到下一个。</li>
<li><code>t,</code> 到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li><code>dt.</code> 删除当前字符到<code>.</code>为止的所有内容。</li>
</ol>
<p>注意补充下<code>normal</code>模式下按<code>/</code>即可进入查找模式， n为下一个，N为上一个。如果是 <code>/singer\c</code>代表查找singer,并且大小写不敏感。因为默认情况下，它是大小写敏感的。相应的，<code>\C</code>代表大小写敏感。</p>
<p>你还可以在此模式下加入正则表达式，比如<code>/inger$</code> ，这时以<code>inger</code>结尾的都会被查出来。</p>
<p>在<code>normal</code>模式下的查找，还可以使用直接按<code>*</code>,来查找当前光标所在的单词。这时候的查找的单词前后都是空白字符或者标点符号。例如当前为<code>foo</code>， 可以匹配<code>foo bar</code>中的<code>foo</code>，但不可匹配<code>foobar</code>中的<code>foo</code>。<strong>经常用于查找函数</strong>。如果想要包含关系，使用<code>g*</code>即可。</p>
<hr>
<h1 id="替换能力"><a href="#替换能力" class="headerlink" title="替换能力"></a>替换能力</h1><p>刚刚提到了查找的能力，<code>normal</code>下使用<code>/</code>即可进入查找模式。替换模式则是使用<code>:s</code>。具体情况如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>:%s/singer/author/g</code>会在全局范围(<code>%</code>)查找<code>singer</code>并替换为<code>author</code>，所有出现都会被替换（<code>g</code>）。如果使用<code>:s/singer/author</code>则只会在当前行替换一个。</p>
<p>这里的<strong>作用范围</strong>可以总结如下：</p>
<blockquote>
<ol>
<li>%全文查找， 如 :%s/singer/author/g</li>
<li>不填写默认当前行，如:s/singer/author/g</li>
<li>:5,12s/singer/author/g, 第5-12行</li>
<li>:.,+2s/singer/author/g， 当前行和接下来的2行。 注意<code>.</code>是当前行， <code>,</code>是分隔符</li>
<li>:’&lt;,’&gt;s/singer/author/g把选区内的内容替换。注意下：在Visual模式下选择区域后输入<code>:</code>，Vim即可自动补全为 <code>:&#39;&lt;,&#39;&gt;</code>。WebStorm也会做同样的事情。</li>
</ol>
</blockquote>
<p>这里的<strong>替换标识</strong>可以总结如下代表：</p>
<blockquote>
<ol>
<li><code>%s/singer/author</code>, 空标识表示：只替换从光标位置开始，目标的第一次出现</li>
<li><code>%s/singer/author/g</code>, global 表示全局</li>
<li><code>i</code>表示大小写不敏感查找，<code>I</code>表示大小写敏感</li>
<li><code>:%s/singer/author/gc</code> c表示全局查找后替换需要被确认。它可能会弹出一句：Replace with author ?  (y/n/…)之类的东西。</li>
</ol>
</blockquote>
<hr>
<h1 id="区域选则-lt-action-gt-a-lt-object-gt-以及-lt-action-gt-i-lt-object-gt"><a href="#区域选则-lt-action-gt-a-lt-object-gt-以及-lt-action-gt-i-lt-object-gt" class="headerlink" title="区域选则 &lt;action&gt;a&lt;object&gt;以及 &lt;action&gt;i&lt;object&gt;"></a>区域选则 <code>&lt;action&gt;a&lt;object&gt;</code>以及 <code>&lt;action&gt;i&lt;object&gt;</code></h1><p>其实这个我已经很熟了，今天看到了别人的总结（注：下面的这段为引用内容，引用地址为：<a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">coolshell</a>）。</p>
<blockquote>
<p>action可以是任何的命令，如 <code>d</code>  (删除),  <code>y</code>  (拷贝),  <code>v</code>  (可以视模式选择)。</p>
<p>object 可能是： <code>w</code>  一个单词， <code>W</code>  一个以空格为分隔的单词， <code>s</code>  一个句字， <code>p</code>  一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>&#39;、</code> <code>)、</code> <code>}、</code> <code>]。</code></p>
</blockquote>
<p>a和i的区别也很好分。i不包括，a包括了。看下面这个例子。</p>
<p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o</code> 的位置。</p>
<blockquote>
<ul>
<li><code>vi&quot;</code>  → 会选择 <code>foo</code>.</li>
<li><code>va&quot;</code>  → 会选择 <code>&quot;foo&quot;</code>.</li>
<li><code>vi)</code>  → 会选择 <code>&quot;foo&quot;</code>.</li>
<li><code>va)</code>  → 会选择<code>(&quot;foo&quot;)</code>.</li>
<li><code>v2i)</code>  → 会选择 <code>map (+) (&quot;foo&quot;)</code></li>
<li><code>v2a)</code>  → 会选择 <code>(map (+) (&quot;foo&quot;))</code></li>
</ul>
</blockquote>
<hr>
<h1 id="VIM-的Visual模式"><a href="#VIM-的Visual模式" class="headerlink" title="VIM 的Visual模式"></a>VIM 的Visual模式</h1><p>vim 分为3中 visual 模式，分别是：</p>
<h2 id="Visual-默认模式："><a href="#Visual-默认模式：" class="headerlink" title="Visual 默认模式："></a>Visual 默认模式：</h2><p><code>normal</code> 下 ，按 v 进入 <code>visual</code> 默认模式。这个模式下可以 hjkl 进行各种上下移动。选中文本后，可以进行 y,d,p,^,$等操作。</p>
<h2 id="Visual-Line-模式"><a href="#Visual-Line-模式" class="headerlink" title="Visual Line 模式"></a>Visual Line 模式</h2><p><code>normal</code>下，按 V 进入 <code>visual line</code>模式。 使用 j/k键可以选中一行或者多行。进行正行操作。</p>
<h2 id="Visual-Block-模式"><a href="#Visual-Block-模式" class="headerlink" title="Visual Block 模式"></a>Visual Block 模式</h2><p>按住 <code>ctrl + v</code>, 进入 <code>visual block</code>模式。此模式下，选中想要选中的内容（可以结合$^）。选中后，输入<code>I,i,A,a,C,c</code>等操作，输入想要输入的内容。再按下<code>Esc</code>键，即可全部行都有填入的内容。类似于 sublime。</p>
<p>注意 I，A，C 的区别，就跟他们原来的意思一样，比如I,A是插入，只是插入的地方可能不同。C是替换。</p>
<p>比如<code>Ctrl+v jj$</code>到每一行行末，再I，填入<code>;</code>，就可以几行一起填分好了。</p>
<p><strong>Visual Block 模式下，还可以做下面这些事情</strong>：</p>
<ul>
<li>可以结合<code>&lt;&gt;</code>进行移动。</li>
<li>使用<code>J</code>把选中的行连接起来变成 一行。</li>
<li>使用<code>=</code>自动给缩进。</li>
</ul>
<p>这些功能都很好用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里面的东西，有些大多我都用过，也知道。但是每次去用的时候有时候还要再去查下命令。怪不好的。总结下，以后忘记了就在博客里翻翻吧。开心。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两天做了一个很繁琐的需求，简单的来说，就是把一个产品配置的复杂的excel表，转入为json, 然后再用 javascript 脚本拼接为对应 php 页面可执行代码。繁琐的是配置多且杂，并且产品的归类excel 转换为的 json 并不可用。于
    
    </summary>
    
    
      <category term="工具/配置" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>记最新几个新的小知识点</title>
    <link href="http://sevencai.github.io/2018/03/08/%E8%AE%B0%E6%9C%80%E6%96%B0%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://sevencai.github.io/2018/03/08/记最新几个新的小知识点/</id>
    <published>2018-03-08T08:15:01.000Z</published>
    <updated>2018-03-08T08:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下最近零零散散学的几个知识点。</p>
<hr>
<h1 id="图片显示方式"><a href="#图片显示方式" class="headerlink" title="图片显示方式"></a>图片显示方式</h1><p>有的时候看到网络上有些图示由模糊变清晰，有些是一直清晰，但是会逐行显示（慢慢的展示全）， 是什么因素导致了他们的显示方式？</p>
<p>实际是图片在<strong>压缩的时候算法</strong>决定了它的显示方式。比如：<br>小波算法：先模糊然后清晰<br>离散余弦变换：清晰，逐行显示</p>
<p>前端可以准备多种样子或者分辨率的图片，当网络好或者网络不好，再或者不同的屏幕分辨率的图片。现在出来了一种新的方式：</p>
<p>HTML <code>&lt;picture&gt;</code>元素是一个容器，用来为其内部特定的 <code>&lt;img&gt;</code>元素提供多样的 <code>&lt;source&gt;</code> 元素。浏览器会根据当前页面（即图片所在的盒子的容器）的布局以及当前浏览的设备（比如普通的屏幕和高清屏幕）去从中选择最合适的资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">	&lt;source srcset=&quot;smaller.png&quot; media=&quot;(max-width:700px)&quot;&gt;&lt;/source&gt;</span><br><span class="line">	&lt;source srcset=&quot;bigger.png&quot; media=&quot;(max-width:1000px)&quot;&gt;&lt;/source&gt;</span><br><span class="line">	&lt;img srcset=&quot;default.png&quot; alt=&quot;美女&quot;&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然并不是每个浏览器都支持,在实验中。</p>
<hr>
<h1 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h1><ol>
<li>jpg,jpeg,以24位颜色存储单个位图，可压缩</li>
<li>png，可做透明图片，体积较大，需要清晰的显示颜色丰富的图片时用</li>
<li>gif，全透/全不透，不支持半透明</li>
<li>svg，矢量图，地图中用的多，体积小</li>
</ol>
<p>注意有的时候只把 尾缀比如.jpg更改为.png 不行，因为只是名称改了，实际上它本质没有更改。需要用工具转换。</p>
<hr>
<h1 id="播放器形式"><a href="#播放器形式" class="headerlink" title="播放器形式"></a>播放器形式</h1><p>【video播放器】<br>优点：不需要下载额外资源（如：flash播放器需要下载.swf辅助插件），控制简单有较为完整的api。<br>缺点：每个浏览器的外观都不一样，如果要统一需要自己写ui实现。</p>
<p>【flash播放器】<br>flash 播放器，兼容性比较好，只需要下载 flash player 即可使用。<br>缺点是必须要下载额外的 swf 才可以。</p>
<p>视频的外部资源可使用<strong> link 加载样式</strong>，这样可以被提前加载。让视频先运行。这是个小 hack。</p>
<hr>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p><strong>页面刷新的时候 sessionStorage (标准浏览器) 是仍然存在的，只有关闭的时候才不存在。同一个浏览器，不同的标签，也是不共享的。</strong></p>
<p>userData 是 IE 的先驱者。</p>
<p>cookie 所有浏览器基本都支持，大小限制不同浏览器也不同，会把数据带给服务器。</p>
<p>openDataBase 是类似于本地数据库这种形式。可以做的东西更多。</p>
<p>localStorage 的缺点是 IE9, IE10 不支持, 注意下 safari 读不到 chrome 的 localStorage。</p>
<p>localStorage 不能跨域，所以存储的时候是在 localStorage 下，按照域名存放的。</p>
<hr>
<h1 id="造成页面卡死的原因"><a href="#造成页面卡死的原因" class="headerlink" title="造成页面卡死的原因"></a>造成页面卡死的原因</h1><p>如果页面突然一直 loading 或者 卡死，可能有以下一些原因。</p>
<ol>
<li>死循环 (while 1 了 ？)</li>
<li>大文件占用资源 loading</li>
<li>频繁的读写本地资源</li>
</ol>
<hr>
<h1 id="页面的重绘和回流"><a href="#页面的重绘和回流" class="headerlink" title="页面的重绘和回流"></a>页面的重绘和回流</h1><p>回流一定触发重绘，但是重绘不一定触发回流。<br>DOM元素的添加、修改(内容)、删除(Reflow+Repaint)<br>仅修改DOM元素的字体颜色(只有Repaint、因为不需要调整布局)</p>
<p>如何判断是否重绘了呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome 开发者工具 =&gt;  settings ,more tools, rendering, Paint flashing即可, 看到绿色的部分即为发生了重绘的部分</span><br></pre></td></tr></table></figure></p>
<p>触发重绘可能有的情况：<br>1、改变字体<br>2、增加或移除样式表<br>3、内容变化，如用户在input框输入文字<br>4、激活css伪类，如:hover<br>5、脚本操作DOM<br>6、计算可见的宽高属性<br>7、设置style属性的值</p>
<hr>
<h1 id="git-常用命令总结"><a href="#git-常用命令总结" class="headerlink" title="git 常用命令总结"></a>git 常用命令总结</h1><p>我总结了已经好多次了，有些命令一段时间不用又会忘记。好记性不如烂笔头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br><span class="line">git log --graph</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard 版本（可省略写）</span><br><span class="line"></span><br><span class="line">// add 后放弃</span><br><span class="line">git checkout -- file</span><br><span class="line"></span><br><span class="line">// add -&gt; commit 后放弃</span><br><span class="line">git reset HEAD file</span><br><span class="line">git checkout --file</span><br><span class="line"></span><br><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">git checkout -b dev</span><br><span class="line">等同于</span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">git branch -d/-D dev</span><br><span class="line"></span><br><span class="line">git stash apply 恢复</span><br><span class="line">git stash drop 恢复后删除 stash</span><br><span class="line">git stash pop = git stash apply + git stash drop</span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line">git branch --set-upstream dev origin/dev</span><br><span class="line"></span><br><span class="line">git tag name 打标签</span><br><span class="line">git tag 显示所有 tag</span><br><span class="line">git tag -d v0.1 删除某个tag</span><br><span class="line">git push origin v1.0 推送某个标签</span><br><span class="line">git push origin --tags 一次推送所有 tag</span><br></pre></td></tr></table></figure>
<p><strong>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</strong></p>
<p>rebase merge 的使用法则。</p>
<blockquote>
<p>In general the way to get the best of both worlds is to rebase local changes you’ve made but haven’t shared yet before you push them in order to clean up your story, but never rebase anything you’ve pushed somewhere</p>
</blockquote>
<hr>
<h1 id="学习一段代码"><a href="#学习一段代码" class="headerlink" title="学习一段代码"></a>学习一段代码</h1><p>这是最近在慕课上看到的一段代码，没事没事看看别人的代码还是有点收获的，比较下自己觉得好的和自己觉得别人可能有所需要改进的。下面这些代码是一位老师写的，大概就是根据版本号来判断资源是不是需要缓存，如果版本号更新了，就去重新拉取资源，并且更新本地缓存。如果版本号没有更新，就直接用本地的缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">window.Xhrfactory = function() &#123;</span><br><span class="line">    this.init.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">window.Xhrfactory.prototype = &#123;</span><br><span class="line">    init: function() &#123;</span><br><span class="line">        this.xhr = this.create();</span><br><span class="line">    &#125;,</span><br><span class="line">    create: function() &#123;</span><br><span class="line">        var xhr = null;</span><br><span class="line">        if (window.XMLHttpRequest) &#123;</span><br><span class="line">            xhr = new XMLHttpRequest();</span><br><span class="line">        &#125; else if (window.ActiveXobject) &#123;</span><br><span class="line">            xhr = new ActiveXobject(&apos;Msml2.Xmlhttp&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            xhr = new ActiveXobject(&apos;Microsoft.Xmlhttp&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return xhr;</span><br><span class="line">    &#125;,</span><br><span class="line">    readystate: function(callback) &#123;</span><br><span class="line">        this.xhr.onreadystatechange = function() &#123;</span><br><span class="line">            if (this.readyState === 4 &amp;&amp; this.status === 200) &#123;</span><br><span class="line">                callback(this.responseText);</span><br><span class="line">                console.log(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    para: function(data) &#123;</span><br><span class="line">        var datastr = &apos;&apos;;</span><br><span class="line">        if (data &amp;&amp; Object.prototype.toString.call(data) === &quot;[object object]&quot;) &#123;</span><br><span class="line">            for (var i in data) &#123;</span><br><span class="line">                for (var i = 0; i &lt; lenght; i++) &#123;</span><br><span class="line">                    datastr += i + &apos;=&apos;</span><br><span class="line">                    data[i] + &apos;&amp;&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    get: function(url, data, callback) &#123;</span><br><span class="line"></span><br><span class="line">        this.readystate(callback);</span><br><span class="line">        var newurl = url;</span><br><span class="line">        var datastr = this.para(data);</span><br><span class="line">        newurl = url + &apos;?&apos; + datastr;</span><br><span class="line">        this.xhr.open(&apos;get&apos;, newurl, true);</span><br><span class="line">        this.xhr.send(null);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 后台程序的模板变量</span><br><span class="line">var localStorageSign = &apos;on&apos;;</span><br><span class="line">// 版本控制</span><br><span class="line">var resourceVersion = &apos;12312443243202&apos;;</span><br><span class="line"></span><br><span class="line">// 本地的Sdk主方法</span><br><span class="line">window.mLocalSdk = &#123;</span><br><span class="line"></span><br><span class="line">    resourceJavascriptList: [&#123;</span><br><span class="line">        id: &apos;1232131241&apos;,</span><br><span class="line">        url: &apos;/dest/js/lib/core.js&apos;,</span><br><span class="line">        type: &apos;javascript&apos;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        id: &apos;1232131242&apos;,</span><br><span class="line">        url: &apos;/dest/js/lib/log.js&apos;,</span><br><span class="line">        type: &apos;javascript&apos;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        id: &apos;1232131243&apos;,</span><br><span class="line">        url: &apos;/dest/js/lib/report.js&apos;,</span><br><span class="line">        type: &apos;javascript&apos;</span><br><span class="line">    &#125;],</span><br><span class="line"></span><br><span class="line">    needUpdate: (function() &#123;</span><br><span class="line">        return localStorage.getItem(&apos;resourceVersion&apos;) === resourceVersion;</span><br><span class="line">    &#125;)(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    isIE: (function() &#123;</span><br><span class="line">            var v = 3;</span><br><span class="line">            var div = document.createElement(&apos;div&apos;);</span><br><span class="line">            var all = div.getElementsByTagName(&apos;i&apos;);</span><br><span class="line">            while (</span><br><span class="line">                div.innerHTML = &apos;&lt;!-- [if gt IE&apos; + (++v) + &apos;]&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif] --&gt;&apos;, !all[0])</span><br><span class="line">                 &#123;</span><br><span class="line">                    if(v &gt; 11)&#123;return false&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            return v &gt; 3 ? v : false;</span><br><span class="line">        &#125;)(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    checkHedge: function() &#123;</span><br><span class="line">        var localStorageLength = localStorage.length;</span><br><span class="line">        var localStorageSize = 0;</span><br><span class="line">        for (var i = 0; i &lt; localStorageLength; i++) &#123;</span><br><span class="line">            var key = localStorage.key(i);</span><br><span class="line">            localStorageSize += localStorage.getItem(key).length;</span><br><span class="line">        &#125;</span><br><span class="line">        return localStorageSize;</span><br><span class="line">    &#125;,</span><br><span class="line">    saveSdk: function() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            localStorage.setItem(&apos;resourceVersion&apos;, resourceVersion);</span><br><span class="line">        &#125; catch (oException) &#123;</span><br><span class="line">            if (oException.name == &apos;QuotaExceededError&apos;) &#123;</span><br><span class="line">                localStorage.clear();</span><br><span class="line">                localStorage.setItem(&apos;resourceVersion&apos;, resourceVersion);</span><br><span class="line">            &#125;</span><br><span class="line">            alert(&apos;QuotaExceededError&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (var i = 0; i &lt; this.resourceJavascriptList.length; i++) &#123;</span><br><span class="line">            _self = this;</span><br><span class="line">            (function(i)&#123;</span><br><span class="line">                var scriptId = _self.resourceJavascriptList[i][&apos;id&apos;];</span><br><span class="line">                var xhr = new Xhrfactory();</span><br><span class="line">                xhr.get(_self.resourceJavascriptList[i][&apos;url&apos;], null, function(data) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        localStorage.setItem(scriptId, data);</span><br><span class="line">                    &#125; catch (oException) &#123;</span><br><span class="line">                        console.log(&apos;oException&apos;,oException);</span><br><span class="line">                        if (oException.name == &apos;QuotaExceededError&apos;) &#123;</span><br><span class="line">                            localStorage.clear();</span><br><span class="line">                            localStorage.setItem(scriptId, data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)(i);</span><br><span class="line">            // XXX addhtml 加载到页面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    startup: function() &#123;</span><br><span class="line">        // 满足一下条件</span><br><span class="line">        var _self = this;</span><br><span class="line">        if (localStorageSign === &apos;on&apos; &amp;&amp; !this.isIE &amp;&amp; window.localStorage) &#123;</span><br><span class="line"></span><br><span class="line">            if (this.needUpdate === true) &#123;</span><br><span class="line">                //不需要更新</span><br><span class="line">                return (function() &#123;</span><br><span class="line"></span><br><span class="line">                    for (var i = 0; i &lt; _self.resourceJavascriptList.length; i++) &#123;</span><br><span class="line">                        // 获取本地缓存列表 输入到html上</span><br><span class="line">                        var scriptId = _self.resourceJavascriptList[i][&apos;id&apos;];</span><br><span class="line">                        // 把我们的列表中的js文件 渲染到页面</span><br><span class="line"></span><br><span class="line">                        // 去读取本地文件</span><br><span class="line">                        window.mDomUtils.addJavascriptByInline(scriptId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 保存我们请求到的js文件</span><br><span class="line">                return (function() &#123;</span><br><span class="line">                    _self.saveSdk();</span><br><span class="line">                    for (var i = 0; i &lt; _self.resourceJavascriptList.length; i++) &#123;</span><br><span class="line">                        // 获取本地缓存列表 输入到html上</span><br><span class="line">                        var scriptId = _self.resourceJavascriptList[i][&apos;id&apos;];</span><br><span class="line">                        // 把我们的 列表中的js文件 渲染到页面</span><br><span class="line"></span><br><span class="line">                        // 去读取本地文件</span><br><span class="line">                        window.mDomUtils.addJavascriptByInline(scriptId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //***</span><br><span class="line">                // 把从网络获取到的javascript 输入到html上；</span><br><span class="line">                // save localstroage</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            return function() &#123;</span><br><span class="line">                alert(2);</span><br><span class="line">                    for (var i = 0; i &lt; resourceJavascriptList.length; i++) &#123;</span><br><span class="line">                        // 获取本地缓存列表 输入到html上</span><br><span class="line">                        var scriptId = resourceJavascriptList[i][&apos;scriptId&apos;];</span><br><span class="line">                        // 把我们的列表中的js文件 渲染到页面</span><br><span class="line"></span><br><span class="line">                        // 读取网络上得到的资源</span><br><span class="line">                        window.mDomUtils.addJavascriptByLink(scriptId, resourceJavascriptList[i][&apos;url&apos;]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //***</span><br><span class="line">                // 把从网络获取到的javascript 输入到html上；</span><br><span class="line">                // 原始方法加载javascriopt</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 写入本地localstorage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">window.mDomUtils = &#123;</span><br><span class="line">    // 内联方式添加javascript</span><br><span class="line">    addJavascriptByInline: function(scriptId) &#123;</span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">        script.id = scriptId;</span><br><span class="line">        var heads = document.getElementsByTagName(&apos;head&apos;);</span><br><span class="line">        if (heads.lenght) &#123;</span><br><span class="line">            heads[0].appendChild(script);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.documentElement.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">        script.innerHTML = localStorage.getItem(scriptId);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 外链方式添加javascript</span><br><span class="line">    addJavascriptByLink: function(scriptId, url) &#123;</span><br><span class="line">        var script = document.createElemet(&apos;script&apos;);</span><br><span class="line">        script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">        script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">        script.id = scriptId;</span><br><span class="line">        var heads = document.getElementsByTagName(&apos;head&apos;);</span><br><span class="line">        if (heads.length) &#123;</span><br><span class="line">            heads[0].appendChild(script);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.documentElement.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 外链方式添加css</span><br><span class="line"></span><br><span class="line">    addCssByLink: function(url) &#123;</span><br><span class="line">        var doc = document;</span><br><span class="line">        var link = doc.createElemet(&apos;link&apos;);</span><br><span class="line">        link.setAttribute(&apos;type&apos;, &apos;text/css&apos;);</span><br><span class="line">        link.setAttribute(&apos;rel&apos;, &apos;stylesheet&apos;);</span><br><span class="line">        link.setAttribute(&apos;href&apos;, url);</span><br><span class="line">        var heads = doc.getElementsByTagName(&apos;head&apos;);</span><br><span class="line">        if (heads.length) &#123;</span><br><span class="line">            heads[0].appendChild(link);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doc.documentElement.appendChild(link);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 外链方式添加css</span><br><span class="line"></span><br><span class="line">        addCssByLink: function(cssString) &#123;</span><br><span class="line">        var doc = document;</span><br><span class="line">        var link = doc.createElemet(&apos;link&apos;);</span><br><span class="line">        link.setAttribute(&apos;type&apos;, &apos;text/css&apos;);</span><br><span class="line">        link.setAttribute(&apos;rel&apos;, &apos;stylesheet&apos;);</span><br><span class="line"></span><br><span class="line">        if (link.stylesheet) &#123;</span><br><span class="line">            // IE支持</span><br><span class="line">            link.stylesheet.cssText = cssString;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // w3c</span><br><span class="line">            var cssText = doc.createTextNode(cssString);</span><br><span class="line">            link.appendChild(cssText);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var heads = doc.getElementsByTagName(&apos;head&apos;);</span><br><span class="line">        if (heads.length) &#123;</span><br><span class="line">            heads[0].appendChild(link);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doc.documentElement.appendChild(link);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>觉得比较好的，一个是它判断 IE 的方法，利用了只有 IE 可以识别的特性。另外一个是它判断 localStorage 缓存的大小。</p>
<p>还有一个是它利用了自执行函数来去做其实只用去初始化一次的工作。比如判断本地的缓存是否是需要跟新（根据版本号），而不是做成一个函数每次去执行一次。</p>
<p>不好的就是，可能是因为现场写代码，随机想的，所以有些地方可以封装，都没有封装好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下最近零零散散学的几个知识点。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;图片显示方式&quot;&gt;&lt;a href=&quot;#图片显示方式&quot; class=&quot;headerlink&quot; title=&quot;图片显示方式&quot;&gt;&lt;/a&gt;图片显示方式&lt;/h1&gt;&lt;p&gt;有的时候看到网络上有些图示由模糊变清晰，有些是一
    
    </summary>
    
    
      <category term="知识点" scheme="http://sevencai.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>小程序使用 component 组件重构</title>
    <link href="http://sevencai.github.io/2018/03/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8-component-%E7%BB%84%E4%BB%B6%E9%87%8D%E6%9E%84/"/>
    <id>http://sevencai.github.io/2018/03/05/小程序使用-component-组件重构/</id>
    <published>2018-03-05T13:40:58.000Z</published>
    <updated>2018-03-05T13:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>世界上没有一蹴而就的事情，任何事情，都有起源，发展和未来。如果你跟他就关，那就适应它，而不要抱怨它的变化，或者抱怨他为什么不一开始就这么做。</p>
</blockquote>
<hr>
<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p>小程序后来出了 component, 看了看自己的代码，还是最初的 template + class,心里好难受。 于是花了2天时间重构了。这段时间没有产品排期，也就是说我是拿别的项目的时间去重构的。时间略紧张，不过还是一点点的完成了。</p>
<p>component 相当于一个完整的组件，你可以对这个组件定义不同的内容。有自己的事件和 data, 这个倒是跟 vue 很像。</p>
<p>但是注意 component 中的 css 除了继承属性（h1,em）等以外，其他的样子必须都写入 component 中。如果你不想做这件事，就把 app.wxss 引入到 component 中吧。（虽然我也很不情愿）</p>
<hr>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>用 <code>Component({})</code>声明。内部可以有自己的 data, methods, behaviors,还有类似于 vue 的 attach, ready 等函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rechargeItem <span class="keyword">from</span> <span class="string">'behaviors/jump-to-order'</span></span><br><span class="line"></span><br><span class="line">Component(&#123;</span><br><span class="line">  behaviors: [rechargeItem],</span><br><span class="line"></span><br><span class="line">  properties: &#123;</span><br><span class="line">     recommendList: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      value: []</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">     bindClickEvent() &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>behaviors 可以理解为 mixins, 多个组件都可能用到同样的内容，就把它抽离为 behaviors 吧。 比如上面，调到订单页可以从很多 component 过来，比如 推荐，搜索。那么就抽离成一个 behavior, 用到的时候引入进来即可。</p>
<p>注意任何一个 component 都需要声明它是一个 component, 我猜测是要语义更好吧，免得跟 page 搞混了(但是 component 和 page 声明就不一样，其实没必要单独再在 json 中声明下？)。component 不需要再在 app.json 里面声明，因为它不是一个 page。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;component&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要引入这个组件的地方，这样引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;recommend&quot;: &quot;../page_component/recommend/recommend&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，直接引入即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;recommend recommendList=&quot;&#123;&#123;recommendList&#125;&#125;&quot;&gt;&lt;/recommend&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的 recommendList 类似于 vue 的 props, 可以用于从父组件（page）传递内容到子组件。</p>
<p>然后就再原先的 properties 中接受即可。也可以用 <code>this.data</code>访问到。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实是不想写这个文章的的，因为文章本身没有啥太大的意义，这些好好学习官网都可以知道的。但是不写的话总觉得自己这两天没干啥。但实际上，我觉得我自己做的事情有意义，因为代码更好了呀。而且可读性也更强了，是 component 的，template的，page的，api modules 的，都清清楚楚了。开心。</p>
<p>估计随后的一段时间都不会再碰小程序了，下次讲讲学习到的 vue 源码的内容吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界上没有一蹴而就的事情，任何事情，都有起源，发展和未来。如果你跟他就关，那就适应它，而不要抱怨它的变化，或者抱怨他为什么不一开始就这么做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; clas
    
    </summary>
    
    
      <category term="小程序" scheme="http://sevencai.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>函数立即表达式整理</title>
    <link href="http://sevencai.github.io/2018/02/27/%E5%87%BD%E6%95%B0%E7%AB%8B%E5%8D%B3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B4%E7%90%86/"/>
    <id>http://sevencai.github.io/2018/02/27/函数立即表达式整理/</id>
    <published>2018-02-27T14:09:32.000Z</published>
    <updated>2018-02-28T03:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文主要介绍的是 Javascript 的<strong>立即执行函数</strong>的比较与总结, 列举了现在大部分的立即执行函数的写法，并且分析了错误的原因和正确的原因。</p>
</blockquote>
<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>来看几种写法，你能分辨出来，哪个是正确的，哪个是错误的吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 写法1</span><br><span class="line">function a() &#123;</span><br><span class="line">	console.log(&quot;a&quot;)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">// 写法2</span><br><span class="line">(function b() &#123;</span><br><span class="line">	console.log(&quot;b&quot;)</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 写法3</span><br><span class="line">（function c() &#123;</span><br><span class="line">	console.log(&quot;c&quot;)</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 写法4</span><br><span class="line">var d = function d() &#123;</span><br><span class="line">	console.log(&quot;d&quot;)</span><br><span class="line">&#125;</span><br><span class="line">(d)()</span><br><span class="line"></span><br><span class="line">// 写法5</span><br><span class="line">var e = function e() &#123;</span><br><span class="line">	console.log(&quot;e&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">(e)()</span><br><span class="line"></span><br><span class="line">// 写法6</span><br><span class="line">!function f() &#123;</span><br><span class="line">	console.log(&quot;f&quot;)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">// 写法7</span><br><span class="line">+function g() &#123;</span><br><span class="line">	console.log(&quot;g&quot;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 写法8</span><br><span class="line">var h = function () &#123;</span><br><span class="line">	console.log(&quot;h&quot;)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">// 写法9</span><br><span class="line">(a === 1) &amp;&amp; function () &#123; /* ... */ &#125; ();</span><br><span class="line"></span><br><span class="line">// 写法 10</span><br><span class="line">1, function () &#123; /* ... */ &#125;();</span><br><span class="line"></span><br><span class="line">// 写法 11</span><br><span class="line">function （）&#123;</span><br><span class="line">	console.log(&quot;a&quot;)</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">// 写法 12</span><br><span class="line">function j() &#123;</span><br><span class="line">	console.log(&quot;j&quot;)</span><br><span class="line">&#125;(1)</span><br></pre></td></tr></table></figure></p>
<p>上面的写法中，有几种是错误❌的，你找出来了吗？</p>
<hr>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先基本知识是，声明  javascript 的函数有两种方式，分别是语句（函数声明）的形式和表达式的形式，其中语句的形式是有变量提升的说法的，而表达式不会：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 表达式</span><br><span class="line">var f = function f() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对于 Javscript 引擎而言， 如果 <code>function</code> 关键字出现在行首，会被解析成函数声明的形式。函数声明必须包括 ： 关键词 function, 函数名，形参，函数体。</strong></p>
<p>第一种（写法1）❌，因为直接开头出现 function 关键字， 有函数名，浏览器会认为这是函数声明，下面是函数的定义，但是它又是以圆括号结尾，所以就报错了。</p>
<p>实际上写法1等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line">()</span><br></pre></td></tr></table></figure></p>
<p>这个空的<code>()</code>里面没有操作符，所以报了相应的错。<br>报错的内容是<code>Uncaught SyntaxError: Unexpected token )</code>。</p>
<p>而第11种（写法11），浏览器也认为是函数声明的形式，<strong>但是却没有找到函数名</strong>，所以也是错误❌的。报错是：<code>VM143:1 Uncaught SyntaxError: Unexpected token (</code> 。所以说这两种类似，但是报错的原因并不相同。</p>
<p>对于写法12， 实际上等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function j() &#123;</span><br><span class="line">	console.log(&quot;j&quot;)</span><br><span class="line">&#125;</span><br><span class="line">(1)</span><br></pre></td></tr></table></figure></p>
<p><strong>所以实际上，它不会报错，因为<code>()</code>有操作符，但是 j 函数也不会被执行， 最后返回的是 1， 因为只有 (1) 执行了。</strong></p>
<p>那么，为什么2，3写法是正确✅的呢？<strong>因为当浏览器解析碰到了<code>()</code>时，<code>()</code>里面不能包含函数声明，所以浏览器会把这个解析成函数表达式。当它是函数表达式的时候，自然就立即执行了。并且也不会报错。</strong></p>
<p>因此下面两种都是正确的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; /* ... */ &#125;());</span><br><span class="line">(function()&#123; /* ... */ &#125;)();</span><br></pre></td></tr></table></figure></p>
<p>所以如果我们要让它可以被浏览器识别，那么就让浏览器知道它是一个表达式吧。 因此6，7，9，10他们都是正确的。9,10这两种写法，前面一个是表达式，浏览器自然也认为后面一个也是表达式。</p>
<p>这种称为<strong>“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</strong> 然而实际中，<strong>我们通常会叫立即执行函数。</strong></p>
<p>但是注意立即调用的函数表达式后面一定要是有分号，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!function () &#123; /* ... */ &#125;();</span><br><span class="line">~function () &#123; /* ... */ &#125;();</span><br><span class="line">-function () &#123; /* ... */ &#125;();</span><br><span class="line">+function () &#123; /* ... */ &#125;();</span><br></pre></td></tr></table></figure></p>
<p>如果没有分号，浏览器又会错误的识别了。认为第二行是第一行的参数。所以写法4正确，写法5错误❌， 这个一定要注意了。</p>
<hr>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>立即执行函数的作用，最常见的是配合闭包的使用，来保存函数局部状态。因为立即执行函数也能够传参数。所以有了最经典的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(&quot;i&quot;,i)</span><br><span class="line">	 &#125;,0)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以分别打印出 i 从 1-5， 但是如果你像下面这样写，就会打印出5个5了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">     console.log(&quot;i&quot;,i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更为经典的一个例子如下, 你想要对每个 a 元素都绑定一个不同的事件，这里 log 出 i 的值。但是却得不到你想要的结果，因为在我们执行点击事件的时候， i 已经被执行完，为5了。所以对于 a0, a1,a2,a3都没有被绑定相应的事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var elems = document.getElementsByTagName( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">for ( var i = 0; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">  elems[i].addEventListener( &apos;click&apos;, function(e)&#123;</span><br><span class="line">    console.log( &apos;i,&apos; + i );</span><br><span class="line">  &#125;, &apos;false&apos; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们用立即执行函数和闭包来改写下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var elems = document.getElementsByTagName( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; eles.length; i++) &#123;</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    elems[i].addEventListener( &apos;click&apos;, function(e)&#123;</span><br><span class="line">      console.log( &apos;i,&apos; + i );</span><br><span class="line">    &#125;, &apos;false&apos; );</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就 ok 了。注意 i 一定要在外部括号和里面的括号都传递进去，否则 i 不会被锁住。</p>
<p>立即执行函数当然还有别的好处，经常见的就是<strong>减少全局变量的定义</strong>，比如 jquery 的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function( $ ) &#123;</span><br><span class="line">  $.fn.myPlugin = function() &#123;</span><br><span class="line">	var a = 1;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)( jQuery );</span><br></pre></td></tr></table></figure></p>
<p>这样减少了全局变量，每个插件自己用自己的变量，以防止冲突。性能也会好些。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要是以前其实这些知识点都是知道的，但是没有系统的总结或者思考过，这次算是有个稍微整体一点的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要介绍的是 Javascript 的&lt;strong&gt;立即执行函数&lt;/strong&gt;的比较与总结, 列举了现在大部分的立即执行函数的写法，并且分析了错误的原因和正确的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;问题&quot;&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://sevencai.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>GBK, GB2312, UTF-8, Unicode,encodeURI, escape的区别和联系</title>
    <link href="http://sevencai.github.io/2018/02/27/GBK-GB2312-UTF-8-Unicode-encodeURI-escape%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://sevencai.github.io/2018/02/27/GBK-GB2312-UTF-8-Unicode-encodeURI-escape的区别和联系/</id>
    <published>2018-02-27T04:00:04.000Z</published>
    <updated>2018-02-28T03:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇目的主要是搞清楚UTF-8, GBK,  Unicode, ASCII码，Unicode, escape, encodeURIComponent, encodeURI 编码等等的区别和联系。</p>
</blockquote>
<hr>
<h1 id="文章起源"><a href="#文章起源" class="headerlink" title="文章起源"></a>文章起源</h1><p>事情起源是，今天在做小程序的时候，发现我请求业务接口时，业务接口返回的是gbk编码。</p>
<p>然后这个在小程序中不支持，会返回内容如：<code>fail response data convert to UTF8 fail</code>, 在  pc 端及 android 端表现正常，但是在 ios 下会返回此错误码。</p>
<p>于是很不好意思的找到了业务方的同事，看能不能把返回的内容变成标准的 utf8 无 bom编码格式。话说，我遇到的这个同事真的好 nice, 以前跨部门的合作没有1-2天下不来，这个同事效率比较高，每次有问题找到他，都能够很快的反馈给我（感恩）。然后他就跟我说了下面这样一句话：</p>
<blockquote>
<p>你请求参数用gbk编码  我返回给你utf8你看如何？</p>
</blockquote>
<p>大概是都统一用 utf8 对于他改动比较大，于是他提出我请求的时候用 gbk 编码。于是我把这段话错误理解为了：</p>
<blockquote>
<p>你请求的时候，用 gbk 编码请求，我返回给你 utf8。</p>
</blockquote>
<p>也就是说我会在请求 header 里加入 <code>charset=gbk</code>, 他返回给我 utf8 编码内容就好。</p>
<p>但实际上同事这句话的意思是：</p>
<blockquote>
<p>把调用他接口的<strong>请求参数</strong>用gbk编码，而不是在请求头里加 header。我掉了参数两个字。</p>
</blockquote>
<p>因为我们组内的前端统一用的都是 utf8, 编码都是用 encodeURI, encodeURIComponent,  以前也没有用过把参数做 gbk 编码的这种方式，导致了我认为是在请求头里请求用 gbk。 并且对 encodeURI 等等的不深入了解，导致了我浪费了同事的时间。 encodeURI, encodeURIComponent 都是针对 utf-8 的编码， 不能够指定编码方式。 gbk 编码在 github 上有这种成熟的 npm。</p>
<p>大概的思路是,如果是 ASCII 码，直接 encode， 判断不是 ASCII 码后，再进行 GBK 的比对编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const encodeUrlGbk = (str) =\&gt; &#123;</span><br><span class="line">    return str &amp;&amp; str.replace(/./g,function (a) &#123;</span><br><span class="line">         var code = a.charCodeAt(0);</span><br><span class="line">         if (_isAscii(code)) &#123;</span><br><span class="line">            return encodeURIComponent(a);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            var key = code.toString(16);</span><br><span class="line">         if (key.length !== 4) &#123;</span><br><span class="line">            key = (&apos;000&apos; \+ key).match(/....$/)\[0\];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return _charHash.U2Ghash\[key\] || a;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然问题解决了，但是发现了自己对这块是不是根本没有弄清楚，今天仔细的查了资料，从新学习和认识下，想把这些内容都了解并且比较清楚。</p>
<hr>
<h1 id="escape-encodeURIComponent-encodeURI-的区别和联系"><a href="#escape-encodeURIComponent-encodeURI-的区别和联系" class="headerlink" title="escape, encodeURIComponent, encodeURI 的区别和联系"></a>escape, encodeURIComponent, encodeURI 的区别和联系</h1><p>如果你想直接看结论，可以跳过下部分引用内容。</p>
<blockquote>
<p>escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。</p>
</blockquote>
<p>该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。他的解码为 unescape。</p>
<p><strong>ECMAScript v3 反对使用该方法</strong>，应用使用 decodeURI() 和 decodeURIComponent() 替代它。</p>
<blockquote>
<p>encodeURI() 函数可把字符串作为 URI 进行编码。</p>
</blockquote>
<p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p>
<p>该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#</p>
<p><strong>如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。</strong></p>
<blockquote>
<p>encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。</p>
</blockquote>
<p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。（这点与 encodeURI 相同）</p>
<p>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 （这点与 encodeURIComponent 不同）</p>
<p>关于这三个函数总结下如下：</p>
<p><strong>如果是跟url编码有关系的，先忘掉 escape 这个函数，他跟 url 编码毫无关系，它只是能够达到类似于 URL Encode 这类似的效果，但是它对于非 ASCII 字符使用了一种非标准的实现，比如某些汉字会被编码成 %uxxxx 这种形式， 在小程序中，url使用 escape, 会报错： fail request:fail _invalid url 这类似的消息。并且 W3C 把这个函数废弃了，能不使用尽量不要去使用 </strong></p>
<p><strong>对于 url 的编码，就使用 encodeURI 及 encodeURIComponent, 他们都是为了 url 编码而设计，不同的地方在于 encodeURI 用于对完整的 url 进行编码，于是URL中的功能字符，比如&amp;, ?, /, =等等这些并不会被转义， 而 encodeURIComponent 被设计用来对某段 query（某个值） 编码。所以正确用法是 encodeURIComponent 经常用于对每个 key value 进行分别编码。</strong></p>
<hr>
<h1 id="延伸阅读-escape-encodeURI的编码方式-百分号编码"><a href="#延伸阅读-escape-encodeURI的编码方式-百分号编码" class="headerlink" title="延伸阅读-escape, encodeURI的编码方式-百分号编码"></a>延伸阅读-escape, encodeURI的编码方式-百分号编码</h1><blockquote>
<p><strong>百分号编码</strong>（英语：Percent-encoding）, 也称作URL编码（英语：URL encoding）, 是特定上下文的统一资源定位符 (URL)的编码机制. 实际上也适用于统一资源标志符（URI）的编码。也用于为”application/x-www-form-urlencoded” MIME准备数据, 因为它用于通过HTTP的请求操作(request)提交HTML表单数据。</p>
</blockquote>
<p>对于 escape 以及 encodeURI 都是属于 <code>percent-encoding</code>。差不多都是把 URI 非法字符转化为合法字符， 转化以后有 <code>%</code>, 所以我猜才叫 percent-encoding 吧，哈哈。</p>
<p>首先 escape 和 encodeURI 在处理 0xff 以内的内容时，都是相同的。也就是说是 %xx,  这里的 xx 是字符的 16进制 unicode (此时的 unicode === utf8值， 所以 escape 的值也等于 encodeURI 的值)。</p>
<p><strong>但 escape 在处理 0xff 之外的时候， 直接使用字符的 unicode , 并且在前面再加上一个 <code>%u</code>（不标准） , 而 encodeURI 是先对 unicode 进行 utf-8 编码，再在每个 utf-8 编码前加上 %（标准）。</strong></p>
<p>比如中文的【我】字， 他的 unicode 为 0x6211,  对他进行 utf8 编码变成了 0xe6, 0x88, 0x91, 因此 escape 得到的值为 <code>\u6211</code>, 但是encodeURI 的结果是 <code>%E6%88%91</code>。</p>
<p>对 escape, encodeURI 这些其实以前是了解的， 但是这次是真正的总结清楚了，挺开心。上面是不是提到了很多比如 utf8, gbk, unicode 之类的词。 下面对这些名词也做一些简单的归类和总结。</p>
<hr>
<h1 id="UTF-8-Unicode-ASCII码的区别和联系"><a href="#UTF-8-Unicode-ASCII码的区别和联系" class="headerlink" title="UTF-8, Unicode, ASCII码的区别和联系"></a>UTF-8, Unicode, ASCII码的区别和联系</h1><blockquote>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于<a href="https://baike.baidu.com/item/%E6%8B%89%E4%B8%81%E5%AD%97%E6%AF%8D" target="_blank" rel="noopener">拉丁字母</a>的一套电脑编码系统，主要用于显示现代<a href="https://baike.baidu.com/item/%E8%8B%B1%E8%AF%AD/109997" target="_blank" rel="noopener">英语</a>和其他<a href="https://baike.baidu.com/item/%E8%A5%BF%E6%AC%A7" target="_blank" rel="noopener">西欧</a>语言。它是现今最通用的单<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">编码</a>系统，并等同于<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85" target="_blank" rel="noopener">国际</a>标准ISO/IEC 646。</p>
</blockquote>
<p> 注意 ASCII 码是 <code>American Standard Code for Information Interchange</code>的简称， 后面的两个II 并不是罗马数字2哦。</p>
<p>我们知道计算机里面存储所有信息都是通过一个二进制值。每一个二进制位（bit）都有两种状态 0或者1， 规定了8个二进制位为一个字节（byte），可以表示256种状态，包括了 <code>00000000</code> 到 <code>11111111</code> 。</p>
<p>美国🇺🇸人们自然想到了可以他们自己规定一套字符编码，把26英文字母，及一些特殊符号和控制字符统一编码。他们一共规定了 128个字符，比如说 A 是 65（01000001）。128位只需要占用7位，最高位统一为0。</p>
<blockquote>
<p>比如遇到0x10 就是换行， 遇到 Ox1b 就打印反白字。这类0x20以下的字节称为控制字节。空格，标点符号，数字，大小写字母用连续的字节状态表示，一直到127号。</p>
</blockquote>
<p>所以 ASCII码就是0-127这套编码方案所形成的编码，这套编码方案叫做ANSI。</p>
<p>下面给出两种判断字符是不是 ASCII 码的方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isASCII (unicode) &#123;</span><br><span class="line">    return ((unicode === 0x20AC) || (unicode &lt;= 0x007F &amp;&amp; unicode &gt;= 0x0000));</span><br><span class="line">&#125;</span><br><span class="line">// 另外一种用正则判断</span><br><span class="line">isASCII(str) &#123;</span><br><span class="line">    return /^\[\\x00-\\x7F\]*$/.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是问题来了，英语用128个编码就足够了，但是其他语言用这些字符是远远不够的，于是延伸出了256编码，也就是最高位也被使用上(<strong>这称为扩展字符集</strong>)。但是不同的国家有不同的字母，同样的编码可能也代表着不同的内容。比如 150，可能法国是一个，俄语又是一个。他们0-127都是相同，但是128-256不一定相同了，这就看不同的国家自己的制定方式了。</p>
<p>但是再想想中国🇨🇳就更可怕了，一共有10几万的文字。显然256种符号是没有办法完全表达的。于是又出现了多字节的形式。比如两个字节，做多表示 256*256 种。大概又6w多符号。最常见的中文编码就是这种2个字节的编码方式，如 GB2312。</p>
<p>下面就介绍下 GB2312, GBK等的区别和联系。</p>
<hr>
<h1 id="GB2312-GBK-GB18030的区别和联系"><a href="#GB2312-GBK-GB18030的区别和联系" class="headerlink" title="GB2312,GBK,GB18030的区别和联系"></a>GB2312,GBK,GB18030的区别和联系</h1><p>中国用到计算机比较晚，那个时候 256个符号已经没有可以用来表达中文文字的了。并且中文10w+个，只能够另辟蹊径了。于是中国人把127号之后的字符都去掉了，并且进行了规定。</p>
<blockquote>
<p>每个汉字及符号以两个字节表示。第一个为高字节，第二个为低字节。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE。</p>
</blockquote>
<p>具体这个字符范围的得来，涉及区位等知识，这些我不打算认识，不做介绍。</p>
<p>这种方案称之为GB2312, 他是对ASCII码的中文扩展。这样就 6000+汉字可以得到表示。</p>
<blockquote>
<p>GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。 GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312不能处理，因此后来GBK及GB 18030汉字字符集相继出现以解决这些问题。–wiki</p>
</blockquote>
<p>后来GB2312这种方案还是不够用，于是就不再要求低字节一定是127之后的内码， 只要是第一个字节大于127，就表示这是汉字的开始，不用管低字节是否是扩展字符集的内容。这种GB2312被扩展之后的内容称之为 GBK， GBK 包括了GB2312的所有内容，并且新增加了20000个汉字。</p>
<p>后来少数民族也需要用电脑，于是又增加了少数名族的内容，GBK 被扩展为了 GB18030。</p>
<p><strong>也就是说 GB18030 &gt; GBK &gt; GB2312。 这一系列的中文编码，称为 DBCS(Double Byte Character Set 双字节字符集)。</strong></p>
<blockquote>
<p>在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。–wiki</p>
</blockquote>
<p>于是就出现了后来编程时候的默念： <strong>一个中文字符占两个字节，1个英文字符占用1个字节</strong>。</p>
<p>注意这个时候 GBK, GB2312 等，只是中文对于ASCII码的扩展，和 UTF8,Unicode 这些并无联系。下面再来看看 Unicode 及 UTF-8。</p>
<hr>
<h1 id="Unicode-及-UTF-8"><a href="#Unicode-及-UTF-8" class="headerlink" title="Unicode 及 UTF-8"></a>Unicode 及 UTF-8</h1><blockquote>
<p>结论： UTF-8 是 Unicode 的实现方式之一。</p>
</blockquote>
<p>前面我们说过，世界上存在着很多编码方式，每个国家可能会去规定和制作自己的编码方式。不同的二进制因而有可能会被解释成不同的内容。 因此如果你不知道一个文件的编码，然后随意用编辑器打开了就会出现我们经常出现的乱码现象。</p>
<p>聪明的人们当然意识到了这一点，所以如果有一种编码方式能够把世界所有的符号都纳入其中，那该多好？ 再也不会有乱码现象了。</p>
<p>于是 Unicode 出现了（union code ？） , <strong>一定要注意 Unicode 并不是一个编码方式，不是一个算法，而是一个集合，集合了所有的符号，它只是规定了所有符号的二进制代码，并没有一个算法来说怎么存储这个内容。比如<code>U+0041</code>表示大写字母A。</strong>  （其实我在想，它能把所有符号录入进去，已经是很大的工作量了。）</p>
<blockquote>
<p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。    —- 引用自<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">阮一峰的文章</a></p>
</blockquote>
<p>后来的人们也进行了很多尝试， 发明了 unicode 的多种存储方式（不同的二进制编码方式或者称之为一种算法）。<strong>直到 UTF-8 这种编码方式的出现， Unicode 才得以推广。 所以前面才说 UTF-8 是一种是Unicode的实现方式。</strong></p>
<blockquote>
<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的<strong>可变长度字符编码</strong>，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码。</p>
</blockquote>
<p><strong>关键字是可变长度字符编码，也就是说对于不同类型的符号，它占用的字节长度不一样。这样可以节省很多空间。并且比较灵活。一般情况下，它使用1-4个字节来表示。</strong>比如：</p>
<blockquote>
<p>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</p>
<p>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</p>
<p>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</p>
<p>其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。 –wiki</p>
</blockquote>
<p><strong>utf-8的具体编码实现，我引用了阮一峰老师的文章的部分内容，他总是能把复杂的东西讲的很简单。</strong> 地址为：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">ascii_unicode_and_utf</a></p>
<p>(<strong>以下内容为引用内容</strong>)</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母<code>x</code>表示可用编码的位。</p>
<blockquote>
<p>Unicode符号范围     |        UTF-8编码方式<br>(十六进制)        |              （二进制）<br>———————-+———————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
</blockquote>
<p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好开心，大概的把这些东西都有了一些了解。不再只是停留在认识阶段，而是了解阶段了。算是对这两天的一个交代了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇目的主要是搞清楚UTF-8, GBK,  Unicode, ASCII码，Unicode, escape, encodeURIComponent, encodeURI 编码等等的区别和联系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设置我的 eslint 配置</title>
    <link href="http://sevencai.github.io/2018/01/23/%E8%AE%BE%E7%BD%AE%E6%88%91%E7%9A%84-eslint-%E9%85%8D%E7%BD%AE/"/>
    <id>http://sevencai.github.io/2018/01/23/设置我的-eslint-配置/</id>
    <published>2018-01-23T09:16:21.000Z</published>
    <updated>2018-01-23T09:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇主要记录了我针对自己的习惯，对 eslint 的一些配置的更改。我一般用的是 <a href="https://github.com/airbnb/javascrip" target="_blank" rel="noopener">Airbnb</a> 的编码规范。</p>
</blockquote>
<p>最开始我会自己去配置 webpack 的相关插件等。后来发现中间去使用的成本太高了，往往配置就花费了我不少时间，现在我主要是使用一些比较成熟的 cli, 比如 vue-cli, react-cli 等。下面的这份 eslint 继承自 <code>airbnb-base</code>, 覆盖了一些我不习惯使用的配置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://eslint.org/docs/user-guide/configuring</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">'babel-eslint'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.</span></span><br><span class="line">  extends: [<span class="string">'plugin:vue/essential'</span>, <span class="string">'airbnb-base'</span>],</span><br><span class="line">  <span class="comment">// required to lint *.vue files</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'vue'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// check if imports actually resolve</span></span><br><span class="line">  settings: &#123;</span><br><span class="line">    <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">      webpack: &#123;</span><br><span class="line">        config: <span class="string">'build/webpack.base.conf.js'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="comment">// don't require .vue extension when importing</span></span><br><span class="line">    <span class="string">'import/extensions'</span>: [<span class="string">'error'</span>, <span class="string">'always'</span>, &#123;</span><br><span class="line">      js: <span class="string">'never'</span>,</span><br><span class="line">      vue: <span class="string">'never'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// disallow reassignment of function parameters</span></span><br><span class="line">    <span class="comment">// disallow parameter object manipulation except for specific exclusions</span></span><br><span class="line">    <span class="string">'no-param-reassign'</span>: [<span class="string">'error'</span>, &#123;</span><br><span class="line">      props: <span class="literal">true</span>,</span><br><span class="line">      ignorePropertyModificationsFor: [</span><br><span class="line">        <span class="string">'vm'</span>,</span><br><span class="line">        <span class="string">'state'</span>, <span class="comment">// for vuex state</span></span><br><span class="line">        <span class="string">'acc'</span>, <span class="comment">// for reduce accumulators</span></span><br><span class="line">        <span class="string">'e'</span> <span class="comment">// for e.returnvalue</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// allow optionalDependencies</span></span><br><span class="line">    <span class="string">'import/no-extraneous-dependencies'</span>: [<span class="string">'error'</span>, &#123;</span><br><span class="line">      optionalDependencies: [<span class="string">'test/unit/index.js'</span>]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// 禁止分号 auto</span></span><br><span class="line">    <span class="string">'semi'</span>: [</span><br><span class="line">      <span class="string">'error'</span>,</span><br><span class="line">      <span class="string">'never'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 禁止使用拖尾逗号</span></span><br><span class="line">    <span class="string">'comma-dangle'</span>: [</span><br><span class="line">      <span class="string">'error'</span>,</span><br><span class="line">      <span class="string">'never'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 箭头函数的括号，只在有多个参数时才使用</span></span><br><span class="line">    <span class="string">'arrow-parens'</span>: [</span><br><span class="line">      <span class="string">'error'</span>,</span><br><span class="line">      <span class="string">'as-needed'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'arrow-body-style'</span>: [</span><br><span class="line">      <span class="string">'error'</span>,</span><br><span class="line">      <span class="string">'always'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 允许我使用 表达式</span></span><br><span class="line">    <span class="string">'no-unused-expressions'</span>: [<span class="string">'error'</span>, &#123; <span class="string">'allowShortCircuit'</span>: <span class="literal">true</span>, <span class="string">'allowTernary'</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="comment">// 放宽最大的支持宽度</span></span><br><span class="line">    <span class="string">'max-len'</span>: [<span class="number">2</span>, <span class="number">150</span>, <span class="number">4</span>, &#123; <span class="string">'ignoreUrls'</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="comment">// allow debugger during development</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这上面因为是已经继承自 <code>airbnb-base</code> ,所以很多默认的配置都没有写下来，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制单引号 auto</span></span><br><span class="line"><span class="string">"quotes"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"single"</span></span><br><span class="line">],</span><br><span class="line"> <span class="comment">// 变量定义或参数声明未使用</span></span><br><span class="line"><span class="string">"no-cond-assign"</span>: [</span><br><span class="line">    <span class="string">"warn"</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 关键字空格 auto</span></span><br><span class="line"><span class="string">"keyword-spacing"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"before"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 强制单行代码块中使用空格 auto</span></span><br><span class="line"><span class="string">"block-spacing"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"always"</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 逗号前面不能由空格, 后面要空格 auto</span></span><br><span class="line"><span class="string">"comma-spacing"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"before"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 冒号前面不能有空格, 后面必须有空格, 键值需水平对齐 auto</span></span><br><span class="line"><span class="string">"key-spacing"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"beforeColon"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"afterColon"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"align"</span>: <span class="string">"value"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 参数未使用提示</span></span><br><span class="line"><span class="string">"no-unused-vars"</span>: [</span><br><span class="line">    <span class="string">"warn"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"var"</span>: <span class="string">"all"</span>,</span><br><span class="line">        <span class="string">"all"</span>: <span class="string">"all"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"> <span class="comment">// 函数左括号左边不能有空格 auto</span></span><br><span class="line"><span class="string">"space-before-function-paren"</span>: [</span><br><span class="line">    <span class="string">"error"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"anonymous"</span>: <span class="string">"always"</span>,</span><br><span class="line">        <span class="string">"named"</span>: <span class="string">"never"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<p>对了，顺便记录一个 vue-cli 配置的问题（不值得开一个新文章，但是想记录下）。</p>
<p>有的时候，如果我们配置了 host , 在本地访问是也许会出现 invalid host 之类的错误，正常访问不了页面，这个时候只需要找到 devServer, 增加一个 <code>disableHostCheck: true</code> 即可。让它不去检测 host, 等到正式上线，再把这个去掉或者更改为 false 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    disableHostCheck: true,</span><br><span class="line">    clientLogLevel: &apos;warning&apos;,</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      rewrites: [</span><br><span class="line">        &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, &apos;index.shtml&apos;) &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<hr>
<p>在项目中使用 eslint 当然是好处多多，规范自己的代码，心情也会好很多。下面是我记录的一些对 airbnb ，自己老是会忘记的几个点。</p>
<h3 id="No-Object-assign"><a href="#No-Object-assign" class="headerlink" title="No Object.assign"></a>No Object.assign</h3><p>Prefer the object spread operator over Object.assign to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// very bad</span><br><span class="line">const original = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">const copy = Object.assign(original, &#123; c: 3 &#125;); // this mutates `original` ಠ_ಠ</span><br><span class="line">delete copy.a; // so does this</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const original = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const original = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line"></span><br><span class="line">const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Use-array-spreads-…-to-copy-arrays"><a href="#Use-array-spreads-…-to-copy-arrays" class="headerlink" title="Use array spreads … to copy arrays."></a>Use array spreads … to copy arrays.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line">let i;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; len; i += 1) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const itemsCopy = [...items];</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="To-convert-an-array-like-object-to-an-array-use-spreads-…-instead-of-Array-from"><a href="#To-convert-an-array-like-object-to-an-array-use-spreads-…-instead-of-Array-from" class="headerlink" title="To convert an array-like object to an array, use spreads … instead of Array.from."></a>To convert an array-like object to an array, use spreads … instead of Array.from.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> nodes = [...foo];</span><br></pre></td></tr></table></figure>
<p>Use Array.from instead of spread … for mapping over iterables, because it avoids creating an intermediate array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const baz = [...foo].map(bar);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const baz = Array.from(foo, bar);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Use-object-destructuring-when-accessing-and-using-multiple-properties-of-an-object-eslint-prefer-destructuring-jscs-requireObjectDestructuring"><a href="#Use-object-destructuring-when-accessing-and-using-multiple-properties-of-an-object-eslint-prefer-destructuring-jscs-requireObjectDestructuring" class="headerlink" title="Use object destructuring when accessing and using multiple properties of an object. eslint: prefer-destructuring jscs: requireObjectDestructuring"></a>Use object destructuring when accessing and using multiple properties of an object. eslint: prefer-destructuring jscs: requireObjectDestructuring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function getFullName(user) &#123;</span><br><span class="line">  const firstName = user.firstName;</span><br><span class="line">  const lastName = user.lastName;</span><br><span class="line"></span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function getFullName(user) &#123;</span><br><span class="line">  const &#123; firstName, lastName &#125; = user;</span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">function getFullName(&#123; firstName, lastName &#125;) &#123;</span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Use-array-destructuring-eslint-prefer-destructuring-jscs-requireArrayDestructuring"><a href="#Use-array-destructuring-eslint-prefer-destructuring-jscs-requireArrayDestructuring" class="headerlink" title="Use array destructuring. eslint: prefer-destructuring jscs: requireArrayDestructuring"></a>Use array destructuring. eslint: prefer-destructuring jscs: requireArrayDestructuring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">const first = arr[0];</span><br><span class="line">const second = arr[1];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const [first, second] = arr;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Never-use-arguments-opt-to-use-rest-syntax-…-instead-eslint-prefer-rest-params"><a href="#Never-use-arguments-opt-to-use-rest-syntax-…-instead-eslint-prefer-rest-params" class="headerlink" title="Never use arguments, opt to use rest syntax … instead. eslint: prefer-rest-params"></a>Never use arguments, opt to use rest syntax … instead. eslint: prefer-rest-params</h3><p>自己老是用第一种方法，哈哈，第二种多好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">function concatenateAll() &#123;</span><br><span class="line">  const args = Array.prototype.slice.call(arguments);</span><br><span class="line">  return args.join(&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">function concatenateAll(...args) &#123;</span><br><span class="line">  return args.join(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Why-Modules-are-the-future-let’s-start-using-the-future-now"><a href="#Why-Modules-are-the-future-let’s-start-using-the-future-now" class="headerlink" title="Why? Modules are the future, let’s start using the future now."></a>Why? Modules are the future, let’s start using the future now.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const AirbnbStyleGuide = require(&apos;./AirbnbStyleGuide&apos;);</span><br><span class="line">module.exports = AirbnbStyleGuide.es6;</span><br><span class="line"></span><br><span class="line">// ok</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default AirbnbStyleGuide.es6;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line">export default es6;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Do-not-use-wildcard-imports"><a href="#Do-not-use-wildcard-imports" class="headerlink" title="Do not use wildcard imports."></a>Do not use wildcard imports.</h3><p>有的时候我还是会用到 * 的，因为也许里面的内容如果我都需要使用到呢。<br>Why? This makes sure you have a single default export.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">import * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;</span><br></pre></td></tr></table></figure></p>
<p> In modules with a single export, prefer default export over named export. eslint: import/prefer-default-export</p>
<p>Why? To encourage more files that only ever export one thing, which is better for readability and maintainability.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">export function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">export default function foo() &#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Multiline-imports-should-be-indented-just-like-multiline-array-and-object-literals"><a href="#Multiline-imports-should-be-indented-just-like-multiline-array-and-object-literals" class="headerlink" title="Multiline imports should be indented just like multiline array and object literals."></a>Multiline imports should be indented just like multiline array and object literals.</h3><p>Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">import &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from &apos;path&apos;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import &#123;</span><br><span class="line">  longNameA,</span><br><span class="line">  longNameB,</span><br><span class="line">  longNameC,</span><br><span class="line">  longNameD,</span><br><span class="line">  longNameE,</span><br><span class="line">&#125; from &apos;path&apos;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇主要记录了我针对自己的习惯，对 eslint 的一些配置的更改。我一般用的是 &lt;a href=&quot;https://github.com/airbnb/javascrip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Airbnb
    
    </summary>
    
    
      <category term="工具/配置" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>2017我的年度小结</title>
    <link href="http://sevencai.github.io/2018/01/02/2017%E6%88%91%E7%9A%84%E5%B9%B4%E5%BA%A6%E5%B0%8F%E7%BB%93/"/>
    <id>http://sevencai.github.io/2018/01/02/2017我的年度小结/</id>
    <published>2018-01-02T11:33:28.000Z</published>
    <updated>2018-01-02T13:14:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>2017 年 6 月底，我毕业了。4月份到了学校，花了大概1个半月学车，半个多月论文，半个月跟我最爱的室友一起浪。可能是先前一直实习，已经熟悉了【哦，原来工作是这个样子】，当7月份再次回到公司的时候，我一点都没有觉得不适应。也没有16年刚来的懵和恐慌。</p>
</blockquote>
<p>当时的懵是从学校到社会的转变，很多东西都不懂。记得刚来的第一天， 中午大家都在睡觉，当时我导师坐在我前面，我中午敲了一个中午的键盘，把环境布置好了。但是后面才意识到，我那天肯定影响了我师父休息。那天我一上午加一下午没有去厕所，没有喝水。因为不好意思问，组里的同事都是男生。</p>
<p>当时的恐慌来自对工作的不熟悉，对环境的不适应。我当时觉得好像什么都不懂，工具也不懂，知识点也不再是学校用的那些，然后业务逻辑也不懂。好在我真的有个很好很好的师父。直到现在我跟他一起做项目，不懂的都是问他。他很耐心，懂的很多，也非常帅气，真的这一年以来，多亏了的导师。感恩。好在我自己也还算努力，一年下来真的觉得自己进步了。</p>
<p>进步了哪些？ 我时常会去看一些跟我一起进来的毕业生，看看他们的成长速度。看到有的优秀的前端，都已经是 nodejs 的 collabrator 了，写的文章也很有意思。 我会经常鞭策自己要向他们看齐，虽然我现在没有他们这么厉害，工作大部分也是写业务逻辑。但是并不代表我没有努力和梦想，至少我还知道自己不足，还知道自己想要努力的方向。说的业务层面，我觉得我已经进步很多了，因为腾讯是一个很大的公司，业务很多很杂，我们部门又承载了公司的整个虚拟支付的体系，涉及到的就不是单个业务，而是一群业务组。各种各样的游戏币，q币以及包月服务等。通过组里的一个项目我已经了解了很多了，不在是当时那个连听他们讨论问题都听不懂的我了。</p>
<p>我有没有想过放弃过？ 没有放弃过，只有难过过， 有的时候工作搞不定， 加了几个星期很长时间的班，有的时候一个问题找了一天发现是重构的 bug, 有的时候跟同事沟通不顺畅的时候，都有难过过。但是你会发现，再难的问题总有解决的一天，真的一切都会过去。就比如你很在意的今天，在很多年后，也只是你人生中的一点点。有一次，路过科技园的天桥，哇的一下就哭了，没有原因，不是因为工作，也不是因为生活，哭的很惨很放肆，但是哭完好开心。哈哈。</p>
<p>提到了科技园的天桥，我今年一整年只要不是下雨或者大姨妈，都是走路回家，差不多5km, 走到腾大底下的时候，如果大龙也下班，他就会送我回家。可是大部分时间他也很忙，一般都到11，12点了，我就会一个人回家。差不多10点20左右下班， 11点左右能到家。提到这里不知道为啥他很忙，可能也是忙业务。大龙是个非常优秀的员工，至少在我心里是。如果我是个老板，我一定雇佣他当我的员工，很认真，很负责，很会处理问题，沟通能力很强。但是写代码方面，我觉得他没有什么进步，可能是因为他现在已经逐渐转运维了。我这毕业半年来都没有感过冒，我怀疑跟我每天走路回家有关系， 还有我现在住的房子很通气。嘻嘻。</p>
<p>我想到哪里就写到哪里了。刚刚提到了大姨妈，这个是我工作的克星。 两次请病假其实都是因为大姨妈。不知道为啥，从高中起，我就反应这么激烈。老是动不动就疼的晕倒，你肯定不懂我的痛苦。真的是折磨死我了。好在大部分时间都在周末。新的一年我希望上帝能保佑我不再疼的晕倒。</p>
<p>我一直想写一篇关于人性善良的文章。对于这个我深有理解。因为我的大姨妈，我真的认识到世界上的好人真的很多。善良的人都很多。</p>
<p>第一次晕倒是高中跟妈妈在超市逛家具，逛着逛着就晕倒在了沙发上，妈妈说我当时脸色发白，浑身出汗，只有一点一点的意识是妈妈吓死了，赶紧跟伯伯一起把我送到了医院。 我好爱好爱我的妈妈。后来还有几次印象深刻的，高中又一次晕倒在了厕所，老师把我带到了医务室，给我付了医药费。当时我一个星期一共就20块钱，没有钱还给他，他就说没关系，不用还，后面再还都可以的。后来我过了好几个星期才还给他。还有好几次是跟大龙在一起，有一次大龙去我家接我，我准备跟他一起去腾大加班。结果地铁上忽然昏倒了，完全失去了意识， 后来大龙把我托下了地铁，有人给我让了位置，我一会就醒了，当时完全出不了地铁站，短短2分钟的路程，我走了半个小时，一直坐在地上，想想当时来来往往那么多人，大龙都完全没有嫌弃我，还给我买水喝，真的很感动。还有一次是在超市门口，出来就不行了，扫地的阿姨帮我叫了人，收营员姐姐给我拿了牛奶，后来打电话让大龙送了我回家。 我当时心想， 我一定要当一个好人，有能力也去帮助别人。因为我受到了太多人的帮助，虽然再他们看起来虽然微不足道，但是这些小小的举动，都让那时候的我感到了深深的力量。还有在办公室疼的不行的，我真的觉得好丢人好丢人。</p>
<p>扯远了，不过都是我的这一年最深的感受。再提到工作总结，上半年实习的时候，还有好些产出，下半年的时候很忙，写的文章很少了。其实我有学到很多东西，但是都没有产出，因为没有时间去总结，这也导致了我有些东西半知半解。<br>下半年的时候一直在用 vue 全家桶，vue 真的是个好框架。现在只是停留在熟悉怎么用的阶段，下个阶段争取能把里面核心实现的机制了解清楚。</p>
<p>今年自己写代码，总是这样写：</p>
<blockquote>
<p>create by sevencai@2017/11/11<br>contact seven.cailidan@gmail.com</p>
</blockquote>
<p>就是短短的这几行字，让我有动力去不断的 review 自己的代码，能不能写的更好，是不是语法没有符合规范，是不是有可以优化的方法。我觉得这点没有变过，我不想让以后如果有人看我的代码，说我写的不好。至少不要那么难看，尽力做到最好。 不管项目再怎么赶， 我一直提醒着自己。千万不要被后人骂，说不定你的代码要跑10年呢。</p>
<p>没有去旅行， 因为没有钱。大龙哥跟我是同一类人。以前大学的时候，基本上每年都跟小伙伴们去旅行，每个人就1000块钱，做硬座，睡旅馆，3，4个人挤在一个房间里，买一份东西大家一起吃，都是很美好的回忆，但是到了工作，真的是因为没有那1000块钱了吗？ 还是因为自己已经懒到连去看更远更大的世界的心都没有了？ 我觉得是第二种。人可怕的不是没有目标，可怕的是还要为自己没有目标找借口。嗯，就是这样。要改变。</p>
<p>提到了2018， 2018是个不一样的一年。 2018，妈妈就50岁了。 2018，我的小侄子要出生了。2018，是我跟大龙认识的第7年。 2018，我将在鹅厂工作满一年。 2008年的时候，爸爸带我去了北京，看了别人升旗。转眼间10年就过去了。2018，我想去趟北京，爬下长城，去胡同里吃遍小吃。对自己有下面些期待。等到2018结束的时候，再来看看自己的这些 flag 有没有成功。</p>
<ol>
<li>办港澳通行证，带妈妈来深圳香港，逛一逛。吃一次三千日本料理。</li>
<li>去一趟北京，爬下长城。</li>
<li>坚持运动，每天中午坚持吃饭，晚上吃水果，锻炼锻炼身体，出出汗。</li>
<li>能瘦8斤（这个怕是最不可能实现的了，但是梦想还是要有的，万一呢）。</li>
<li>晚上1点之前睡觉。（12.59关手机睡觉）</li>
<li>跟最爱的雪琴，盼盼或者干夫，伟成他们几个一起去趟成都。</li>
<li>在把自己工作做好的情况下，对业务熟悉的情况下，多提升自己的专业技能。</li>
<li>把鸟哥的 linux 私房菜好好再学习下。</li>
<li>对 JS 原生，还要再多花时间弄清楚，最好再把书完整的过一遍。</li>
<li>多学点 Nodejs 、Http 吧, 争取把学的内容都整理到博客来，不要偷懒。</li>
<li>知其然，知其所以然。</li>
</ol>
<p>2018！ 你要去看更大更远的世界！不止脚下，不止书中，不止将来！(To discover a bigger world!)</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017 年 6 月底，我毕业了。4月份到了学校，花了大概1个半月学车，半个多月论文，半个月跟我最爱的室友一起浪。可能是先前一直实习，已经熟悉了【哦，原来工作是这个样子】，当7月份再次回到公司的时候，我一点都没有觉得不适应。也没有16年刚来的懵和恐
    
    </summary>
    
    
      <category term="生活与总结" scheme="http://sevencai.github.io/tags/%E7%94%9F%E6%B4%BB%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>mac 下 zsh: command not found</title>
    <link href="http://sevencai.github.io/2017/12/15/mac-%E4%B8%8B-zsh-command-not-found/"/>
    <id>http://sevencai.github.io/2017/12/15/mac-下-zsh-command-not-found/</id>
    <published>2017-12-15T02:54:30.000Z</published>
    <updated>2017-12-15T03:53:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，是我使用 <code>tnpm install -g webpack</code> 或者任何使用 -g 来安装的全局 npm 包都报错： <code>zsh: command not found</code>,</p>
<p>想到了肯定是环境变量引起的，zsh 找不到全局包安装的位置。</p>
<p>zsh 的配置文件在 <code>~/.zshrc</code> 文件中，里面已经有被配置了的环境变量如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> $PATH = <span class="regexp">/usr/</span>bin:<span class="regexp">/usr/</span>local/bin:<span class="regexp">/usr/</span>bin:<span class="regexp">/bin:/u</span>sr/sbin:<span class="regexp">/sbin</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 或者你可以直接在终端工具中 echo $PATH 查看暴露的全局环境变量</span></span><br></pre></td></tr></table></figure>
<p>发现问题后，找到了 npm -g 安装的全部目录为（…为自己的目录） <code>/usr/local/bin/node/.../bin</code> 下， 添加到 $PATH 后面即可。</p>
<p>每个 : 代表的是多个环境变量的分割。</p>
<p>过程中做了一件特别傻的事情，没有把 npm 的目录直接在原来的 export 后面加，而是直接新建了一行，大概是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH = <span class="regexp">/usr/</span>bin:<span class="regexp">/usr/</span>local/bin:<span class="regexp">/usr/</span>bin:<span class="regexp">/bin:/u</span>sr/sbin:<span class="regexp">/sbin</span></span><br><span class="line"><span class="regexp">export PATH = /u</span>sr/local/bin/node/.../bin</span><br><span class="line"></span><br><span class="line">zsh 启动会报错：</span><br><span class="line">/Users/sevencai/.oh-my-zsh/oh-my-zsh.sh:<span class="number">3</span>: command not found: env</span><br><span class="line">env_default:<span class="number">1</span>: command not found: env</span><br><span class="line">env_default:<span class="number">1</span>: command not found: grep</span><br><span class="line">env_default:<span class="number">1</span>: command not found: env</span><br><span class="line">env_default:<span class="number">1</span>: command not found: grep</span><br></pre></td></tr></table></figure>
<p>这样会导致最后的环境变量是后面一项，前面被覆盖了。导致一些最基本的命令，如 cat/vi/vim 都不能使用了。哈哈，连vi都不能用了，我知道错了，怎么改回来？</p>
<p>直接在命令行中<code>export PATH=/bin:/usr/bin:/usr/local/bin</code>， 然后再去 vi ~/.zshrc 更改就好了。</p>
<p>zshrc 是 zsh 的配置文件，如果你不是用的 zsh, 而是 bash 或者 shell , 配置文件就不是这个了，有可能是 .bash_profile 之类的。</p>
<p>记得每次 modify …rc 文件后都 source 下哦， 要不不会生效。</p>
<p>上面或者直接使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH = <span class="regexp">/usr/</span>bin:<span class="regexp">/usr/</span>local/bin:<span class="regexp">/usr/</span>bin:<span class="regexp">/bin:/u</span>sr/sbin:<span class="regexp">/sbin</span></span><br><span class="line"><span class="regexp">export PATH = $PATH:/u</span>sr/local/bin/node/.../bin</span><br></pre></td></tr></table></figure></p>
<p>即在路径前或路径后添加 <code>$PATH</code> 变量，也可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，是我使用 &lt;code&gt;tnpm install -g webpack&lt;/code&gt; 或者任何使用 -g 来安装的全局 npm 包都报错： &lt;code&gt;zsh: command not found&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;想到了肯定是环境变量引起的，zsh 找
    
    </summary>
    
    
      <category term="工具/配置" scheme="http://sevencai.github.io/tags/%E5%B7%A5%E5%85%B7-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
