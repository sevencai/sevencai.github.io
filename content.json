{"meta":{"title":"Seven's Blog","subtitle":"Share, Learn, Enjoy, Keep","description":"Seven的博客，用于记录和分享生活和技术","author":"Seven Cai","url":"http://sevencai.github.io"},"pages":[{"title":"","date":"2017-12-13T11:36:32.000Z","updated":"2017-03-02T03:36:55.000Z","comments":true,"path":"project/index.html","permalink":"http://sevencai.github.io/project/index.html","excerpt":"","text":"DEMO &amp;&amp; PROJECTS Nodejs聊天室使用SocketIO,利用较少的代码实现私聊、群聊、显示用户列表、用户进入退出聊天室记录等功能。 地址：https://github.com/sevencai/node-chat 基于hybrid的ionic应用app使用感受是，可快速上手，但是坑太多。未来hybrid应该会略于ReactNative。 项目写于2014，大二。仅限于参考代码，因为到目前为止ionic已经迭代了很多次，运行可能报错误。 地址：https://github.com/sevencai/ionic-hybrid Blog using Bootstrap14年为学习bootstrap, 利用bootstrap做了一个静态博客。 可以结合Java/PHP/.Net等后端语言动态拉去后台数据从而成为一个技术、生活博客。 地址：https://github.com/sevencai/Blog-using-Bootstrap CSS3 动画学习记录项目项目地址：https://github.com/sevencai/css3-animation 动画小项目地址： http://cailidan.cn/web/CSS3-practice-master/Adou-newSite/地址：http://cailidan.cn/web/CSS3-practice-master/box-shadow/index.html地址：http://cailidan.cn/web/CSS3-practice-master/dynamic_effect/1.html地址：http://cailidan.cn/web/CSS3-practice-master/dynamic_effect/2.html地址：http://cailidan.cn/web/CSS3-practice-master/dynamic_effect/3.html地址： http://cailidan.cn/web/CSS3-practice-master/Ghost%20Buttons/index.html地址：http://cailidan.cn/web/CSS3-practice-master/%E4%B8%83%E5%A4%95%E6%B8%B8%E6%88%8F/index.html 备注1.由于入司后代码不可外泄，以上是我大三之前的小DEMO 2.梦想希望像 TJ Holowaychuk 那样写出很多优秀的开源代码，目前还差很远，要一直努力。"},{"title":"404","date":"2017-12-18T09:34:04.000Z","updated":"2017-12-18T09:34:35.000Z","comments":true,"path":"404/index.html","permalink":"http://sevencai.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-18T09:15:19.000Z","updated":"2017-12-18T09:18:33.000Z","comments":true,"path":"categories/index.html","permalink":"http://sevencai.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-12-18T12:22:41.000Z","updated":"2017-12-18T12:22:41.000Z","comments":true,"path":"about/index.html","permalink":"http://sevencai.github.io/about/index.html","excerpt":"","text":"ABOUT SEVENMy Name is Cai Lidan, you can call me Seven. Now, I work as a front-end developer in Tencent SZ. ABOUT THE WEBSITEI use this blog to share what I learned and keep my daily mistakes. If you found some mistakes in these articles,please tell me about it. You can contact me by the ways below or leave messages through the comment column. Thank you very much. The photos of this website were missing ABOUT THE ARTICLESDo not use these articles for commercial purposes. It will be better to keep the original link so you can keep up with the latest articles. CONTACTGMAIL: seven.cailidan@gmail.comWEIXIN: sevenCaiLiDan EVERY BLOG HAS ITS HISTORY2013-2014CSDN BLOG: http://blog.csdn.net/christine95It’s now only used for keeping mistakes. 2014-2015A self-made blog using PHP, now discarded. 2015-2016For better management, I changed the php blog to Hexo, and made a theme called seven.I did’t publish it, For the code is somehow messy.WEBSITE URL: https://cailidan.cn 2016-12~Considering that I will graduate next year and can no longer use the cheap aliyun server for students(9.9Y a month), I decide to move my blog from aliyun to github.And I also changed the theme to next. I think it’s really simple and beautiful!"},{"title":"schedule","date":"2017-12-18T09:23:00.000Z","updated":"2017-12-18T09:23:16.000Z","comments":true,"path":"schedule/index.html","permalink":"http://sevencai.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-18T09:13:11.000Z","updated":"2017-12-18T09:13:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://sevencai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mac 下 zsh: command not found","slug":"mac-下-zsh-command-not-found","date":"2017-12-15T02:54:30.000Z","updated":"2017-12-15T03:53:20.000Z","comments":true,"path":"2017/12/15/mac-下-zsh-command-not-found/","link":"","permalink":"http://sevencai.github.io/2017/12/15/mac-下-zsh-command-not-found/","excerpt":"","text":"简单来说，是我使用 tnpm install -g webpack 或者任何使用 -g 来安装的全局 npm 包都报错： zsh: command not found, 想到了肯定是环境变量引起的，zsh 找不到全局包安装的位置。 zsh 的配置文件在 ~/.zshrc 文件中，里面已经有被配置了的环境变量如： 123export $PATH = /usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin// 或者你可以直接在终端工具中 echo $PATH 查看暴露的全局环境变量 发现问题后，找到了 npm -g 安装的全部目录为（…为自己的目录） /usr/local/bin/node/.../bin 下， 添加到 $PATH 后面即可。 每个 : 代表的是多个环境变量的分割。 过程中做了一件特别傻的事情，没有把 npm 的目录直接在原来的 export 后面加，而是直接新建了一行，大概是下面这样： 123456789export PATH = /usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbinexport PATH = /usr/local/bin/node/.../binzsh 启动会报错：/Users/sevencai/.oh-my-zsh/oh-my-zsh.sh:3: command not found: envenv_default:1: command not found: envenv_default:1: command not found: grepenv_default:1: command not found: envenv_default:1: command not found: grep 这样会导致最后的环境变量是后面一项，前面被覆盖了。导致一些最基本的命令，如 cat/vi/vim 都不能使用了。哈哈，连vi都不能用了，我知道错了，怎么改回来？ 直接在命令行中export PATH=/bin:/usr/bin:/usr/local/bin， 然后再去 vi ~/.zshrc 更改就好了。 zshrc 是 zsh 的配置文件，如果你不是用的 zsh, 而是 bash 或者 shell , 配置文件就不是这个了，有可能是 .bash_profile 之类的。 记得每次 modify …rc 文件后都 source 下哦， 要不不会生效。 上面或者直接使用：12export PATH = /usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbinexport PATH = $PATH:/usr/local/bin/node/.../bin 即在路径前或路径后添加 $PATH 变量，也可。","categories":[],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"嗯，又是纪录几个小的知识点","slug":"嗯，又是纪录几个小的知识点","date":"2017-10-20T11:54:29.000Z","updated":"2017-10-20T12:14:52.000Z","comments":true,"path":"2017/10/20/嗯，又是纪录几个小的知识点/","link":"","permalink":"http://sevencai.github.io/2017/10/20/嗯，又是纪录几个小的知识点/","excerpt":"","text":"Hash maps without side effects简单的来说，当我们用 对象字面量 {} 来创建这个 hash 表时，他会默认从 Object 继承属性，这等同于 Object.create(Object.prototype) , 这么来创建的话，就会有脏数据，因为其实你只是需要一个 map 而已。并且在 for in 的时候，还需要使用 hasOwnProperty 来判断。 但如果使用 Object.create(null), 我们明确的指定其原型为 null, 因此他才是真正的没有构造器，没有 toString(), hasOwnProperty, valueOf 等。注意这里不要使用 Object.create({}),这个效果跟前面是一样的。 12345678910111213141516171819const dirtyMap = &#123;&#125;;const cleanMap = Object.create(null);dirtyMap.constructor // function Object() &#123; [native code] &#125;cleanMap.constructor // undefined// Iterating mapsconst key;for(key in dirtyMap)&#123; if (dirtyMap.hasOwnProperty(key)) &#123; // Check to avoid iterating over inherited properties. console.log(key + \" -&gt; \" + dirtyMap[key]); &#125;&#125;for(key in cleanMap)&#123; console.log(key + \" -&gt; \" + cleanMap[key]); // No need to add extra checks, as the object will always be clean&#125; angular 双向绑定和 vue双向绑定AngularJS 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。 VueJS 则使用 ES5 提供的 Object.defineProperty() 方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。 移动端调试- erudaeruda 类似于 小程序的 console 控制台。但是比小程序的更好，他还可以看 network,cookies,localStorage 这些都可以显示出来，非常的方便。用法也很方便。引入文件，init下就可以了。如果觉得引入了多余的文件，生产环境去掉就行。 github 地址是：eruda 12&lt;script src=\"//cdn.jsdelivr.net/npm/eruda\"&gt;&lt;/script&gt;&lt;script&gt;eruda.init();&lt;/script&gt; 编译和解释的区别编译器 编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。 编译器需要产出另外一个代码。他往往是执行前的一步，产出可执行或者再需要编译的代码。 解释器 解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码预编译成机器码。一个解释器，通常会用以下的姿势来执行程序代码：分析源代码，并且直接执行。把源代码翻译成相对更加高效率的中间码，然后立即执行它。执行由解释器内部的编译器预编译后保存的代码 可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。 总结起来可以像下面这样理解：编译 Compile：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。 解释 Interpret：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。 Javascript Style Guide最近看到了一个我觉得很合理的 Javascript 的规范指南。 github 地址是： Airbnb Javascript Style Guide 可以利用他的 eslint 规范自己的代码。我觉得不错。 Google PageSpeed Insights想要快速提高网站的性能，用这个网站非常好。他会给你详细的分析，根据网页的代码质量得出报告。开发者根据这个报告，进行调整。除了这个外，使用 WebPagetest 也是很好的。 什么是关键 CSS对CSS文件的请求可以显著增加网页呈现所需的时间。 原因是默认情况下，浏览器将延迟页面呈现，直到它完成加载、解析和执行所有在“页面”中引用的CSS文件。 这样做是因为它需要计算页面的布局。 不幸的是，这意味着如果我们有一个非常大的CSS文件，并且需要一段时间才能完成下载，我们的用户将在浏览器开始呈现页面之前等待整个文件被下载下来。 幸运的是，有一个巧妙的技术，使我们能够优化我们的CSS的传输并减轻阻塞。这种技术被称为优化关键渲染路径。关键渲染路径表示浏览器呈现页面的所有必须步骤。 我们想要找到最小的阻塞CSS集合 ，或者关键 CSS，以使页面显示给用户。 关键资源是可能阻塞页面首屏呈现的所有资源。 这背后的想法是，网站应该在前几个TCP数据包响应中为用户获取第一个屏幕的内容（或“首屏”内容）。 人工去找 关键 CSS，当然不太方便，现在出来了很多的工具，可以帮助我们提取出关键CSS， 比如 grunt 这类工具来提取。只是单纯的好奇什么是关键 CSS， 但是我已经好久没有写过 CSS 了。 解决个 http 缓存的困惑访问百度首页的时候，为什么刷新页面后，静态资源都是返回 200， from cache? 有的人问，from cache 不是返回 304 才合理吗？ 其实不是的，百度首页再资源在刷新后实际没有发送任何请求， 因为 caache-control 的缓存时间还没到期，也就是在 chrome 中根本没有发送请求。只要是 chrome 没有发送请求，资源从本地读取，都会在 network 中显示 状态为 200， from cache, 其中的 response 只是上一次回包留下的数据。如果 cache-control 的缓存到期了，然后发了请求到服务器，但是服务器通过 etag 等，发现资源没改变，这时候肯定就是返回 304 了。不要被绕道坑里了。 总结开始工作了以后，基本上都是零零散散的学习。有些东西想要系统的写成博客，但是基本上一篇精心想写的文章，要花至少3个小时，时间略不够。我会想办法解决。比如上面的双向绑定，想仔细的写篇文章说说里面的原理，再比如 http 缓存。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://sevencai.github.io/tags/javascript/"}]},{"title":"纪录最近遇到的坑","slug":"纪录最近遇到的坑","date":"2017-10-01T13:39:56.000Z","updated":"2017-10-01T13:41:45.000Z","comments":true,"path":"2017/10/01/纪录最近遇到的坑/","link":"","permalink":"http://sevencai.github.io/2017/10/01/纪录最近遇到的坑/","excerpt":"","text":"记录最近遇到的坑ssi 未被解析今天接入 ssi 配置，本以为只需要 include 地址正确就行了。结果执行 gulp 命令后，竟然生成的 dist 里显示不出来 ssi 地址。我以为是我 virtual 绝对地址错误了。后来换成了 file,还是不正确。 最终发现我在压缩 HTML 的时候，用的 gulp-minify-html 竟然把我的 ssi 当成注释给去掉了。解决方法是 把这个插件换成 gulp-htmlmin,这个解析机制会稍微好一些，会保留我的 ssi 的内容。 1&lt;!--#include virtual=\"h5/test.js\"--&gt; Mixed Content今天在公司加班，突然同事让我帮他看个问题， 页面点击没反应。我猜测是 JS 未被正常加载，一看果然是： 页面显示 1Mixed Content: The page at was loaded over HTTPS, but requested an insecure script This request has been blocked; the content must be served over HTTPS. 错误就直白的显示页面是以 https 加载的， 但是却请求了一个不安全的 script, 这个 script 不是 https 的，而是 https 的。因此请求被浏览器拦截了。 这个问题我以前是知道的，但是这次才知道这个现象只出现在 ios 的机器上， 某些 android 对应的浏览器 上是没问题的。因此仔细了解了下这个问题，记录如下。 什么是混合内容？ 混合内容在以下情况下出现：初始 HTML 内容通过安全的 HTTPS 连接加载，但其他资源（例如，图像、视频、样式表、脚本）则通过不安全的 HTTP 连接加载。之所以称为混合内容，是因为同时加载了 HTTP 和 HTTPS 内容以显示同一个页面，且通过 HTTPS 加载的初始请求是安全的。现代浏览器会针对此类型的内容显示警告，以向用户表明此页面包含不安全的资源。 之所以用 https 很清楚， https 可以帮助我们： 身份验证， 不被重定向 数据完整性，不会有人篡改正在发送和接收的内容 保密性，会使用 TLS 提供加密 但是并不是每个网站的每个访问者都会使用最新的浏览器，并且不同的浏览器商的不同版本的浏览器处理混合内容的方式也不是完全一样的。 注意混合内容不仅仅在 https 引入 http 文件中，在 https 页面里通过 ajax 的形式请求 http 资源，也是会被 block 掉的。 如果你的项目很大，一下子没办法全部转换完成，就可以使用： 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt; 可以在相应的页面的里加上这句代码，upgrade-insecure-requests 意思是自动将http的不安全请求升级为https。 微信开发工具微信开发工具自从更新了新版本后，我真的觉得好难用啊。。。这里记录一个刚开始使用 微信开发工具发现无法使用的情况。是因为他们工具有个 bug, 自动没有转成 https。那个错误是可以在微信开发工具的请求中看到的，是个 debug 请求。要用 fiddler 或者 whistle 重定向下： 12# 微信开发者工具https whistlehttp://mp.weixin.qq.com https://mp.weixin.qq.com 顺便提下：whistle 是个很好的代替 fiddler 的工具，因为配置更加灵活，比如正则通配啥的，而且直接在浏览器中，跨平台使用，完全没有隔阂。","categories":[],"tags":[{"name":"javascripts","slug":"javascripts","permalink":"http://sevencai.github.io/tags/javascripts/"}]},{"title":"纪录几个点","slug":"纪录几个点","date":"2017-08-24T08:24:32.000Z","updated":"2017-08-25T02:56:54.000Z","comments":true,"path":"2017/08/24/纪录几个点/","link":"","permalink":"http://sevencai.github.io/2017/08/24/纪录几个点/","excerpt":"","text":"Object.create()创建Object的实例有下面三种方法：123var o1 = Object.create(Object.prototype);var o2 = new Object;var o3 = &#123;&#125;; 通过：var o4 = Object.create(null);可以创建没有原型的Object,这个对象不能使用 toString,valueOf等函数。 创建一个以另一个空对象为原型,且拥有一个属性p的对象1o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;) 字符串判断在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串。12\"37\" - 7 // 30\"37\" + 7 // \"377\" 单目加法运算符将字符串转换为数字的另一种方法是使用单目加法运算符。12\"1.1\" + \"1.1\" = \"1.11.1\"(+\"1.1\") + (+\"1.1\") = 2.2 // 注：加入括号为清楚起见，不是必需的。 false 判断当传递给条件语句时，所有其他值，包括所有对象会被计算为 true 。123456falseundefinednull0NaN空字符串 (\"\") 请不要混淆原始的布尔值true和false 与 布尔对象的值true和false.123var b = new Boolean(false);if (b) // this condition evaluates to trueif (b == true) // this condition evaluates to false promise catch error12345678910111213141516171819function imgLoad(url) &#123; return new Promise(function(resolve, reject) &#123; var request = new XMLHttpRequest(); request.open('GET', url); request.responseType = 'blob'; request.onload = function() &#123; if (request.status === 200) &#123; resolve(request.response); &#125; else &#123; reject(Error('Image didn\\'t load successfully; error code:' + request.statusText)); &#125; &#125;; request.onerror = function() &#123; reject(Error('There was a network error.')); &#125;; request.send(); &#125;);&#125; for…of statement该新特性属于 ECMAScript 2015（ES6）规范，在使用时请注意浏览器兼容性。下面的这个例子展示了 for…of 和 for…in 两种循环语句之间的区别。与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值：12345678910let arr = [3, 5, 7];arr.foo = \"hello\";for (let i in arr) &#123; console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"&#125;for (let i of arr) &#123; console.log(i); // logs \"3\", \"5\", \"7\" // 注意这里没有 hello&#125; 剩余参数(rest parameters)剩余参数语法允许将不确定数量的参数表示为数组。在下面的例子中，使用剩余参数收集从第二个到最后参数。然后，我们将这个数组的每一个数与第一个参数相乘。123456function multiply(multiplier, ...theArgs) &#123; return theArgs.map(x =&gt; multiplier * x);&#125;var arr = multiply(2, 1, 2, 3);console.log(arr); // [2, 4, 6] 列举对象属性从 ECMAScript 5 开始，有三种原生的方法用于列出或枚举对象的属性： 1.for...in 循环该方法依次访问一个对象及其原型链中所有可枚举的属性。 2.Object.keys(o)该方法返回一个对象 o 自身包含（不包括原型中）的所有属性的名称的数组。 3.Object.getOwnPropertyNames(o)该方法返回一个数组，它包含了对象 o 所有拥有的属性（无论是否可枚举）的名称。 使用 defineProperty 为已存在的对象定义 setterset 语法将对象属性绑定到要调用的一个函数上， 当尝试设置该属性时。123456789var o = &#123; a:0 &#125;Object.defineProperties(o, &#123; \"b\": &#123; get: function () &#123; return this.a + 1; &#125; &#125;, \"c\": &#123; set: function (x) &#123; this.a = x / 2; &#125; &#125;&#125;);o.c = 10 // Runs the setter, which assigns 10 / 2 (5) to the 'a' propertyconsole.log(o.b) // Runs the getter, which yields a + 1 or 6 使用defineProperty在存在的对象上定义 getterget 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。1234var o = &#123; a:0 &#125;Object.defineProperty(o, \"b\", &#123; get: function () &#123; return this.a + 1; &#125; &#125;);console.log(o.b) // Runs the getter, which yields a + 1 (which is 1) defineProperty 的 getter/setter 方法就是 Vue 双向绑定的一部分机制。 判断浏览器高度注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如：123456789var width;if (getIEVersion(navigator.userAgent) &lt; 9) &#123; width = document.body.clientWidth;&#125; else &#123; width = window.innerWidth;&#125;但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：var width = window.innerWidth || document.body.clientWidth; 几个高度1.window对象不但充当全局作用域，而且表示浏览器窗口。 2.window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 3.outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 4.screen对象表示屏幕的信息，常用的属性有：screen.width：屏幕宽度，以像素为单位；screen.height：屏幕高度，以像素为单位； location 对象location对象表示当前页面的URL信息。例如，一个完整的URL：http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP可以用location.href获取。要获得URL各个部分的值，可以这么写： 123456location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' DOM 对象低版本的IE&lt;8不支持querySelector和querySelectorAll。IE8仅有限支持。 JSON.stringify哈哈， 今天才知道 JSON.stringify 有第二个参数和第三个参数，是不是很菜。 123456789101112131415161718192021222324252627var obj = &#123; \"name\": \"小明\", \"age\": 14, \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]&#125;;// 传入数组，用于筛选需要得到的key和value，传入keyJSON.stringify(obj, [\"name\", \"skills\"]);// =&gt; \"&#123;\"name\":\"小明\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;\"// 传入函数， 用于在序列化之前对每对键值进行处理function convert(key, value) &#123; if(typeof value === \"string\") &#123; return value.toUpperCase(); &#125; return value;&#125;JSON.stringify(obj, convert); 同样， JSON.parse 也有第二个参数，用来处理得到后的JSON串。 1234567JSON.parse(obj, function (key, value) &#123; if(key === \"name\") &#123; return value + \"小朋友\"; &#125; return value;&#125;) filterfilter 一般可能我们只用第一个参数，其实还有第二个，第三个参数。1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;); 利用 filter 去除里面未定义元素或者空字符串：1234567var arr = ['A', '', null, undefined, 'R'];var newArr = arr.filter(function (ele) &#123; return ele &amp;&amp; ele.trim();&#125;)// =&gt; [\"A\", \"R\"] 利用 filter 去重：1234567var fruits = ['apple', 'orange', 'banana', 'apple'];var r = fruits.filter(function (ele, index, self) &#123; return self.indexOf(ele) === index;&#125;)// =&gt; [\"apple\", \"orange\", \"banana\"] 利用 filter 去除偶数：1234567var arr = [1,2,3,4,5,6,7,8];var r = arr.filter(function (ele) &#123; return ele % 2 !== 0;&#125;)// =&gt; [1, 3, 5, 7] 千万不要直接用 JS 里的 Sort12345678// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 字符串都是按照 ASCII 码来排列，所以1,2 没问题，只是平常要注意这个地方。后面一个一定要记住 Array.sort 默认都会把元素转换为 字符串，再来排序。所以连基本的数字排序他都没做好。 但是 sort 可以传入一个 function 用来自定义排序： 123456789101112131415161718192021var arr = [10, 20, 1, 2];// 从小到大var r = arr.sort(function (x, y) &#123; if(x &gt; y) return 1; if(x = y) return 0; if(x &lt; y) return -1;&#125;)// sort 方法会对原数组进行修改，并且返回的也是修改后的数组// arr =&gt; [1, 2, 10, 20]// r =&gt; [1, 2, 10, 20]var r = arr.sort(function (x, y) &#123; if(x &lt; y) return 1; if(x = y) return 0; if(x &gt; y) return -1;&#125;)// arr =&gt; [20, 10, 2, 1]// r =&gt; [20, 10, 2, 1]","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"Understanding Vuex","slug":"Understanding-Vuex","date":"2017-07-11T09:21:39.000Z","updated":"2017-07-12T06:44:46.000Z","comments":true,"path":"2017/07/11/Understanding-Vuex/","link":"","permalink":"http://sevencai.github.io/2017/07/11/Understanding-Vuex/","excerpt":"","text":"Recently, I try to use Vuex to do some small projects. After some studies, I find a better way for myself to understand and use it. Here, I just put them done in my blog for later reading. If you find any grammar mistakes or misleading opinions, please let me kown. Thank you. define a storeFirst define a store. A store should contain 4 parts, they are state mutaions actions getters after define these 4 parts, combine them by using Vue.Store(). State is an Object. It contains all the data information of your app. Each Vuex instance is just a single state tree. mutations are operations that actually mutates state. And state can only be changed by mutations. Each mutaion handler gets the entire state tree as the first argument, followed by additional payload arguments. Mutations must be synchronous and be recorded by plugins for debugging purposes. actions are functions that causes side effects and handle your logical process . Unlike mutations, you can involve asynchronous operations. getters are functions. let’s see an counter example. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)//define root state object.const state = &#123; count: 0&#125;// define mutaionsconst mutations = &#123; increment (state) &#123; state.count++ &#125;, decrement (state) &#123; state.count-- &#125;&#125;// define actionsconst actions = &#123; increment: (&#123; commit &#125;) =&gt; commit('increment'), decrement: (&#123; commit &#125;) =&gt; commit('decrement'), incrementIfOdd (&#123; commit, state &#125;) &#123; if ((state.count + 1) % 2 === 0) &#123; commit('increment') &#125; &#125;, incrementAsync (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('increment') resolve() &#125;, 1000) &#125;) &#125;&#125;// define gettersconst getters = &#123; evenOrOdd: state =&gt; state.count % 2 === 0 ? 'even' : 'odd'&#125;// A Vuex instance is created by combining the state, mutations, actions,// and getters.export default new Vuex.Store(&#123; state, getters, actions, mutations&#125;) The above example comes from https://github.com/vuejs/vuex. You can see that all the four parts are been written in one file, which is bad for big and complex projects. To avoid this, just split them, and then combine them together. define entryYou may have an root element in your app. Just set the store and the view component to the root element. In this way , your store will be available in any place of your application.123456789import Vue from 'vue'import Counter from './Counter.vue'import store from './store'new Vue(&#123; el: '#app', store, render: h =&gt; h(Counter)&#125;) Then, you just need to include this file in your index.html. Shared.js is common code that you extract by webpack.bundle.js includes all the code that you need in this app. 12345&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"shared.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt; write your view componentAfter defining the entry, We can begin write our component. Notice that you can use your Store Object now. Use $store.state.count to get your state info. And by functions like mapGetters and mapActions ,you can get the functions that you have just defined in store a moment ago. 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=\"app\"&gt; Clicked: &#123;&#123; $store.state.count &#125;&#125; times, count is &#123;&#123; evenOrOdd &#125;&#125;. &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;button @click=\"incrementIfOdd\"&gt;Increment if odd&lt;/button&gt; &lt;button @click=\"incrementAsync\"&gt;Increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapGetters, mapActions &#125; from 'vuex' export default &#123; computed: mapGetters([ 'evenOrOdd' ]), methods: mapActions([ 'increment', 'decrement', 'incrementIfOdd', 'incrementAsync' ]) &#125;&lt;/script&gt; run the appWe have just used ES2015 and vue, so it’s necessary to use webpack compiling all the code. Actually, I am not very skilled in webpack. So I keep them down, and give some small introductions for later checking out. 1234567891011121314151617181920212223242526272829303132const webpack = require('webpack');const path = require('path');module.exports = &#123; entry: './app.js', output: &#123; path: __dirname, filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123;test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader'&#125;, &#123;test: /\\.vue$/, loader: 'vue-loader'&#125; ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'shared', filename: 'shared.js' &#125;), //get share.js new webpack.DefinePlugin(&#123; // 编译时配置的全局变量 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development') &#125;), new webpack.HotModuleReplacementPlugin(), //热更新插件 new webpack.NoEmitOnErrorsPlugin() //不触发错误,即编译后运行的包正常运行 ]&#125; After make the webpack.config,let’s start the server. Here, we can use express to build a little server. 1234567891011121314151617181920212223242526272829303132const express = require('express')const webpack = require('webpack')const webpackConfig = require('./webpack.config')const webpackHotMiddleware = require('webpack-hot-middleware')const webpackDevMiddleware = require('webpack-dev-middleware')const opn = require('opn')const app = express()const port = process.env.PORT || 8080const autoOpenBrowser = true //you can load the config from your config file.const compiler = webpack(webpackConfig)app.use(webpackDevMiddleware(compiler, &#123; stats: &#123; colors: true, chunks: false &#125;&#125;))app.use(webpackHotMiddleware(compiler))app.use(express.static(__dirname))module.exports = app.listen(port, (err) =&gt; &#123; if(err) return console.log(`Server listening on http://localhost:$&#123;port&#125;, Ctrl+C to stop`) if(autoOpenBrowser) &#123; opn(`http://localhost:$&#123;port&#125;`) &#125;&#125;) npm package opn was used to force open the browser.","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"由 Fetch 跨域 看 CORS","slug":"由-Fetch-API-看-CORS","date":"2017-03-06T07:59:49.000Z","updated":"2017-07-11T09:31:21.000Z","comments":true,"path":"2017/03/06/由-Fetch-API-看-CORS/","link":"","permalink":"http://sevencai.github.io/2017/03/06/由-Fetch-API-看-CORS/","excerpt":"","text":"最近在看 react 获取服务器数据时， 看到了一新的 API fetch， 上手来用了用，觉得十分好用。但是使用的过程中遇到了一些问题，还是决定整体的记录下。 fetch 类似于 Ajax, 区别自在与 fetch 结合了 promise 的友好调用方式，有效的防止了 callback hell。 fetch() allows you to make network requests similar to XMLHttpRequest (XHR). The main difference is that the Fetch API uses Promises, which enables a simpler and cleaner API, avoiding callback hell and having to remember the complex API of XMLHttpRequest. 对比传统方式与 fetch先感受下好用在哪儿：123456789101112131415161718fetch('./api/some.json') .then( function(response) &#123; if (response.status !== 200) &#123; console.log('Looks like there was a problem. Status Code: ' + response.status); return; &#125; // Examine the text in the response response.json().then(function(data) &#123; console.log(data); &#125;); &#125; ) .catch(function(err) &#123; console.log('Fetch Error :-S', err); &#125;); 相比于传统的 XMLHttpRequest 的如下写法： 1234567891011121314function reqListener() &#123; var data = JSON.parse(this.responseText); console.log(data); &#125;function reqError(err) &#123; console.log('Fetch Error :-S', err); &#125;var oReq = new XMLHttpRequest(); oReq.onload = reqListener; oReq.onerror = reqError; oReq.open('get', './api/some.json', true); oReq.send(); 传统的 XMLHttpRequest 需要使用两个回调函数，分别在 onload 和 onerror 的时候使用。并且使用 open 和 send 两个 api, 这么看来 fetch 是不是很好用。 fetch 跨域在用 fetch 的时候，跟普通 ajax 一样，经常会遇到 跨域的情况，那么跨域应该如何解决呢？ 分为下面两种情况，也可以看我在知乎上的回答： 1. 如果服务器不支持 CORS， 则不用使用 Fetch Api 了。 因为此时如果你设置了 {mode: &#39; cors &#39;}，就会报错告诉你你请求的服务器不支持 CORS。大概会报下面的错误： Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 如果设置成 {mode: &#39; no-cors &#39;}, 虽然不会报错，但是结果会 返回被标记了为 opaque 的数据，表明你没有权限访问。 这种情况下可以使用 JSONP。 2. 如果服务器支持 CORS, 则在客户端设置相应的 Access-Control-Allow-Origin 即可得到数据。 1234567891011let myHeaders = new Headers(&#123; 'Access-Control-Allow-Origin': '*', 'Content-Type': 'text/plain'&#125;);fetch(url, &#123; method: 'GET', headers: myHeaders, mode: 'cors'&#125;) .then((res) =&gt; &#123; // TODO &#125;) 回到刚刚的第一种情况， 如果 设置 {mode: &#39;no-cors&#39;} 返回的数据都是 opaque 的，那还要这种 mode 干嘛呢？ no-cors is intended to make requests to other origins that do not have CORS headers and result in an opaque response, but as stated, this isn’t possible in the window global scope at the moment. introduction-to-fetch这篇文章给了我们解释，就是比如你发送一些 log_data 的数据， 上报一些数据，这个时候你是不需要返回的，那利用 no-cors 就是没问题的了。也就是说 {mode: ‘no-cors’} 模式允许来自 CDN 的脚本、其他域的图片和其他一些跨域资源或者不需要返回资源的, 但是 cors 模式一般用来跨域请求，从而从第三方提供的 API 获取数据。 缺点与优点优点上面已经讲到了，比如支持 primise 的方式，比如简介的 API, 多样的设置。 但是还有一种情况可能会使用到： 比如你需要的传给服务器的数据很大，这时候用传统的 JSONP 不太合适，因为 JSONP 只支持 GET, 不支持 POST, 这个时候也可以用 Fetch, 给相应的服务器设置一下 CORS 即可。 有一个缺点是浏览器不兼容，还有一个缺点 和 promise 一样，一旦发生了就不能取消。 其他注意的地方1.在 Firefox 39, Chrome 42 以上都支持了， 对于其他浏览器，建议使用 Fetch Polyfil 2.Fetch 引入了 3 个接口，分别是 Headers，Request 和 Response， 这里就不讲解具体怎么用了。 理解CORS在用 fetch 的过程中， 发现自己对 CORS 的理解还是不完全，又学习了下： 跨来源资源共享（CORS）是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略[1]，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS 简单的说，我们只需要在服务器上发送一个响应标头， 就可以允许一个域上的网络向另外一个域提交跨域请求。 这种方法就是 CORS ,是一种跨域的访问机制。 比如在我的 php 代码中 header 一下： 1header(\"Access-Control-Allow-Origin: *\"); 然后再浏览器返回给我们的 Response Headers 里面就有下面的信息： CORS 的请求又包括了 两类，有简单请求以及非简单请求两种。两种具体不同在于对服务器请求的不同。 如果是简单的 HEAD、GET、POST ，Content-Type只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain，这种情况就是简单请求。 如果有请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json 的时候，那么可以认为是复杂请求。 两者的区别在于 后者（复杂请求）回去在真正的请求服务器资源前， 先发一次预检请求，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。而第一种就是不管怎么样都会先发一次 XMLHttpRequest。 更加具体的可以参考文章understanding/CORS和文章from 软老师的cors other tips在学习 fetch 的过程中， 看到了一篇文章javascript ajax libraries, 这篇文章里面总结了下我们发起 http 请求时，用到的一些库的对比。我觉得总结的很好。附文章中的一个图。 总结总体来说就是学习了一个新的 API, 然后又进一步了解了下 CORS, 了解了什么时候该用 Fetch, CORS 又是场合下用，并且分为哪些中情况。 阅读并推荐资源如下，十分感谢： introduction-to-fetch introduction-to-fetch fetch的具体使用方法 CORS的两种处理方式","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://sevencai.github.io/tags/javascript/"}]},{"title":"探索Promise用法和机制","slug":"深度探索Promise机制","date":"2017-02-27T13:36:38.000Z","updated":"2017-07-11T09:25:01.000Z","comments":true,"path":"2017/02/27/深度探索Promise机制/","link":"","permalink":"http://sevencai.github.io/2017/02/27/深度探索Promise机制/","excerpt":"","text":"以前就会经常用到 Promise，但是没有去探究内部的实现机制。 正好由这次在小程序中引入了 Promise ，探究下内部原理。 为什么使用 PromisePromise 可以让我们避免回调的地狱。以前我们可能使用的是 bluebird 或者 Q,现在我们已经有了原生的实现。1234567891011func1(function (value1) &#123; func2(value1, function (value2) &#123; func3(value2, function (value3) &#123; func4(value3, function (value4) &#123; func5(value4, function (value5) &#123; // Do something with value 5 &#125;); &#125;); &#125;); &#125;);&#125;); 使用 Promise 后，可以把平行的代码变成竖状的易读的代码。12345func1(value) .then(func2) .then(func3) .then(func4) .then(func5) 一个最常见的 Promise 的例子如下：1234567891011var request = require('request');return new Promise((resolve, reject) =&gt; &#123; request.get(url, (error, response, body) =&gt; &#123; if(body) &#123; resolve(JSON.parse(body)); &#125; else &#123; resolve(&#123;&#125;); //reject(....); &#125; &#125;)&#125;) 小程序 Promise 化实现小程序里，包括官方文档的 demo 里会看到很多的 cb, 比如我们获取用户身份信息就需要下面的操作：12345678910wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo; typeof cb == \"function\" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125;&#125;); 这样略微深的嵌套一定程度的阻碍了我们的阅读和理解，代码整体也不好查 bug 和 扩展。所以我考虑到用 Promise 扩展一层。 但是由于小程序已经去除了 自带的 Promise ，所以需要开发者自动引入 Promise 库，或者编写相应的 Promise 库。这里我引入 es6-promise 这个库。注意不要使用 bluebird ，bluebird 会导致android 上有报错，因为这个里面有用到一些小程序不支持的比如 document, window之类的对象。 选取一小段没使用的代码如下：12345678910var Promise = require('es6-promise').Promise; var wxLib = require('../wxLib);wxLib.login().then(()=&gt;&#123; wxLib.getUserInfo();&#125;).catch(()=&gt;&#123; wxLib.showErrorMsg();&#125;) promise 更易我们看清整个的结构。更好的控制异步流程， 也可以让我们使用本来不方便使用的 return, throw 等。 更多其他的用法关于 Promise 的几个注意的地方 Promise 对象是一个构造函数，所以才需要 new Promise 生成一个 Pormise 的实例对象。 Promise 构造函数接受了两个参数，分别是 resolve 和 reject, 这两个函数由 js 引擎提供，不需要自己实现。 resolve 是将 Promise 对象从 未完成 =&gt; 成功。（pending =&gt; resolved）, reject 是 将对象的状态从 未完成=&gt; 失败。（pending=&gt;rejected） then 方法接收两个回调函数。第一个是 Promise 返回 resolved 的时候调用的， 第二个是 返回 rejected 的时候调用的。 Promise catch 是 .then(null, rejection)的别名，里面的回调用于发生错误时使用。 12345678910111213141516// 这种情况不会捕捉then 里的错误promise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// betterpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 关于Promise.all的用法 var p = Promise.all([p1, p2, p3]);其中 Promise.all 会接收一个数组作为参数， p1,p2,p3都是 Promise 对象的实例。 如果不是，则调用 Promise.resolve 方法，将参数转化为 Promise 实例。 他们三个之间的关系是： 必须都变成 fulfilled ， p才是 fulfilled, 只要有一个是 rejected, 就会是 rejected, 并且这个第一个被 reject 的实例的返回值就会给到 P。 haha, 挺团结的。 12345678910111213141516171819202122let urls = [ '/api/commits', '/api/issues/opened', '/api/issues/assigned', '/api/issues/completed', '/api/issues/comments', '/api/pullrequests'];let promises = urls.map((url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: url &#125;) .done((data) =&gt; &#123; resolve(data); &#125;) &#125;)&#125;)Promise.all(promises) .then((results) =&gt; &#123; // results is an array list&#125;) 有一个方法叫做 Promise.race() 跟 Promise.all 差不多。也是 var p = Promise.race([p1, p2, p3]); p1, p2, p3 只要有一个率先改变，p 的状态就会改，并且把这个率先改的返回值给到 P。 Promise.resolve() 的 用法上面提到了， promise.all 和 promise.race 的参数 p1, p2, p3 都必须是 promise 的实例对象。 如果不是，就需要转化为 Promise 对象。 Promise.resolve 就派上了用法。 12Promise.resolve('foo');new Promise(resolve =&gt; resolve('foo')); Promise.resolve 方法的参数分成下面几个情况： Promise.resolve(value); Promise.resolve(promise); Promise.resolve(thenable); 12345678910Promise.resolve(\"Success\").then(function(value) &#123; console.log(value); // \"Success\"&#125;, function(value) &#123; // 不会被调用&#125;);var p = Promise.resolve([1,2,3]);p.then(function(v) &#123; console.log(v[0]); // 1&#125;); 实现一个简易的 Promise这里实现的过程我参考阅读了很多篇文章，感谢，具体有： 剖析Promise内部结构 how-do-promises-work JS Promise的实现原理 先搭一个简单的框架。 构造函数的实现123456789101112131415161718192021// processor 就是传给 Promise 的函数function Promise(processor) &#123; this.status = 'pending'; this.data = undefined; this.onResolvedCb = []; this.onRejectedCb = []; this.resolve = (value) =&gt; &#123; //TODO &#125; this.reject = (reason) =&gt; &#123; //TODO &#125; try&#123; (typeof processor === 'function') &amp;&amp; processor(resolve, reject); &#125;catch(e) &#123; reject(e); &#125; &#125; 然后是对 resolve 和 reject 的实现， 我们用原生的 Promise 的时候不需要实现这两个函数，是因为 JS 引擎已经帮我们做了这件事情。 123456789101112131415161718this.resolve = (value) =&gt; &#123; if(this.status === 'resolved' || this.status === 'pending') &#123; this.status = 'resolved'; this.data = value; for(var i = 0, l = this.onResolvedCb.length; i &lt; l; i++) &#123; //执行回调函数 this.onResolvedCb[i].value; &#125; &#125;&#125;// reject 就和 resolve 非常像this.reject = (reson) =&gt; &#123; if(this.status === 'rejected' || this.status === 'pending')&#123; this.status = 'rejected'; //...... &#125;&#125; then 函数的实现1234567891011121314151617181920212223242526272829Promise.prototype.then = (onResolved, onRejected) =&gt; &#123; onResolved = typeof onResolved === 'function' ? onResolved : function(value) &#123;&#125; onRejected = typeof onRejected === 'function' ? onRejected : function(reason) &#123;&#125; if(this.status === 'resolved')&#123; return new Promise((resolve, reject) =&gt; &#123; try&#123; let x = onResolved(self.data); if(x instanceof Promise) &#123; x.then(resolve, reject); &#125; resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;else if(this.status === 'rejected') &#123; return new Promise((resolve, reject) =&gt; &#123; //TODO &#125;) &#125;else&#123; //pending return new Promise((resolve, reject) =&gt; &#123; //TODO &#125;) &#125;&#125; 总结上面只是一个粗浅的大概。如果要丰富 Promise ， 还要去实现很多其他的内容，比如 catch 之类的。关于异步还有很多要学习，其实大部分都学习过，只是因为使用的少，没有考虑他内部的实现，也比较容易忘记。还是实践是王道。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://sevencai.github.io/tags/javascript/"}]},{"title":"React 读书笔记（一）","slug":"React-读书笔记","date":"2017-02-21T03:07:36.000Z","updated":"2017-07-11T09:25:15.000Z","comments":true,"path":"2017/02/21/React-读书笔记/","link":"","permalink":"http://sevencai.github.io/2017/02/21/React-读书笔记/","excerpt":"","text":"最近又把 React 的官方文档和有关的书籍看了下，又有新的收获。下面记录下我最近有感受的或者觉得重要的一些地方。也体会到了其实最好的书籍就是官方文档。 而且React的文档写的很好，有很好的例子，有codepen,也有相应的解释说明。赞。 Adding React to an Existing ApplicationYou don’t need to rewrite your app to start using React. We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case. 如果已经有现有的 App，没有必要重头全部重构，可以先选取其中一个模块。 React Only Updates What’s NecessaryReact DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. 也就是传说中的虚拟DOM,每次render之前比较前后节点的区别，只更新需要更新的部分。 Components and PropsComponents let you split the UI into independent, reusable pieces, and think about each piece in isolation. Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen. 组件就像函数一样，接受 props ，然后返回对应的 元素。所以我的理解似乎组件一定要是可复用，简洁，并且保持独立。 Functional and Class Components函数和 es6 的类都可以生成 Components。123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; This function is a valid React component because it accepts a single “props” object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions. You can also use an ES6 class to define a component:12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; can both be used as12345const element = &lt;Welcome name=\"Sara\" /&gt;;ReactDOM.render( element, document.getElementById('root')); Rules to Follow不要害怕把 大的 components 切分成小的。这一点我开始就有点害怕。总觉得分的大了就越开了，是不是越难维护了。但实际上只要组件确实是独立可复用，就完全可以大胆的分割。 Extracting ComponentsDon’t be afraid to split components into smaller components. Props are Read-OnlyReact is pretty flexible but it has a single strict rule: All React components must act like pure functions with respect to their props. 12345678910//pure, they do not attempt to change their inputs, and always return the same result for the same inputs.function sum(a, b) &#123; return a + b;&#125;//impure because it changes its own inputfunction withdraw(account, amount) &#123; account.total -= amount;&#125; So,we need State, State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule. Converting a Function to a ClassYou can convert a functional component like Clock to a class in five steps: Create an ES6 class with the same name that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Components defined as classes have some additional features. Local state is exactly that: a feature available only to classes. Adding Lifecycle Methods to a Class12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); Using State Correctly Do Not Modify State Directly12345// Wrongthis.state.comment = 'Hello';//Correctthis.setState(&#123;comment: 'Hello'&#125;); The only place where you can assign this.state is the constructor. State Updates May Be Asynchronous意思是state的更新可能是异步的，并且为了细嫩那个，有可能会合并setState。所以不能够依赖他们当前的值来计算下面的一个状态。React may batch multiple setState() calls into a single update for performance. Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. 下面就使用了prevState来保存了当前的state,这样再计算，就不会因setState异步的原因，而导致结果错误。 1234567891011121314151617// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;);// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));// Correctthis.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;); The Data Flows DownNeither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class. This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it. Handling Events这里注意this的绑定方法有下面几种：第一种：this.handleClick = this.handleClick.bind(this);12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 第二种：使用arrow functions123handleClick = () =&gt; &#123; console.log('this is:', this);&#125; 我自己比较喜欢这种，简单方便。如果真的像第一种方法绑定， 。。总觉得写的代码不太干净的样子。 第三种，在callback中使用arror function12345678render() &#123;// This syntax ensures `this` is bound within handleClick return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; );&#125; Conditional Rendering1234567function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125; 也可以在render函数中：1234567891011121314151617render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; );&#125; 也可以不用if else, 而用 condition ? true : false。 Preventing Component from Rendering直接 return null，即可防止rendering. In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output. 1234567891011function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );&#125; Lists and KeysA “key” is a special string attribute you need to include when creating lists of elements.1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity. 微信小程序貌似也是借用了这种方法。有key的时候渲染会快一点，性能会更好。 如果渲染的 obj 里面有唯一标示 id, 就用次 id, 如果没有，就用 index 也是可以的。 1234567891011121314//okconst todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;);//okconst todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); keys需要注意的地方Keys only make sense in the context of the surrounding array. keys 一定只能在需要它并且它确实在此处（上下文）有意义的时候再使用。 12345678910111213141516171819202122232425262728function ListItem(props) &#123; const value = props.value; return ( // Wrong! There is no need to specify the key here: &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // Wrong! The key should have been specified here: &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 正确的用法应该如下：123456789101112131415161718192021222324function ListItem(props) &#123; // Correct! There is no need to specify the key here: return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // Correct! Key should be specified inside the array. &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 总结起来就是有 map 的后面就需要有个 key. A good rule of thumb is that elements inside the map() call need keys. Keys Must Only Be Unique Among SiblingsKeys used within arrays should be unique among their siblings. However they don’t need to be globally unique. 当然要是唯一的，如果不唯一他的本身的作用就失去了。只要在 map 里面 id 是唯一的即可。 1234567891011121314151617181920212223242526272829303132333435function Blog(props) &#123;//key 1 const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; );//key 2 const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: 'Hello World', content: 'Welcome to learning React!'&#125;, &#123;id: 2, title: 'Installation', content: 'You can install React from npm.'&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById('root')); Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name. keys 不作为上下文传递给component参数, 如果需要 key 值传给下面的 component 就显示的传递下即可。 123456const content = posts.map((post) =&gt; &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;); Lifting State Up There should be a single “source of truth” for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the top-down data flow. 在React 应用中任何数据变动都应该是基于一个”source of truth”。通常state 被首先加入组件去渲染。然后，如果另一个组件也需要它，那么你就可以将它们提升到它们的父组件中。而不是尝试在不同的组件中同步state，你应该依赖top-down data flow。 提升状态涉及编写比双向绑定方法更多的‘样板’代码。但好处是找到和隔离bug需要较少的工作。由于任何状态存在于特定的组件中，并且该组件可以单独改变它，所以大大减少了错误的表面积。此外，你可以实现任何自定义逻辑以拒绝或转换用户输入。 如果数据可以从props或state派生，那么它就不应该在状态之中。例如，我们只存储了最后编辑的value和scale，而不是存储两个celsiusValue和fahrenheitValue。另一个输入的值总是可以从render()方法中计算出来。这允许我们清除或应用四舍五入到其他字段，而不会丢失用户输入的任何精度。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://sevencai.github.io/tags/javascript/"}]},{"title":"小程序开发体会","slug":"小程序开发体会","date":"2017-01-22T09:45:02.000Z","updated":"2017-02-09T12:02:02.000Z","comments":true,"path":"2017/01/22/小程序开发体会/","link":"","permalink":"http://sevencai.github.io/2017/01/22/小程序开发体会/","excerpt":"","text":"过去的两个月，在组里参与了【腾讯充值小程序】以及【腾讯周边】两个项目。其中充值项目，由于IOS对于微信小程序的虚拟商品的限制，暂时搁浅上线，周边已上。下面是我遇到的一些体会，坑，以及一些感受。 小程序快的原理轻应用，快一定是个最大的优点。小程序为什么这么快？平时开发是在PC端开发者工具上，可以看到各个资源的请求情况，包括js，cgi等。在真实手机上，又是怎么样的呢？ 资源最初全部下载下来 图片缓存策略 小程序大小限制，最多1M 小程序页面状态缓存，webview不会被回收销毁 每个程序都是单独的进程，并且最多5个进程 前期我曾抓了个包试试，如下： 可以看到没有我们平时在开发者工具上看到的js等资源，原因是小程序在第一次打开时就把资源预先全部从微信服务器 down 了下来到本地，（appbrand/pkg目录下，后缀名为wxapkg），存放在了本地的文件系统中，所以在你使用的过程中，只会有CGI请求发出，不会再请求其他代码资源了。 所以这也是为什么微信会限制开发者包的大小不得超过1M。这保证了第一次加载的速度，也不至于在无WIFI情况下，耗费太多流量。 所以如果完全可以通过一些API比如setStorage、getStorage等使用户在离线状态下也可以使用。 后期我再抓包时，发现请求又有了写变化，如下： 猜想（未验证仅参考）这个rid/sid可能是用来判断小程序有没有资源发生变化，比如如果开发者提交了审核新版本，那么这个时候就去判断，如果有变化就从服务器拉去新的资源。如果没有变动，就用本地文件中的资源。 再：微信对于访问过的图片，都有缓存策略，所以对比如腾讯周边小程序这样的图片很多的应用，也比较快。 小程序发布流程思考 开发者本地开发，通过开发者工具，本地预览，提交发布。然后微信通过审核，开发者发布审核版本，用户即可搜到。 上传的代码是到了微信服务器上，统一管理。所以这里是微信服务器，第三方服务器，微信客户端三方的交互。 这个过程中情形是这样的： 小程序框架分为两层 View视图层， 用于渲染页面结构。使用Webview渲染。 App Service逻辑层，用来逻辑处理，网络请求，接口调用等等。运行在JSCore中。 视图层和逻辑层通过JSBridge通信。逻辑层通知视图层数据发生变化，从而出发视图层更新。视图层则绑定事件，通知到逻辑层进行相应的业务处理。 如在视图层：123&lt;view&gt; &lt;button bindtap=\"updateData\"&gt;页面跳转&lt;/button&gt;&lt;/view&gt; 逻辑层：123456789101112131415page(&#123; data: &#123; config: &#123; title: '', name: '' &#125; &#125;, updateData() &#123; this.setData(&#123; 'config.title': '腾讯周边', 'config.name': 'Seven' &#125;); &#125;&#125;) 在View层渲染数据用户打开小程序后，选择左上角的关闭或按返回键时小程序只是隐藏到后台，webview不会被销毁或者回收。比如在ios上，从小程序转到另外一个应用中，再回来微信，打开的webview仍然存在。再android上则是可以在窗口进程中再次找到先前打开的小程序。 Native预先加载额外一个Webview，当打开指定页面时，无需请求额外资源，直接渲染 model和view双线程，单向数据绑定 重渲染使用Virtual DOM减少开销，采用diff算法局部更新 这里的单向数据绑定确实是有不方便的地方。先前用过Vue等双向绑定的，能够及时反馈用户的输入，相对来说这种可能更方便操作，也更适合小型应用。但是单向绑定就是可能更加高效一些了。 其他特性1.小程序并发请求数不超过5，这里可以做优化，比如使用接口将所有的请求合并。 2.小程序关于登录态与移动应用和网页应用的不同之处是抛弃了access_token的验证方式，而是采用session_key加签名的方式，为小程序与服务器交换敏感数据提供了对称加密方法。签名方法对小程序透明，后端服务实现相应的解密程序以及登录态验证和控制能力。由于我们部门的后台接口基本都是基于access_token这一套，后来与WX侧协商还是可以用ac.否则后台就会有很大的改动。 3.要好好的利用小程序模板机制，这样可以减少很多代码量，也更便于维护。 4.对于WX官方文档上的API,最好是自己封装一个WXLIB文件。这样可以减少代码量，统一整个代码。例如：12345678910111213class wxLib &#123; constructor() &#123; &#125; share(obj) &#123; return &#123; title: obj.title, desc: obj.desc, path: obj.path &#125; &#125;&#125; 在每一个想要分享的页面就可以：12345678910import wxLib from '../../service/lib/wxLib';Page(&#123; onShareAppMessage() &#123; return wxLib.share(&#123; title: '腾讯周边', desc: '正品周边', path: 'page/index/index' &#125;); &#125;&#125;) (233,这个好像看起来没有代码量减少，但是统一了以后，其他的也统一，就会发现后来方便很多。) 5.可以利用本地存储，解决离线的时候，黑屏无数据的情况。 6.文档很容易理解，API也好用。基本上按照文档来大部分功能都可以实现。 关于小程序定位小程序即用即走的定位原本是很好的，比如非常适合线下的营销，非常适合生活服务。比如查火车票，膜拜单车，打麻将和牌的小游戏都很合适。用户生活方便，娱乐也方便。 但是目前来看小程序除了刚发布的时候，现在的流量目测已经越来越少，除开微信好像没有做很多推广以外，小程序还没有形成用户的习惯，可能是一个问题。 小程序要发展起来，一定是要在用户形成了使用习惯，产生【不用装这个app,直接用小程序就可以满足我的需求】的这种想法。 未来会怎样，取决于微信的推广和未来长远的看法。也取决是不是有很好的小程序出来。期待未来超出想象。 下次准备写一些小程序的用法，比如模板消息，客服等等。以上内容如果有不对的地方，欢迎指正，感谢阅读。","categories":[],"tags":[{"name":"小程序 javascript","slug":"小程序-javascript","permalink":"http://sevencai.github.io/tags/小程序-javascript/"}]},{"title":"利用onerror/onload写的jsonp在IE下不兼容的问题","slug":"onload及onerror在IE下不兼容的问题","date":"2017-01-22T09:01:43.000Z","updated":"2017-01-22T09:39:55.000Z","comments":true,"path":"2017/01/22/onload及onerror在IE下不兼容的问题/","link":"","permalink":"http://sevencai.github.io/2017/01/22/onload及onerror在IE下不兼容的问题/","excerpt":"","text":"某一天，我用 js 写了一段 jsonp 的代码。以前在学校也这么写，因为在学校没有测试IE所有的版本兼容性，一直觉得这段代码木有问题。 代码是这样子的： 简单来说就是将一个script标签添加进入dom,这样就可以伪造一次请求，因为同源策略可以用script/image之类标签回避掉。 123456789101112131415161718192021222324252627282930Util.prototype.loadScript = function (url, params, cb) &#123; var path = url + '?' + this.serializeParam(params); var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); var format = params.format.substr(6), result; window[format] = function (_res) &#123; result = _res; &#125;; var handler = function () &#123; if(!script) return; head.removeChild(script); script = null; window[format] = undefined; typeof cb == 'function' &amp;&amp; cb(result); &#125;; script.src = path; script.async = true; script.charset = 'utf-8'; script.type = 'text/javascript'; script.onload = handler; script.onerror = handler; head.insertBefore(script, head.firstChild);&#125;; 直到测试同事那天在测试的时候，发现IE7,IE6的时候，请求可以发送，但是 callback 函数没有执行。导致了一个按钮好像像点不动一样。 这种 bug 算得上是严重的 bug 了，经过排查，发现确实是代码不完善，没有考虑到： 在多数浏览器（包括Firefox和Chrome）下会触发onload和onerror， 但是在IE下只会触发 onreadystatechange，也就是说在IE8及IE8以下，onerror和onload都不能够使用。 所以要调用回调函数一定需要再写一个针对 onreadystatechange 时的操作。错误中成长。 123456script.onreadystatechange = function() &#123; var r = script.readyState; if (r === 'loaded' || r === 'complete') &#123; handler(); &#125;&#125;; 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536Util.prototype.loadScript = function (url, params, cb) &#123; var path = url + '?' + this.serializeParam(params); var head = document.getElementsByTagName('head')[0]; var script = document.createElement('script'); var format = params.format.substr(6), result; window[format] = function (_res) &#123; result = _res; &#125;; var handler = function () &#123; if(!script) return; head.removeChild(script); script = null; window[format] = undefined; typeof cb == 'function' &amp;&amp; cb(result); &#125;; script.src = path; script.async = true; script.charset = 'utf-8'; script.type = 'text/javascript'; script.onreadystatechange = function() &#123; var r = script.readyState; if (r === 'loaded' || r === 'complete') &#123; handler(); &#125; &#125;; script.onload = handler; script.onerror = handler; head.insertBefore(script, head.firstChild);&#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://sevencai.github.io/tags/javascript/"}]},{"title":"Redux 中 combineReducers 和 createStore的实现原理","slug":"Redux 中 combineReducers 和 createStore的实现原理","date":"2016-10-25T14:46:27.000Z","updated":"2017-01-22T09:42:08.000Z","comments":true,"path":"2016/10/25/Redux 中 combineReducers 和 createStore的实现原理/","link":"","permalink":"http://sevencai.github.io/2016/10/25/Redux 中 combineReducers 和 createStore的实现原理/","excerpt":"","text":"最近一直在学习 redux, 感到了深深的难过，都两天了，感觉还是不知道怎么写代码，倒不是不知道是Redux 里面涉及的概念，是不知道什么代码该放在哪里。怎么样组织结构。希望再过两天能更清晰。 下面是中间学习到的 combineReducers 和 createStore 的实现原理，了解这些后，确实帮助了我更好的理解整个流程。 combineReducers 的实现原理在探究 combineReducers 的实现原理之前，先看下 combineReducers 的用法： 1234const todoApp = combineReducers(&#123; visibilityFilter, todos&#125;); 这里为了逻辑上的分离，我们把 reducers 拆分成了 visibilityFilter 和 todos, 然后利用了 combineReducers 合成了一个 reducer。 先看下我们的 todos 和 visibilityFilter 是这样的：123456789101112131415161718192021//todos const todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': //... case 'TOGGLE_TODO': //... default: return state &#125;&#125;//visibilityFilterconst visibilityFilter = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter default: return state &#125;&#125; 我们的 reducers 也是跟这里的每一个分 reducer 一样，都是函数，都要通过传入 (state, action) 来唯一判断下次的状态。所以我们 combineReducers 的作用就是重新生成一个 可以传入 (state, action) 两个值来判断 next 的 state 的值的函数。 所以这下我们就可以理解下面的代码，combineReducers 的实现： 12345678910111213141516const combineReducers = ( reducers ) =&gt; &#123; return ( state = &#123;&#125;, action ) =&gt; &#123; return Object.keys(reducers).reduce( ( nextState, key ) =&gt; &#123; nextState[key] = reducers[key]( state[key], action ); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;;export default combineReducers; 解释下：首先是返回一个可以传入两个参数的函数。所以我们先 return 一个 function, 然后再通过 reduce 函数，遍历每一个 key 值， 然后为对应的 state 赋值为新的函数。 当我们形成了新的 reducer 以后， 传入任何 的 action 和 status 就会返回一个明确的 状态树了。可能是下面这个样子的： 12345678&#123; visibilityFilter: 'SHOW_ALL', todos: &#123; id: 0, text: 'Hello world', completed: false &#125;&#125; createStore 的实现原理同样我们先看下 createStore 的用法：123//let &#123; subscribe, dispatch, getState &#125; = createStore(reducer);import &#123; createStore &#125; from 'redux';const store = createStore(reducer) createStore 通过传入 我们的 reducer 形成一个全局唯一的 store, 这个形成的 store 是一个对象，它有3个方法，分别是： 123store.dispatch()store.subscribe() store.getState() 所以其实我们就是要编辑一个函数，这个函数里面可以有这三个方法暴露给我们使用。 原理如下： 1234567891011121314151617181920212223242526const createStore = ( reducer ) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = ( action ) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125; const subscribe = ( listener ) =&gt; &#123; listeners.push(listener); return ()=&gt;&#123; listeners = listeners.filter(l =&gt; l !== listener) &#125; &#125; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;&#125; 可以看到我们是先实现了这三个方法。下面简单看下怎么用这三个方法： 12345678910111213const &#123;createStore&#125; = Redux;const store = createStore(reducer);const render = () =&gt; &#123; document.body.innerHTML = store.getState();&#125;store.subscribe(render)render();document.addEventListener('click', ()=&gt;&#123; store.dispatch(&#123;type:'INCREMENT'&#125;);&#125;)","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"React","slug":"React","permalink":"http://sevencai.github.io/tags/React/"}]},{"title":"在应用(微信/浏览器)中拉起手机QQ","slug":"在应用-微信-浏览器-中拉起手机QQ","date":"2016-10-16T10:43:30.000Z","updated":"2016-12-12T02:33:10.000Z","comments":true,"path":"2016/10/16/在应用-微信-浏览器-中拉起手机QQ/","link":"","permalink":"http://sevencai.github.io/2016/10/16/在应用-微信-浏览器-中拉起手机QQ/","excerpt":"","text":"场景是：当我们做一些活动用来拉新等等时，通常会限制用户只在手Q中打开。比如用户通过微信扫码到了我们H5活动页面。那么我们就可以通过伪协议将手Q拉起，并且将H5页面打开。用户到达的途径有很多，比如通过浏览器，通过微信，通过其他APP应用。 正解代码先不看原理的话，代码应该是像下面的。今天我也参照了许多别人的代码，但大多数不是这个不兼容，就是微信拉不起来。或者是 IOS 拉起正常，但是 Android 就是不行。这通常是由于代码没有完备造成的。更主要是因为我们的浏览器什么的都在时时更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/*** 检测浏览器UA* @type &#123;Function&#125;*/var condition = (function() &#123; var ua = navigator.userAgent, chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/); //利用正则获得匹配 安卓 UA var getAndroidVersion = function() &#123; var ua = navigator.userAgent.toLowerCase(), version = ua.match(/android\\s([0-9\\.]*)/); return version ? version[1].split('.')[0] : false; &#125;; return &#123; chrome: chrome, //true or false androidVersion: getAndroidVersion() //version &#125;&#125;);/*** 获得伪协议* @param jumpURL* @returns &#123;string&#125;*/function getURL( normal ) &#123; if(normal) &#123; return 'mqqapi://forward/url?src_type=internal&amp;version=1&amp;url_prefix='+ btoa(location.href); &#125; return \"intent://forward/url?src_type=web&amp;style=default&amp;=1&amp;version=1&amp;url_prefix=\" + btoa(location.href) + \"#Intent;scheme=mqqapi;package=com.tencent.mobileqq;end\";&#125;/** * 检测是否安装了QQ,如果没有安装要引导用户安装 */var checkIfInstallQQ = function() &#123; WeixinJSBridge.invoke(\"getInstallState\", &#123; \"packageUrl\": \"mqq://\", //ios \"packageName\": \"com.tencent.mobileqq\" //android &#125;, function(res) &#123; if(/^get_install_state:yes/.test(res.err_msg)) &#123; window.open( getURL( true ), '_self' ); window.setTimeout(function() &#123; WeixinJSBridge.invoke(\"closeWindow\"); &#125;, 1500); &#125; else if(/^get_install_state:no$/.test(res.err_msg)) &#123; if(confirm('您还没有安装手Q，现在去下载安装？')) &#123; window.location.replace('http://im.qq.com/mobileqq/touch/index.html'); &#125; &#125; else &#123; Alert.show(&#123; showCancel:false, msg: \"err:\" + res.err_msg &#125;); &#125; &#125;);&#125;;/** * 判断是否在手q中打开，如果不是，则判断是否在微信打开 * 如果在微信打开，调用微信的 JSBridge */if( !U.ua.QQ )&#123; Alert.show(&#123; showCancel:false, msg: \"请在手q中打开此页面\", onConfirm : function () &#123; //如果在微信中打开 if(U.ua.weixin) &#123; if (typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\") &#123; checkIfInstallQQ(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener(\"WeixinJSBridgeReady\", checkIfInstallQQ, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(\"WeixinJSBridgeReady\", checkIfInstallQQ); document.attachEvent(\"onWeixinJSBridgeReady\", checkIfInstallQQ); &#125; &#125; &#125;else&#123; //这里也可以判断下是否安装了手Q if(U.ua.android &amp;&amp; condition.chrome &amp;&amp; condition.androidVersion() &gt;= 5) &#123; window.open( getURL(false) ); &#125;else&#123; window.open( getURL(true) ); &#125; &#125; &#125; &#125;); return;&#125; 代码分析正常情况下我们拉起手q，利用伪协议就可以了。伪协议是形如上面的不是http,https,ftp,之类的协议。例如： 123mqqapi://forward/url?src_type=internal&amp;version=1&amp;url_prefix='+ btoa(location.href)\"intent://forward/url?src_type=web&amp;style=default&amp;=1&amp;version=1&amp;url_prefix=\" + btoa(location.href) + \"#Intent;scheme=mqqapi;package=com.tencent.mobileqq;end\" mqqapi是专门掉起手Q的， 后面的 btoa(location.href)是由于我们需要在手q打开我们的H5，所以这里要利用 location.href, 并且需要 base64的编码。这里的编码我们是利用的 window.btoa 函数。比起自己去编写 base64encode， 这个方法给我们提供了便利。 那么我们调用这一个 mqqapi 就可以了，为什么还要去判断一个 intent 呢？原因是： Android 4.4 以上将原生的浏览器换成了chrome,而Android 5.开始的chrome不再允许传统的scheme拉起手q。 所以当打开的浏览器是 Android5 的时候，我们就要去调用这个 intent 新协议，而不是原来的 mqqapi协议。但是也要注意，这里的拉起app是需要用户操作的，需要用户确定（点击确认按钮）拉起才可以。所以不要用JS定时器了。 另外要注意 IOS 9.0 safari ，IOS 9.0以后，原生的safari不支持iframe 拉起 scheme 了。可以用 location.href/top.location.href拉起。 那么下面这些代码是什么呢？ 1234567 WeixinJSBridge.invoke(\"getInstallState\", &#123; \"packageUrl\": \"mqq://\", //ios \"packageName\": \"com.tencent.mobileqq\" //android &#125;, function(res) &#123; //......&#125; WeixinJSBridge是微信浏览器内置的一个对象。JS API 建立在内置的这个对象中。但是有一个坑要注意。 WeixinJSBridge 不是我们一打开一个 WebView 就可以了的。我们需要在客户端初始化这个对象。当这个对象 ready 的时候，我们去监听，也就是这个 WeixinJSBridgeReady 事件。所以我们在调用这个 JS API 的时候，一定要判断下 WeixinJSBridge 是否存在。也就是 123typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\"document.addEventListener(\"WeixinJSBridgeReady\", checkIfInstallQQ, false); 这两句话的作用。 WeixinJSBridge.invoke 是 WeixinJSBridge 的一个方法，用来唤起相关的事件。这里我们唤起的是 getInstallState 这个事件。用来判断是否用户安装了 手机QQ。 当然还有很多别的 API，比如 1234document.addEventListener('WeixinJSBridgeReady', function onBridgeReady() &#123; // 通过下面这个API隐藏底部导航栏，‘showToolbar’是显示导航栏 WeixinJSBridge.call('hideToolbar');&#125;); 延伸和扩展这里去学习了下下面这些的区别。是可能会碰到的坑。 “top.location.href”是最外层的页面跳转 “window.location.href”、”location.href”是本页面跳转 = self.location.href “parent.location.href”是上一层页面跳转. 其他方法上面我们使用 window.open 打开的，其实我们还可以用 ifame 打开。如下面的代码： 1234567891011121314151617// ios 9 后，safari 打不开，可以用 location.href 或者 top.location.href 处理if(mqq.IOS)&#123; location.href = getURL(true);&#125;else&#123; //利用 iframe 处理 var iframe = document.createElement(\"iframe\"); if(U.ua.android &amp;&amp; condition.chrome&amp;&amp; condition.androidVersion() &gt;= 5)&#123; iframe.src = getURL(false); &#125;else&#123; iframe.src = getURL(true); &#125; iframe.onload = function () &#123; setTimeout(function() &#123; document.body.appendChild(iframe); &#125;, 0); &#125;&#125; 主要这里也是一个简略的写法。可以更加完善的。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/tags/WEB开发/"}]},{"title":"记一次实战 Dom XSS 漏洞","slug":"记一次实战-Dom-XSS-漏洞","date":"2016-10-09T14:33:55.000Z","updated":"2016-12-12T02:40:38.000Z","comments":true,"path":"2016/10/09/记一次实战-Dom-XSS-漏洞/","link":"","permalink":"http://sevencai.github.io/2016/10/09/记一次实战-Dom-XSS-漏洞/","excerpt":"","text":"国庆的前一天，突然有一个漏洞单接到我这里来，当时心里很着急，第一实习生小白，对于我们这种支付部门有漏洞不是很可怕，以前没见过，觉得有点吓人。第二，为什么是国庆的前一天呢，不能发版本。看了下，就是熟悉又不太熟悉的 Dom xss 漏洞。熟悉是因为以前书里经常见，不熟悉是因为以前没有实践过。 现象及解决办法安全部门的同事说，它更改了 uin, 然后就可以输出 用户uin, 也就是俗称的 alert 出来。 大概是这样一个步骤 12document.cookie = \"uin=&lt;img src=x onerror=alert('')&gt;\"然后刷新了我的网页，由于我获取cookie的方法不严谨，这个时候就alert出来了。 解决方法当然是换掉我不严谨的获取cookie的方法，正确获取 cookie 的方法应该如下：1234567891011121314151617function getCookie(b) &#123;var filterXSS = function(e) &#123; if (!e) return e; for (; e != unescape(e);) e = unescape(e); for (var r = [\"&lt;\", \"&gt;\", \"'\", '\"', \"%3c\", \"%3e\", \"%27\", \"%22\", \"%253c\", \"%253e\", \"%2527\", \"%2522\"], n = [\"&amp;#x3c;\", \"&amp;#x3e;\", \"&amp;#x27;\", \"&amp;#x22;\", \"%26%23x3c%3B\", \"%26%23x3e%3B\", \"%26%23x27%3B\", \"%26%23x22%3B\", \"%2526%2523x3c%253B\", \"%2526%2523x3e%253B\", \"%2526%2523x27%253B\", \"%2526%2523x22%253B\"], a = 0; a &lt; r.length; a++) e = e.replace(new RegExp(r[a], \"gi\"), n[a]); return e &#125;; var a; return filterXSS((a=document.cookie.match(RegExp(\"(^|;\\\\s*)\"+b+\"=([^;]*)(;|$)\")))?unescape(a[2]):null)&#125; 探究原因那么我的 Cookie 是怎么获取的呢？ 12var ret = document.cookie.match(new RegExp(\"(?:^|;\\\\s)\" + name + \"=(.*?)(?:;\\\\s|$)\"));return ret ? ret[1] : \"\"; 为啥我的就不严谨了呢？ 日常我们的cookie 是这样一种格式：1ts_refer=ADTAGpay.index.header.paycenter; pgv_si=s3636090880; pgv_info=ssid=s9066946176; ts_last=pay.qq.com/; pgv_pvid=2986859684; ts_uid=8406093480 所以上面代码通过 = 和 ; 获得对应的 cookie , 似乎没有错，但是如果一遇到恶意攻击，没有对不合法字符进行任意转义就输出到页面上，就会造成 web 前端的安全大隐患。所以看到最上面我们的好方法里面，是有对不合法字符进行转义的。所以我们这样处理后，就会变成下面这样一个结果： 延伸记得我刚来面试的时候，当时 qq 问了我获取 cookie 的方法，那时之前做项目写过获取 cookie 的方法，还是特别傻的方法，代码大概是这样的：1234567891011121314151617181920212223242526272829function getCookie(c_name)&#123;if (document.cookie.length&gt;0) &#123; c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) &#123; c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) &#125; &#125;return \"\"&#125; 没错，就是正则也没用，直接去找 = 和 ;之间的串是否与要查找的相同。这个方法在 w3cShool 上作为了标准方法，现在看来是误导人了。 当时 qq 问我有没有更好的方法，我说正则，但是正则还不能很快的写出来。那么这种方法除了效率不那么高以外，有没有上面提到的安全隐患呢？**做个实验： 1document.cookie = \"a=123 b=other; b=678\"; 这个的意思是 cookie a 的值为 123 b=other, b的值为 678, 但是我们通过上面的 getCookie 方法 做实验时：12getCookie(&quot;b&quot;); //输出 othergetCookie(&quot;a&quot;); //输出 123 b=other b的值很明显不正确了。这样就混淆了正确的 cookie。 所以这种方法也不是正确的方法，运用我们最上面提到的解决方法 可以很好的解决这个问题。 总结还是实战出真知，继续前行！不怕犯错，积累经验。我当时跟师傅说我遇到了 dom xss 漏洞，师傅马上就让我去检查 cookie 获取的方法，连整个事情的经过就没问，就可以做出准确的判断，这就是老司机啊，向他学习。希望以后知道一些更多关于安全方面的实战。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/tags/WEB开发/"}]},{"title":"Git 分支管理与多人协作","slug":"Git-分支管理与多人协作","date":"2016-09-20T15:19:04.000Z","updated":"2016-12-12T02:28:14.000Z","comments":true,"path":"2016/09/20/Git-分支管理与多人协作/","link":"","permalink":"http://sevencai.github.io/2016/09/20/Git-分支管理与多人协作/","excerpt":"","text":"这一篇文章主要学习和记录分支管理和多人合作。我们知道 Git 的分支管理非常快，这是因为 Git 只是生成一个指向当前版本的指针。但是以前的很多管理软件都是生成一份代码的物理拷贝，可以想象，如果代码很大，是有多慢。但 Git 的这个特点，也需要我们更好的掌握它的切换，否则很容易造成错误。 在 SF 上看到了一张图片，觉得非常好,图片来源是SF的这篇文章,感谢： 创建与合并分支创建和合并分支都可以看作是指针的移动。我们看下下面这样一套流程，这是最常见的： git checkout -b dev //创建一个新的dev（-b创建并切换） git add file.txt //在dev分支中修改 file.txt 文件 git commit -m &quot;add change on dev&quot; //到dev分支提交新的代码 git checkout master //切换到主分支 git merge dev //在主分支上合并dev分支 git branch -d dev //dev工作完成，删除该dev分支 我画了一张图用于描述这个过程： 下面我们学习一些基本的命令： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 所以： git checkout -b dev = git branch dev + git checkout dev。 合并分支碰到的问题有时候我们会碰到下面这个问题： 可以看到，我们新建了一个 feature1 分支，这个时候比如修改了 a 文件的第一行代码。然后当我们切换到 master 分支的时候，发现 master 也已经有了新版本。然后我们按照上面将的方法 切换到 master 分支，然后利用 git merge feature1 来进行合并。但是发现， master 分支也是修改了 a 文件的第一行代码，这时候我们就要手动去解决冲突了。并且会在 a 文件发现下列问题： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is a ======= Creating a new branch is b &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git 利用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;来表明冲突的地方，我们手动解决后再进行简单的合并就没有问题了。然后再删除 feature1 分支。 试试 git log --graph这个命令，你会发现分支合并图。 合并分支时，有时候 Git 会用 Fast forward 模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。可以用 –no-ff 参数，表示禁用 Fast forward 。 git merge --no-ff -m &quot;no-ff merge&quot; develope //or git merge --no-ff develop 看下下面这张图开了解下是否通过 –no-ff 的区别。 正确的分支管理策略应该是这样的。 每个人干自己的活，在自己的分支上工作，别人不受影响也看不到，然后一定时候合并到 dev 分支上，这样大家就可以看到了。然后要到一定的时候发版本再合并到 git 分支上。 修复bug分支比如我当前在dev分支工作，此时工作还没有完成不能够 merge 到master 分支，但是这个时候发现有一个 bug 需要修复。怎么破呢？ Git 还提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 git stash //保存现场 git status //发现现场是干净 git checkout master //切换到 master 分支修复 bug git checkout -b bug //在 master 分支上 新建分支 bug git add bug001.txt git commit -m &quot;修复bug&quot; //提交修改 git checkout master //切换到主分支 git merge --no-ff -m &quot;merged bug&quot; bug //合并 bug 分支 git branch -d bug //删除 bug 分支 好，这时候我们已经完成了 bug 分支的修改。我们要会到我们的 dev 分支来继续我们没有完成的工作了。进行如下的过程。 git checkout dev git status //nothing to commit git stash list //查看现场 git stash apply //恢复现场 git stash drop //删除 stash git stash pop //恢复并且删除 stash git stash list //再次查看现场 过程解释如下：首先我们切换到了 dev 分支。但是查看 git status 发现却是 nothing to commit ，这是怎么回事呢? 我们可以利用利用 git stash list 查看下。发现 Git 会列出所有保存起来的现场： stash@{0}: WIP on dev: 13d436c 工作现场还在， Git 把 stash 内容存在某个地方了，但是需要恢复一下。 git stash apply &lt;现场名称&gt;//恢复现场 git stash drop //删除 stash 其中 git stash apply stash@{0} 的现场名称可以加可以不加，如果你 git stash 了多下，就需要指明了，如果只有一个，就直接 apply 了。 apply 后，保存的现场还在，但是我们是不需要的，所以我们删除它，再使用 git stash drop 即可。这两个命令合在一起可以用 git stash pop 代替。 我们再次使用 git stash list 就会发现没有啦。 所以我们总结下，如果我们要修复 bug，我们可以创建新的bug 分支，然后合并再删除。但如果当前手头工作没有完成时，先要用 git stash 保存现场，然后去修复bug,最后再利用 git stash pop 回到工作现场。 这时候有人会问，那我不能这样吗？ 虽然我在 dev 分支上进行了修改，我切换到 master 分支上去新建 bug 分支不行吗？这样或得到的不是从 master 分支的代码吗？ dev 上的代码又没有提交到 master 分支上。 答案是不行的。应为你在 dev 上的改变，即使切换到 master 分支去新建分支都不行，会把你 dev 上的更改到新建的 bug 分支上。可以试下。我做了实验是这样。 测试的过程中， 我发现了一个好用的命令,比如你新建了一个 bug 分支，这个 bug分支做了修改，但是后来又不想用了，如果直接用普通的git branch -d bug 是删除不了的。要用下面这个命令。 git branch -D &lt;name&gt; 特别注意下，我们修补了的 bug 分支，最后不仅要同步到 master 分支，可能还要同步到当前工作的 dev 分支。我们可以起名为 fixbug-* 来命名。这样或许比较清楚。 多人协作两个小伙伴 A和B： A和B 都从远程库中 clone 代码，由于默认 clone 都是 把远程 master 分支和本地 master分支关联了起来，并且名称为 origin。此时 A 和 B 本地都有一个 master 分支，他们都要建立自己的 dev 分支。于是 A 和 B: git checkout -b dev 此时 A 和 B 同事把修改推送到 远程 origin 的 dev 上，如果第一次没有 dev 分支，则会自动建立。 git push origin dev 若 A 和 B 同时修改了同一个地方。这时候 A 推送过去， B 再 git push origin dev 的时候，会 push 失败，要解决冲突， 所以 B 需要先 git pull , 但此时 git pull 也会失败，原因是没有指定本地 dev 分支与远程 origin/dev 分支的连接。此时我们 git branch --set-upstream dev origin/dev git pull git push origin dev 总结到目前为止分支管理就也弄完了。还有一些其他功能，比如打 tag 等等。我觉得不会经常用到的，就不用写在这里了，因为不常用，肯定还会经常忘记，知道有这个东西，以后再来查就行啦。感觉写博客还是很好的。写完这两篇文章，基本上自己的思路就清楚了。以后再遇到问题就来这里面看就好啦。再次感谢廖雪峰老师的文章。","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"Git 基础知识重新梳理","slug":"Git-基础知识重新梳理","date":"2016-09-20T15:18:31.000Z","updated":"2016-12-12T02:51:54.000Z","comments":true,"path":"2016/09/20/Git-基础知识重新梳理/","link":"","permalink":"http://sevencai.github.io/2016/09/20/Git-基础知识重新梳理/","excerpt":"","text":"以前在学校的时候用git基本上就那几个命令，一般是用于push到github上做备份。比较容易，最近涉及到了git的一些别的用途，多人合作，创建分支等，发现自己有些命令还是不熟悉，需要老是查文档，所以重头开始学习，并做记录方便以后查阅，下面是我的整理。 Git的优点集中式 vs 分布式集中式版本控制系统，版本库是集中存放在中央服务器，必须联网工作。因此如果是局域网带宽大，尚可。如果是在互联网上，可能会导致花费时间长。 分布式版本控制系统，每个人电脑里都有完整的版本库， 安全性高，一个人电脑坏了，可以复制别的人的即可。不需要联网工作。a和b改了相同的文件，互相推送到对方的电脑，就可以看到修改的内容。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 –from 廖雪峰的git网站 那这个时候有人会问，包括我自己最开始也觉得奇怪： 分布式的版本控系统如果要在多个人之间协作不也是需要一个像github一样的的远程版本库吗，这与集中式的有什么区别呢？ 区别在于，Git不仅包含代码库还包含了历史库，你每一次clone代码都是一个完整的和中央仓库一模一样的库。意味着你本地与中央仓库一样都有所有的提交修改记录。而SVN的只有代码库是在本地，其历史库实在中央仓库，因此每次当我们提交和比对代码的时候都要连接中央仓库才可以。这也是我们为什么说Git不需要联网的一个原因。 所以主要差别就在于历史版本维护的位置。一句话总结就是：分布式版本控制的每个节点都是完整仓库。这里的每个节点就是我们的终端的意思。 Git 原理-工作区和暂存区有过一点点认识的童鞋都知道一些基本操作，比如 git add , git commit 为什么我们不一次性进行 commit 操作，反而要执行这么多步呢？ 所以我们一定要了解 Git 工作原理，才能够理解下面的命令的一些意思。 上面这张图中，我们可以认识到： 工作区可以当成你写代码的地方。 在你通过 git init 命令之后，会在你的文件夹下生成一个 .git 文件，这个我们称之为 git 的版本库。 它不算做工作区，在这个版本库里又包括两个部分，第一个是暂存区 Stage ，第二个是 Git 为我们自动创建的第一个分支 master ，以及指向 master 的一个指针叫 HEAD 。我们一般不要去动这个 .git 文件，否则可能破坏我们的版本库。 那么当我们通过 git add 的时候，其实是把工作区的更改，提交到了暂存区 stage, 然后我们再通过 git commit 提交到 master 主分支。 通过下面一张图，我们可以看的更清楚。 仓库/版本库-Repository创建版本库如何创建版本库？ //初始化一个git仓库 git init //添加文件到git仓库,可多次使用 git add &lt;file1&gt; git add &lt;file2&gt; git commit -m &quot;说明&quot; //掌握仓库当前的状态 git status //查看修改内容 git diff &lt;file1&gt; //提交日志 git log (--pretty=oneline) -m 后面输入的是本次提交的说明,最好有意义。通过 commit 我们可以一次提交很多文件，所以可以 add 多次。 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 – from 廖雪峰的git网站 版本回退上面提到了可以使用 git log 来查看提交日志，我们可以看到 上面的 commit 后面有一串用 sha1 计算出来的串，就是 commit_id 了。通过这 样一个个 commit_id 就可以看出我们提交历史的一条线了。那如果我们要回退版本怎么办呢？ 首先 Git 肯定要知道你要回退到哪个版本，很明显，我们不可能再去根据写 commit_id 来判断，因为这个很长的一串让我们重复是很费脑子的事情。 在 Git 中，我们使用 HEAD 来表示当前的版本， 也就是上面图片里看到的 13d436c4a928e3db2bfd08e15c9a8ce06780da91 这个。 那么上一个版本我们可以使用 HEAD^ , 上上一个用 HEAD^^, 第一百个就是 HEAD~100 。 具体的回退的命令，我们使用 git reset。 1git reset --hard HEAD^ 但是此时我们再往前看， 刚刚第一个 HEAD 版本已经不在了， 这可咋办？ 如果我们没有关闭刚刚 git log 的窗口， 是可以的。 //版本号不用写全，git会自动去找 git reset --hard 13d436c4a... 那如果我关闭了呢？ Git 提供了一个命令记录你的每一次命令. git reflog git reset --hard commit_id 这下我们再在 git reflog 里面查看，就可以看到第一个版本的 commit_id了，然后我们再用 reset 命令即可。 这里我们看到一个现象， 我们使用 git reset 做版本回退的时候，速度非常快，这是为什么呢？ 因为 Git 在内部有个指向当前版本的HEAD指针，当你回退版本的时候， Git 仅仅是把 HEAD 从指向 了新的 commit_id 并将工作区的文件更新。 撤销修改可能有下面几种情形： 修改了工作区的内容，但是并没有使用 git add 添加到暂存区， 可以使用 git checkout -- file 。这样就直接丢弃工作区的修改。这种情况使用 git status 会看到下面的提示（not staged）的： 123# Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)# (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) 不但修改了工作区的文件，而且还使用 git add 添加到了暂存区，如果想要丢弃更改两步走。第一步用命令git reset HEAD file，就回到了第一种情况，第二步按第一种情况来操作。 git reset HEAD file git checkout –file 这种情况使用 git status 会看到下面的提示(to be committed)的： # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) 如果已经 git commit 了，也就是已经提交到了 master 分支上，那么应该庆幸还没有 push 到远程，这时候我们利用我们上面一个小节提到的撤销版本即可。 如果已经 push 了的话，就没办法喽 。。 1git reset --hard HEAD^ 删除文件如果我们执行下面的操作： git add test.txt git commit -m &quot;add test.txt&quot; rm test.txt 意思比较明白，就是我们将 test.txt 添加到了 master 分支，但是我们后来不想要这个文件，就删除了。于是你利用 git status 就会发现如下的信息： # Changes not staged for commit: # (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # deleted: test.txt # 告诉我们已经删除了 test.txt ，要做修改了。我们可以用下面的命令来改变我们的更改： git add test.txt git rm test.txt git commit -m &quot;delete test.txt&quot; 那如果我们执行了 rm test.txt 之后，发现我们实际还是想要这个文件的怎么办呢？ 没关系，因为我们版本库里面确实是有这个文件的啊。所以我们利用： git checkout -- test.txt 即可恢复到我们最新版本了。git checkout 非常好用，注意一定要加 -- 因为如果不加就是切换分支了。它其实就是利用版本库里面的版本替换工作区的版本，这样不管是添加，修改，删除都可以瞬间恢复。 Git 远程操作关联并向远程推送分支通过以下命令，我们可以关联本地库和远程库并且推送分支。 //关联库 git remote add origin git@server-name:path/repo-name.git //将本地分支 master 推送到远程分支 git push -u origin master 注意，这里的 orgin 代表的就是远程仓库的名字， Git 默认这么做，如果改成别的当然也是可以的啦。 然后就是这里的 -u 是什么意思呢？ 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。–from 廖雪峰 好，那我们以后如果再推送还要做写什么呢？ git push origin master 以后每次推送就用这个就可以了。就不需要做 remote add 了。 这里要强调一下，有很多人都是看着这么用，就这么用了，但是不知道 origin master 分别代表的什么意思，就导致以后比如我要把本地的 develope 分支和远程的 master 分支推送怎么写呢？所以强调如下： 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。如果不同名字，我们可以用下面的命令使之关联 1git branch --set-upstream master origin/next 上面命令指定 master 分支追踪 origin/next 分支。 1git push origin master 上面的简写命令就表示的是：将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 千万要注意的是，上面的命令是省略了远程分支名，这是因为一般我们可以认为远程分支和本地分支名相同的原因。那如果我们省略了本地分支名呢？ //删除 origin 主机上的 master 分支 git push origin :master # 等同于 git push origin --delete master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。是不是很可怕。。所以一定要注意了。你还可能见过下面三种用法： //将当前分支推送到origin主机的对应分支 git push origin git push git push -u origin master git push --all origin git push --force origin git push origin 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 git push 如果当前分支只有一个追踪分支，那么主机名都可以省略。 git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。(此命令表示将master分支推送到origin主机的master分支，同时指定了 orgin 为默认分支，以后可以直接使用 git push 了。) git push --all origin 表示将所有本地分支都推送到origin主机。如果你远程主机上的版本比本地的要新，你可以使用 git push --force origin 这样导致远程主机上更新的版本被覆盖。所以要慎用。 git clone/pull/fetch/remote刚刚讲了最重要的 git push 我们下面来看看稍微简单一点的 其他命令。 git clone12git clone &lt;版本库的网址&gt;git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 后面的网址有很多情况，比如以 http, https, ssh, ftp等等。其中 Git 协议的下载速度会稍微快一些，然后 SSH就是要认证了。 git clone https://github.com/Christine95/Blog.git git clone git@github.com:Christine95/Blog.git git clone git@github.com:Christine95/Blog.git myBlog git clone -o Blog https://github.com/Christine95/Blog.git 如果不指定后面的本地目录名(myBlog)的话，就是与远程库相同的名字。 如果不指定 -o 选项，我们通过 git remote -v 查询时，就是名字默认为 origin, 指定就是刚刚的 Blog 啦。 git remote//只有名字 git remote //有名字有路径 git remote -v //远程主机详情 git remote show &lt;主机名&gt; //添加远程主机 git remote add &lt;主机名&gt; &lt;网址&gt; //删除远程主机 git remote rm &lt;主机名&gt; //重命名 git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 我感觉这个就没啥说的了。经常用就好了。 git fetch当我们远程主机有了更新后，可以使用 git fetch 取回这些更新至本地。 12git fetchgit fetch &lt;远程主机名&gt; &lt;分支名&gt; git fetch 表示将某个远程主机的更新，全部取回本地。git fetch origin develope 表示只更新远程主机的 develope 分支。 注意：取回了更新后，必须用”远程主机名/分支名”的形式读取。如我们上面的例子，就必须用 origin/develope 读取。比如： git branch -r //会得到类似： origin/HEAD -&gt; origin/master origin/develope origin/html origin/master origin/test_d002 git branch -a //会得到类似： remotes/origin/HEAD -&gt; origin/master remotes/origin/develope remotes/origin/html remotes/origin/master remotes/origin/test_d002 git branch 命令的 -r 选项，可以用来查看远程分支，-a 选项查看所有分支。这里注意： git pull = git fetch + git merge git pull1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 注意不要和 git push 的&lt;本地&gt;:&lt;远程&gt; 弄混淆了。有例子如下： //将orgin主机上的next分支取回并和本地master分支合并 git pull origin next:master //将origin主机的next分支取回并和当前分支合并 git pull origin next //上面一句命令等于下面两条命令 git fetch origin git merge origin/next 有一个地方需要注意： 当我们使用某些命令的时候，Git会自动在本地分支和远程分支之间，建立一种追踪关系，也就是说关联起来啦。比如你使用 git clone 的时候，会默认将远程主机和本地分支建立相同的名字。比如你克隆的是远程的 develope 分支，那么你本地克隆下来也会是 develope 分支，然后自动追踪 origin/develope分支。 但是，比如说有这样一种情况，我就遇到过，同事让我看一个项目，我很自然的去 clone master 分支了。这个时候发现 master 分支并不对，我应该去 clone develope 分支的。因为同事有些代码在 develope 分支上，不再 master 分支上。这个时候，我当然可以去利用 git pull origin develope master，但是为了方便，我最好这么做： 1git branch --set-upstream master origin/develope 这样就把本地的 master 分支和远程的 develope 分支关联啦。这样我们就可以用：1git pull origin 来 pull 代码啦。这样连主机名都省略了。只用告诉从那个远程主机 pull 就可以。 总结本来想这一篇文章能总结完的，结果连分支管理都没讲完。还是决定下一篇文章再将啦。要不然篇幅太长，就不适合阅读了。感谢下面两篇文章，让我清晰了很多，也准备小额资助感谢下廖雪峰老师的网站啦，毕竟是花心血写这么好的教程： 廖雪峰的git教程 阮一峰的git文章 最后贴一张阮一峰老师这个文字里的一幅图，我觉得太棒了。","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"fis3基本用法介绍","slug":"fis3基本用法介绍","date":"2016-08-24T08:21:08.000Z","updated":"2016-12-12T02:28:04.000Z","comments":true,"path":"2016/08/24/fis3基本用法介绍/","link":"","permalink":"http://sevencai.github.io/2016/08/24/fis3基本用法介绍/","excerpt":"","text":"今天有这样一个需求，其实是很常见的。一般我们公司都是静态资源放在一个机器上，比如是cdn上。然后内容页面放在另外一个机器上。这样很好的一点是cdn可以做缓存。而且整个分离看起来也比较清楚。 在本地，我用的相对路径比如./images/1.png 或者绝对路径 images/1.png 。这样写第一不统一。第二，我需要把图片，js，css放到cdn上，比如说是：**.qq.com上。但是页面又是在另外一个机器上，或者说域名下，所以很明显这个时候不能用相对路径了，只能用url的形式。 那么，我要怎么去改呢？难道手工一个个的去改？那不是很麻烦，而且应该想到公司那么多人，肯定不是用的这种笨一点的方法。一般有用gulp的，有用webpack的。今天我在师傅的建议下去学习了fis的。fis用很少量的配置，就完成了我需要的功能。唯一一点我觉得不好的，就是文档了，文档要是写的更好一点，接地气一点就更好啦。 FIS简介 FIS3 是面向前端的工程构建工具。解决前端工程中性能优化、资源加载（异步、同步、按需、预加载、依赖管理、合并、内嵌）、模块化开发、自动化工具、开发规范、代码部署等问题。 FIS是百度出品的，一般的gulp有的功能，它基本都有。下面有几个fis的几个特点： FIS3 的构建不会修改源码，而是会通过用户设置，将构建结果输出到指定的目录。 文件指纹，唯一标识一个文件。在开启强缓存的情况下，如果文件的 URL 不发生变化，无法刷新浏览器缓存。一般都需要通过一些手段来强刷缓存，一种方式是添加时间戳，每次上线更新文件，给这个资源文件的 URL 添加上时间戳。 CssSprite图片合并压缩了静态资源，我们还可以对图片进行合并，来减少请求数量。FIS3 提供了比较简易、使用方便的图片合并工具。通过配置即可调用此工具并对资源进行合并。FIS3 构建会对 CSS 中，路径带 ?__sprite 的图片进行合并。为了节省编译的时间，分配到 useSprite: true 的 CSS 文件才会被处理。 其实这些功能其它的几种方案应该都有，但是fis会更加方便。第一个深深的吸引着我。不改变源码真是太好了。具体原因下文分析。 FIS初识安装安装必须在全局环境下：123npm install -g fis3 //安装fis3 -v //查看npm update -g fis3 //升级 完整例子12touch fis-conf.js //生成默认配置文件fis3 release -d ../output //构建到上级目录下 ../output可以换成任意path 简单的对比下output和源文件中的内容，可以发现不同，资源路径已经被换了。可以利用diffmerge工具来看。下面来自文档中的一个图片。 我们可以很明显看到相对路径已经被替换成了绝对路径。再加深一点，如何压缩js,css呢？我们只需要调用它内置的插件就可以了。 fis通过正则匹配文件。 123456789101112131415/ 清除其他配置，只保留如下配置fis.match('*.js', &#123; // fis-optimizer-uglify-js 插件进行压缩，已内置 optimizer: fis.plugin('uglify-js')&#125;);fis.match('*.css', &#123; // fis-optimizer-clean-css 插件进行压缩，已内置 optimizer: fis.plugin('clean-css')&#125;);fis.match('*.png', &#123; // fis-optimizer-png-compressor 插件进行压缩，已内置 optimizer: fis.plugin('png-compressor')&#125;); 那么怎么解决我们开头说的那个问题呢？很简单，我们加一个release和url： 12345678910111213141516171819fis.match('*', &#123; useHash: false&#125;);// 所有的 jsfis.match('js/*.js', &#123; //发布到/static/js/xxx目录下 optimizer: fis.plugin('uglify-js'), release : '/dist/$0', url : '//midas.gtimg.cn/**/dist$0'&#125;);// 所有的 cssfis.match('css/*.css', &#123; //发布到/static/css/xxx目录下 optimizer: fis.plugin('clean-css'), release : '/dist/$0', url : '//midas.gtimg.cn/**/dist$0'&#125;); 先压缩，在发布到某个dist下去，然后真正发布的时候用某个url替换。这个url就可以换成我们的cdn上的链接。然后我们把压缩后的dist文件对应上传到cdn上去就可以了。 我们看下最后的结果是不是跟我们想的一样： :) 是不是很简单的配置就完成了？这里可以留一个思考的地方，就是你会发现上面替换都是替换html里面的，那如果css/js里面也有路径要替换，打比方css里面引入了图片路径怎么破呢？ FIS其他功能刚刚是已一个简单的例子，告诉我们fis的工作很简单的配置就可以完成了。现在我们看看fis还能干什么。 压缩文件,图片（资源） 重定向文件目录和url 刚刚已经说了上面，下面我们看看还有什么功能： 文件指纹 文件指纹，唯一标识一个文件。在开启强缓存的情况下，如果文件的 URL 不发生变化，无法刷新浏览器缓存。一般都需要通过一些手段来强刷缓存，一种方式是添加时间戳，每次上线更新文件，给这个资源文件的 URL 添加上时间戳。 FIS3 选择的是添加 MD5 戳，直接修改文件的 URL，而不是在其后添加 query。 对 js、css、png 图片引用 URL 添加 md5 戳，配置如下 12345678910//一般方法&lt;img src=\"a.png?t=12012121\"&gt;//清除其他配置，只剩下如下配置 fis.match('*.&#123;js,css,png&#125;', &#123; useHash: true&#125;);//执行输出fis3 release -d ../output CssSprite图片合并 压缩了静态资源，我们还可以对图片进行合并，来减少请求数量。 FIS3 提供了比较简易、使用方便的图片合并工具。通过配置即可调用此工具并对资源进行合并。 FIS3 构建会对 CSS 中，路径带 ?__sprite 的图片进行合并。为了节省编译的时间，分配到 useSprite: true 的 CSS 文件才会被处理。 在上一张对比图片里面是不是有一个多余的style开头的png,那个就是图片合并后的两个文件： 因为我们在css里面：1234567li.list-1::before &#123; background-image: url('./img/list-1.png?__sprite');&#125;li.list-2::before &#123; background-image: url('./img/list-2.png?__sprite');&#125; 设置了两个以?__sprite的图片，所以他们会合并了。好方便。当然不以这个结尾的肯定不会合并了。合并的好处当然就是减少请求数量。当然了，fis会自动帮你把精灵图重新定位。所以你会发现你的css会多了下面这些代码：12345content:\"\";position:absolute;height:15px;width:15px;left:-15px 关闭默认配置、查看文件属性这个时候我们利用重要的指令fis3 inspect可以查看文件分配到的属性，这些属性决定了文件将如何被编译处理。1fis3 inspect //查看文件命中属性的情况 因为有一些功能是默认开启了，所以我们可以利用开启debug模式，关闭这些： 12345fis.media('debug').match('*.&#123;js,css,png&#125;', &#123; useHash: false, useSprite: false, optimizer: null&#125;) fis3 release debug 启用 media debug 的配置，覆盖上面的配置，把诸多功能关掉。 调试FIS3 构建后，默认情况下会对资源的 URL 进行修改，改成绝对路径。这时候本地双击打开文件是无法正常工作的。这给开发调试带来了绝大的困惑。 FIS3 内置一个简易 Web Server，可以方便调试构建结果。12345678910111213//构建时不指定输出目录，即不指定 -d 参数时，构建结果被发送到内置 Web Server 的根目录下。此目录可以通过执行以下命令打开。fis3 server open//不加 -d 参数默认被发布到内置 Web Server的根目录下，当启动服务时访问此目录下的资源。fis3 release//启动本地 Web Server访问http://127.0.0.1:8080fis3 server start//FIS3 支持文件监听fis3 release -w//浏览器自动刷新fis3 release -wL 总结上面的内容只是一小部分功能，还有很多其他的功能，比如嵌入资源（import等等），定位资源（从html,css,js中定位分离资源），部署到服务器上，声明依赖能力等等功能。","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"几种清除多余CSS的方法和基本原理","slug":"几种清除多余CSS的方法和基本原理","date":"2016-08-23T13:09:19.000Z","updated":"2016-12-12T03:01:40.000Z","comments":true,"path":"2016/08/23/几种清除多余CSS的方法和基本原理/","link":"","permalink":"http://sevencai.github.io/2016/08/23/几种清除多余CSS的方法和基本原理/","excerpt":"","text":"最近遇到一个坑，重构给了重构代码，但是没有分离好，导致我引入了很多无用的css。这些css又引入了很多无用的图片，使整个的非常重而且很无用。我需要想办法把整个无用css都去掉。下面是几种方法。 gulp-uncssgulp-uncss是一个gulp插件，和普通gulp插件没有区别。先引入gulp。然后利用uncss方法传入需要优化的css所在的页面。注意这里支持本地文件，正则匹配和url匹配。 12345678910var gulp = require('gulp');var uncss = require('gulp-uncss');gulp.task('default', function () &#123; return gulp.src('site.css') .pipe(uncss(&#123; html: ['index.html', 'posts/**/*.html', 'http://example.com'] &#125;)) .pipe(gulp.dest('./out'));&#125;); 当然，也可以和其他插件一起用。如下： 12345678910111213141516var gulp = require('gulp');var uncss = require('gulp-uncss');var sass = require('gulp-sass');var concat = require('gulp-concat');var nano = require('gulp-cssnano');gulp.task('default', function () &#123; return gulp.src('styles/**/*.scss') .pipe(sass()) .pipe(concat('main.css')) .pipe(uncss(&#123; html: ['index.html', 'posts/**/*.html', 'http://example.com'] &#125;)) .pipe(nano()) .pipe(gulp.dest('./out'));&#125;); 我觉得很方便，最后项目里就是采用的这个方法。 chrome浏览器audits利用chrome的自带审计功能。打开chrome浏览器，然后点击Audits审计功能。然后点击run,就可以分析出咱们这个页面可以优化的地方了。 但是这有一个缺陷，就是它只能找到你的有多少样式是不需要的，不能够自动把清理后的css给你。你还是需要手动去你的文件里对比，然后删除。对于比较少的可以这么用。要是本来就有很多很多无用的，那么就很不好使了。这个时候，火狐出来了。 firefox浏览器css usage下载css usage这个火狐插件并安装，地址在 https://addons.mozilla.org/en-US/firefox/addon/css-usage/。然后f12,切到CSS Usage 选项卡点击 scan 按钮，稍后会分析出哪些css规则未使用。然后点击 export cleaned css 按钮，导出清理好的css文件，将在新页面打开新的css源文件。即可。是不是很方便。步骤是(Scan-&gt;Clear-&gt;AutoScan)。 Scan: 通过字面意思我们就能知道,这是一个扫描当前页面的工具,如果我们的站点只有一个页面或者几个页面,我们可以通过使用此功能按键来查看页面的css实用情况. Clear: 清除扫描结果,但我们查看完网页,并对CSS 进行了修改后,我们就不需要以前的扫描结果了,那么我们就可以使用Clear功能键,清除以前的扫描结果缓存,重新开始我们的扫描. AutoScan: 我们的网站可能会有很多的页面,更有可能有很多的弹出层,如果我们每次都点击扫描的话,会占用我们大量的时间,AutoScan功能键可以使我们的扫描工作更自动化,提高我们的工作效率. tidycss-nodejs插件 经常看到有童鞋问，有没有什么工具能快速分析出站点的CSS冗余，于是就有了这个项目。本质上，这个工具是为了解决我们 腾讯课堂 在多人开发与快速迭代下的CSS冗余问题，为代码Review提供可行的工具。-from tidycss github install tidycss后，使用nodejs运行，之后并会生成报表。基本原理思想跟上面几个都差不多。源码也是利用selector。1234567891011121314var tidy = require('tidycss');tidy( // 你要检测冗余的url 'http://ke.qq.com', // 可选参数 &#123; // 不对common.xxxx.css检测冗余，因为这个是站点公共文件 ignore: /common\\..*\\.css/, // 忽略的选择器列表, 即这里的选择器是被review后可冗余项， // 比如有通过javascript动态生成的DOM树 unchecks: ['.mod-nav__course-all span:hover'] &#125;); 可能的坑这中间可能就是要尽量的把用到的css功能都拉出来。比如有一个模块，是我点击按钮才能出现列表。那么如果你不点击按钮，这些插件就获取不到列表这些css对应的dom，也就会认为这些css选择器是无用的。就会把这些选择器给删掉。那么真正的你是缺少这些css的。这个可能结合后面基本原理理解会更清楚。 基本原理那么这些工具是如何做到识别没有使用过的css呢？ 一个 css 选择器是无效的，也就是说我们是无法通过这个css选择器找到dom元素。所以，我们可以使用querySelector判断改css选择器对应的dom是否为空。从而知道哪些是没有使用的。 其实上面这个gulp的插件gulp-uncss是利用的另外一个别人写好的模块uncss,只不过把它打包成了gulp的插件格式。 我去看了下它的（uncss）源码，基本上就是上面那个思想，找出unused的selector,找出used过了的selector。然后看了下别人写的代码，就觉得还要好好努力，差的太多。下面放出核心代码，方便以后我经常学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244'use strict';var promise = require('bluebird'), phantom = require('./phantom.js'), postcss = require('postcss'), _ = require('lodash'); /* Some styles are applied only with user interaction, and therefore its * selectors cannot be used with querySelectorAll. * http://www.w3.org/TR/2001/CR-css3-selectors-20011113/ */var dePseudify = (function () &#123; var ignoredPseudos = [ /* link */ ':link', ':visited', /* user action */ ':hover', ':active', ':focus', /* UI element states */ ':enabled', ':disabled', ':checked', ':indeterminate', /* pseudo elements */ '::first-line', '::first-letter', '::selection', '::before', '::after', /* pseudo classes */ ':target', /* CSS2 pseudo elements */ ':before', ':after', /* Vendor-specific pseudo-elements: * https://developer.mozilla.org/ja/docs/Glossary/Vendor_Prefix */ '::?-(?:moz|ms|webkit|o)-[a-z0-9-]+' ], pseudosRegex = new RegExp(ignoredPseudos.join('|'), 'g'); return function (selector) &#123; return selector.replace(pseudosRegex, ''); &#125;;&#125;());/** * Private function used in filterUnusedRules. * @param &#123;Array&#125; selectors CSS selectors created by the CSS parser * @param &#123;Array&#125; ignore List of selectors to be ignored * @param &#123;Array&#125; usedSelectors List of Selectors found in the PhantomJS pages * @return &#123;Array&#125; The selectors matched in the DOMs */function filterUnusedSelectors(selectors, ignore, usedSelectors) &#123; /* There are some selectors not supported for matching, like * :before, :after * They should be removed only if the parent is not found. * Example: '.clearfix:before' should be removed only if there * is no '.clearfix' */ return selectors.filter(function (selector) &#123; selector = dePseudify(selector); /* TODO: process @-rules */ if (selector[0] === '@') &#123; return true; &#125; for (var i = 0, len = ignore.length; i &lt; len; ++i) &#123; if (_.isRegExp(ignore[i]) &amp;&amp; ignore[i].test(selector)) &#123; return true; &#125; if (ignore[i] === selector) &#123; return true; &#125; &#125; return usedSelectors.indexOf(selector) !== -1; &#125;);&#125;/** * Find which animations are used * @param &#123;Object&#125; css The postcss.Root node * @return &#123;Array&#125; */function getUsedAnimations(css) &#123; var usedAnimations = []; css.walkDecls(function (decl) &#123; if (_.endsWith(decl.prop, 'animation-name')) &#123; /* Multiple animations, separated by comma */ usedAnimations.push.apply(usedAnimations, postcss.list.comma(decl.value)); &#125; else if (_.endsWith(decl.prop, 'animation')) &#123; /* Support multiple animations */ postcss.list.comma(decl.value).forEach(function (anim) &#123; /* If declared as animation, it should be in the form 'name Xs etc..' */ usedAnimations.push(postcss.list.space(anim)[0]); &#125;); &#125; &#125;); return usedAnimations;&#125;/** * Filter @keyframes that are not used * @param &#123;Object&#125; css The postcss.Root node * @param &#123;Array&#125; animations * @param &#123;Array&#125; unusedRules * @return &#123;Array&#125; */function filterKeyframes(css, animations, unusedRules) &#123; css.walkAtRules(/keyframes$/, function (atRule) &#123; if (animations.indexOf(atRule.params) === -1) &#123; unusedRules.push(atRule); atRule.remove(); &#125; &#125;);&#125;/** * Filter rules with no selectors remaining * @param &#123;Object&#125; css The postcss.Root node * @return &#123;Array&#125; */function filterEmptyAtRules(css) &#123; /* Filter media queries with no remaining rules */ css.walkAtRules(function (atRule) &#123; if (atRule.name === 'media' &amp;&amp; atRule.nodes.length === 0) &#123; atRule.remove(); &#125; &#125;);&#125;/** * Find which selectors are used in &#123;pages&#125; * @param &#123;Array&#125; pages List of PhantomJS pages * @param &#123;Object&#125; css The postcss.Root node * @return &#123;promise&#125; */function getUsedSelectors(page, css) &#123; var usedSelectors = []; css.walkRules(function (rule) &#123; usedSelectors = _.concat(usedSelectors, rule.selectors.map(dePseudify)); &#125;); // TODO: Can this be written in a more straightforward fashion? return promise.map(usedSelectors, function (selector) &#123; return selector; &#125;).then(function(selector) &#123; return phantom.findAll(page, selector); &#125;);&#125;/** * Get all the selectors mentioned in &#123;css&#125; * @param &#123;Object&#125; css The postcss.Root node * @return &#123;Array&#125; */function getAllSelectors(css) &#123; var selectors = []; css.walkRules(function (rule) &#123; selectors = _.concat(selectors, rule.selector); &#125;); return selectors;&#125;/** * Remove css rules not used in the dom * @param &#123;Array&#125; pages List of PhantomJS pages * @param &#123;Object&#125; css The postcss.Root node * @param &#123;Array&#125; ignore List of selectors to be ignored * @param &#123;Array&#125; usedSelectors List of selectors that are found in &#123;pages&#125; * @return &#123;Object&#125; A css_parse-compatible stylesheet */function filterUnusedRules(pages, css, ignore, usedSelectors) &#123; var ignoreNextRule = false, unusedRules = [], unusedRuleSelectors, usedRuleSelectors; /* Rule format: * &#123; selectors: [ '...', '...' ], * declarations: [ &#123; property: '...', value: '...' &#125; ] * &#125;,. * Two steps: filter the unused selectors for each rule, * filter the rules with no selectors */ ignoreNextRule = false; css.walk(function (rule) &#123; if (rule.type === 'comment') &#123; // ignore next rule while using comment `/* uncss:ignore */` if (/^!?\\s?uncss:ignore\\s?$/.test(rule.text)) &#123; ignoreNextRule = true; &#125; &#125; else if (rule.type === 'rule') &#123; if (rule.parent.type === 'atrule' &amp;&amp; _.endsWith(rule.parent.name, 'keyframes')) &#123; // Don't remove animation keyframes that have selector names of '30%' or 'to' return; &#125; if (ignoreNextRule) &#123; ignoreNextRule = false; ignore = ignore.concat(rule.selectors); &#125; usedRuleSelectors = filterUnusedSelectors( rule.selectors, ignore, usedSelectors ); unusedRuleSelectors = rule.selectors.filter(function (selector) &#123; return usedRuleSelectors.indexOf(selector) &lt; 0; &#125;); if (unusedRuleSelectors &amp;&amp; unusedRuleSelectors.length) &#123; unusedRules.push(&#123; type: 'rule', selectors: unusedRuleSelectors, position: rule.source &#125;); &#125; if (usedRuleSelectors.length === 0) &#123; rule.remove(); &#125; else &#123; rule.selectors = usedRuleSelectors; &#125; &#125; &#125;); /* Filter the @media rules with no rules */ filterEmptyAtRules(css); /* Filter unused @keyframes */ filterKeyframes(css, getUsedAnimations(css), unusedRules); return css;&#125;/** * Main exposed function * @param &#123;Array&#125; pages List of PhantomJS pages * @param &#123;Object&#125; css The postcss.Root node * @param &#123;Array&#125; ignore List of selectors to be ignored * @return &#123;promise&#125; */module.exports = function uncss(pages, css, ignore) &#123; return promise.map(pages, function (page) &#123; return getUsedSelectors(page, css); &#125;).then(function (usedSelectors) &#123; usedSelectors = _.flatten(usedSelectors); var filteredCss = filterUnusedRules(pages, css, ignore, usedSelectors); var allSelectors = getAllSelectors(css); return [filteredCss, &#123; /* Get the selectors for the report */ all: allSelectors, unused: _.difference(allSelectors, usedSelectors), used: usedSelectors &#125;]; &#125;);&#125;; 总结所以，如果是只是要一个整理后的文件，就用火狐就好。如果是工程化项目，用gulp的插件比较好。主要是整理了几种方法。中间也学到了不少东西，比如审计audits以前就没有关注过。现在知道是分析页面性能的一个好方法了。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"ECMAScript2015 对象扩展","slug":"ECMAScript2015-对象扩展","date":"2016-08-19T13:34:22.000Z","updated":"2017-01-17T12:28:49.000Z","comments":true,"path":"2016/08/19/ECMAScript2015-对象扩展/","link":"","permalink":"http://sevencai.github.io/2016/08/19/ECMAScript2015-对象扩展/","excerpt":"","text":"上篇文章学习和记录了Object.defineProperty的用法，主要是对属性的扩展定义。这次学习三个API，是关于对象操作的三个扩展。 分别是下面三对，具体来讲讲它们的区别和联系以及用法。 Object.freeze() / Object.isFrozen() Object.seal() / Object.isSealed() Object.preventExtensions() / Object.isExtensible Object.freeze() / Object.isFrozen()Object.freeze()是这三个里面最高级别。通过Object.freeze(obj)的obj，相当于已经冻结了：不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。 也就是说这个对象不可以变了。12345678var obj = &#123;a:1,b:2&#125;;obj.c = 3;Object.freeze(obj);obj.d = 4; //不会抛出异常obj.d //undefineddelete obj.c //false 上述我们可以看到，虽然obj被冻结了，但是我们在它上面修改属性的时候，仍然是可以的，只是不会得到正确的值，不抱错。这很明显会对我们整体的代码造成影响，以后排查错误也不方便。所以我们需要定义’use strict’，在严格模式下，就可以报错啦。12345'use strict'//TypeError: \"c\" is read-onlyobj.c = 0;Object.isFrozen(obj) //true 然后我们可以定义Object.isFrozen来判断是否该对象被冻结了。 Object.seal() / Object.isSealed()密封一个对象，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可以修改已有属性的值的对象。 所以在Object.freeze的基础上，就是可以修改自己已经有了的属性。但是还是不能删除和添加。 也不能修改已有属性的可枚举，可写等特性。 12345678910111213141516171819var obj = &#123;a:1, b:2&#125;;Object.seal(obj);Object.isSealed(obj); // trueobj.c = 3; //不抛出异常obj.c // undefineddelete obj.b // false//已有属性可以变更值obj.b = 3;obj.b //3//TypeError: can't define property \"[object Object]\": Object is not extensibleObject.defineProperty(obj,a,&#123; value : 'r', writable : true, configurable : true&#125;) 通过上面一些简单的例子，我们可以看到Object.freeze和Object.seal的区别了。Object.freeze更加严格，Object.seal相当于封装好了这个对象，不准多一个，也不准少一个，但是你可以在这个里面更改原来已有的。 Object.preventExtensions / Object.isExtensible阻止对象扩展，让一个对象变的不可扩展，也就是永远不能再添加新的属性。在没有这个之前，我们定义了一个对象，是可以进行无限制的扩展属性的。 1234567891011121314var obj = &#123;a:1, b:2&#125;;obj.c = 3; Object.preventExtensions(obj);obj.d = 4; // 不抛出异常obj.d // undefined，不能扩展属性Object.isExtensible(obj); // falseobj.a = 'a';obj.a // 'a',可以更改已有的属性delete obj.a //可以删除已有属性obj.a //删除后再添加也不行 总结三者有类似的作用，但是用法很不同。可以通过这些API，对对象再进行更严谨的控制。这样代码的健壮性更好了。也更容易让我们发现错误，多人合作的时候也更不容易出错。但一定要记得写严格模式的&#39;use strict&#39;哟。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"ECMAScript Object.defineProperty 属性描述符","slug":"ECMAScript-Object-defineProperty-属性描述符","date":"2016-08-19T11:14:08.000Z","updated":"2016-12-12T02:59:58.000Z","comments":true,"path":"2016/08/19/ECMAScript-Object-defineProperty-属性描述符/","link":"","permalink":"http://sevencai.github.io/2016/08/19/ECMAScript-Object-defineProperty-属性描述符/","excerpt":"","text":"ECMAScript 5 出了一个【属性描述符】，主要是为了【给属性增加更多的控制】。下面我们就谈论这样一个新的特性-Object.defineProperty()。 Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 语法定义 Object.defineProperty(obj, prop, descriptor) obj : 需要定义属性的对象 prop : 需被定义或修改的属性名 descriptor : 需被定义或修改的属性的描述符 为什么我们要用这个新特性？我们给对象创建属性有下面这样几种方法：12345678910var person = &#123;&#125;;//第一种方式person.name = 'Seven';//第二种方式person[name] = 'Seven';//第三种方式Object.defineProperty(person, 'name', &#123; value : 'Seven'&#125;)person.name //Seven 看起来好像最后一种新方法最麻烦，那我们为什么还要用最后一种方法呢？因为后面的descriptor可以让我们制定更多对对象属性的策略。 descriptor数据描述符-writable上面我们提到了更多策略，其实这个更多策略就是让属性可以更多不同的权限，比如让它只能读，不能写。 当属性特性（property attribute） writable 设置为false时，表示 non-writable，属性不能被修改。 12345678Object.defineProperty(person,'sex'&#123; value:'girl', writable:false&#125;)person.sex // 'girl'person.sex = 'boy'person.sex //girl 当我们设置了descriptor里面的writable为false的时候，这个sex就不可以更改了。虽然你可以设置，但是设置后结果还是girl不会变的。 有人会说，这样不是很不好吗？如果我们在不知情的情况下改写了，连报错都不报。会造成很多bug。很难排查出到底是哪里出了bug。 解决方法是写上use strict。这样就会报错了。 12345678// 定义严格模式'use strict';var obj = &#123; &#125;;Object.defineProperty(obj, 'attr', &#123; value: 1, writable: false&#125;);obj.attr = 2; // throw exception descriptor数据描述符-enumerable上面已经提到了一个writable,表示是否可写。现在在看一个数据描述符enumerable。 属性特性 enumerable 定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举。 123456789101112131415161718192021222324252627var o = &#123;&#125;;Object.defineProperty(o, \"a\", &#123; value : 1, enumerable:true&#125;);Object.defineProperty(o, \"b\", &#123; value : 2, enumerable:false&#125;);// enumerable defaults to falseObject.defineProperty(o, \"c\", &#123; value : 3&#125;);// 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为trueo.d = 4;for (var i in o) &#123; console.log(i);&#125;// 打印 'a' 和 'd' (in undefined order)Object.keys(o); // [\"a\", \"d\"]o.propertyIsEnumerable('a'); // trueo.propertyIsEnumerable('b'); // falseo.propertyIsEnumerable('c'); // false 相当于定义了enumerable后，enumerable可以将其“藏”起来，不被循环看见。 那么属性描述符可以修改吗？比如原来我设置了writable为false,我现在想改变了。那我可以更改吗？这就又有一个专门的属性描述符。 descriptor数据描述符-configurable 如果属性已经存在，Object.defineProperty()将尝试根据描述符中的值以及对象当前的配置来修改这个属性。如果描述符的 configurable 特性为false（即该特性为non-configurable），那么除了 writable 外，其他特性都不能被修改，并且数据和存取描述符也不能相互切换。 如果一个属性的 configurable 为 false，则其 writable 特性也只能修改为 false。 如果尝试修改 non-configurable 属性特性（除 writable 以外），将会产生一个TypeError 异常，除非当前值与修改值相同。 configurable 特性表示对象的属性是否可以被删除，以及除 writable 特性外的其他特性是否可以被修改。 12345678910var obj = &#123; &#125;;Object.defineProperty(obj, 'attr', &#123; value: 1, writable: false, configurable: true&#125;);Object.defineProperty(obj, 'attr', &#123; writable: true&#125;);obj.attr = 2; 因为configurable是true，所以writable可以更改。 123456789101112131415161718192021222324252627282930313233343536var o = &#123;&#125;;Object.defineProperty(o, \"a\", &#123; get : function()&#123;return 1;&#125;, configurable : false&#125; );//因为上面已经对a属性定义了configurable为false,所以下面的都是错误的// throws a TypeErrorObject.defineProperty(o, \"a\", &#123; configurable : true&#125;);// throws a TypeErrorObject.defineProperty(o, \"a\", &#123; enumerable : true&#125;);// throws a TypeError (set was undefined previously)Object.defineProperty(o, \"a\", &#123; set : function()&#123;&#125;&#125;);// throws a TypeError (even though the new get does exactly the same thing)Object.defineProperty(o, \"a\", &#123; get : function()&#123;return 1;&#125;&#125;);// throws a TypeErrorObject.defineProperty(o, \"a\", &#123; value : 12&#125;);console.log(o.a); // logs 1delete o.a; // Nothing happensconsole.log(o.a); // logs 1 存取描述符上面介绍的是数据描述符，现在介绍下存取描述符。 1234567var obj = &#123; &#125;;Object.defineProperty(obj, 'attr', &#123; set: function(val) &#123; this._attr = Math.max(0, val); &#125;, get: function() &#123; return this._attr; &#125;&#125;);obj.attr = -1;console.log(obj.attr); // 0 就是说我们可以利用get/set来对属性进行一定的控制和更改。我们最后通过obj.attr得到的值其实就是通过get返回的值。而我们通过obj.attr = value，设置的值其实就是set的值。 12345678910111213141516171819202122var pattern = &#123; get: function () &#123; return 'I alway return this string,whatever you have assigned'; &#125;, set: function () &#123; this.myname = 'this is my name string'; &#125;&#125;;function TestDefineSetAndGet() &#123; Object.defineProperty(this, 'myproperty', pattern);&#125;var instance = new TestDefineSetAndGet();instance.myproperty = 'test';// 'I alway return this string,whatever you have assigned'console.log(instance.myproperty);// 'this is my name string'console.log(instance.myname); 上面一个例子是从mdn上面学习到的，仔细看，如果能看明白，应该就能明白这个set/get的用法了。 获取对象描述符Object.getOwnPropertyDescriptor 可以帮助我们获得对象描述符。比如我们定义：1234567891011var obj = &#123;&#125;;Object.defineProperty(obj, attr, &#123; value : 'a', writable : false, configurable : true&#125;)var descriptor = Object.getOwnPropertyDescriptor(obj, attr);console.dir(descriptor); 结果是：{ value: &#39;a&#39;, writable: false, enumerable: false, configurable: true }。这是console.log 的结果。console.dir 会显示的很好看。 注意事项数据描述符和存取描述符不能混合使用,否则会报错：TypeError: property descriptors must not specify a value or be writable when a getter or setter has been specified。 123456Object.defineProperty(o, \"conflict\", &#123; value: 'a', get: function() &#123; return 'b'; &#125;&#125;); 定义多个属性123456789101112var obj = &#123;&#125;;Object.defineProperties(obj, &#123; \"property1\": &#123; value: true, writable: true &#125;, \"property2\": &#123; value: \"Hello\", writable: false &#125; // etc. etc.&#125;); 用途这一部分是我觉得最有价值的一部分了。是我在这篇文章里看到并学习的。感谢。可以优化对象获取和修改属性的方式。下面我就直接引用这个文章里的描述了。 这个优化对象获取和修改属性方式，是什么意思呢？ 过去我们在设置dom节点transform时是这样的。12345//加入有一个目标节点， 我们想设置其位移时是这样的var targetDom = document.getElementById('target');var transformText = 'translateX(' + 10 + 'px)';targetDom.style.webkitTransform = transformText;targetDom.style.transform = transformText; 通过上面，可以看到如果页面是需要许多动画时，我们这样编写transform属性是十分蛋疼的。 但如果通过Object.defineProperty， 我们则可以123456789101112131415//这里只是简单设置下translateX的属性，其他如scale等属性可自己去尝试Object.defineProperty(dom, 'translateX', &#123; set: function(value) &#123; var transformText = 'translateX(' + value + 'px)'; dom.style.webkitTransform = transformText; dom.style.transform = transformText; &#125;&#125;//这样再后面调用的时候, 十分简单dom.translateX = 10;dom.translateX = -10;//甚至可以拓展设置如scale, originX, translateZ,等各个属性，达到下面的效果dom.scale = 1.5; //放大1.5倍dom.originX = 5; //设置中心点X 总结主要就是学习了Object.defineProperty这个新的特性。先前知道这个，但是没有仔细去学习，最近在了解vue的时候，忽然感觉这个要好好学下了。因为这些MVVM大都是通过这个新特性来实现数据绑定的。当然angular不是的，angular是通过脏数据。下面推荐和感谢几篇文章： MDN-defineProperty es5-property-descriptors IMWEB-不会Object.defineProperty你就out了","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"用Nodejs进行文件上传-下载-浏览-横扫File-System-API","slug":"用Nodejs进行文件上传-下载-浏览-横扫File-System-API","date":"2016-08-10T13:36:49.000Z","updated":"2016-12-12T03:02:10.000Z","comments":true,"path":"2016/08/10/用Nodejs进行文件上传-下载-浏览-横扫File-System-API/","link":"","permalink":"http://sevencai.github.io/2016/08/10/用Nodejs进行文件上传-下载-浏览-横扫File-System-API/","excerpt":"","text":"以前知道用Nodejs进行上传下载是很容易的，用个formidable就可以了，也就没有去管它，然后昨天晚上有空，就写了个小demo，就发现了自己的一些问题。比如对File System的API不熟悉。用的时候还要去查。尤其是对createReadStream 和 writeReadStream这一类流处理不熟悉，下面是我的整理和学习。基本上是一个完整的demo,有上传，有下载，还有浏览文件。 上传下载关于formidable This module was developed for Transloadit, a service focused on uploading and encoding images and videos. It has been battle-tested against hundreds of GB of file uploads from a large variety of clients and is considered production-ready. 具体的一些用法，大家可以去这个上面去看,比较简单了。一个官网的小demo如下： 12345678910111213141516171819202122232425262728var formidable = require('formidable'), http = require('http'), util = require('util');http.createServer(function(req, res) &#123; if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; res.writeHead(200, &#123;'content-type': 'text/plain'&#125;); res.write('received upload:\\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; // show a file upload form res.writeHead(200, &#123;'content-type': 'text/html'&#125;); res.end( '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt;'+ '&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;'+ '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;'+ '&lt;input type=\"submit\" value=\"Upload\"&gt;'+ '&lt;/form&gt;' );&#125;).listen(8080); 这就基本已经完成上传的功能了。但是我们可以让它更丰富，我们下面加一下预览文件并下载的功能。这里面有几个小知识点先解释下： form上传的时候，必须是enctype=”multipart/form-data”这种格式，否则上传不了。 util.inspect是nodejs里面util模块的一个方法。它可以将任意对象转换 为字符串的方法。比如这里就是把fields里面和files两个对象合为一个对象，然后再转换为字符串。 util.inherits则是一个实现对象间原型继承 的函数。注意这个是只继承原型里面的。原来的属性和方法并不会被继承，也就是在function(){this里面生成的不会被继承}，并且继承过来的原型方法也不会被输出。 预览和下载大概做成以后是这个样子的。样子是不是很丑，确实不想管样式，咱们还是注重功能吧。点击upload可以上传文件，点击下面的文件可以直接下载到本地。注意这里要保证文件不重名，我利用的是date。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778\"use strict\";var formidable = require('formidable'), http = require('http'), util = require('util'), fs = require('fs'), path = require('path'), querystring = require('querystring'), url = require('url');http.createServer(function (req, res) &#123; var urlObj = url.parse(req.url); if (urlObj.pathname == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; var form = new formidable.IncomingForm(); form.encoding = 'utf-8'; form.uploadDir = \"dir/\"; form.maxFieldsSize = 2 * 1024 * 1024; form.keepExtensions = true; form.parse(req, function (err, fields, files) &#123; if (err) &#123; console.log(err); &#125; var name = files.upload.name; var ext = /\\.[^\\.]+$/.exec(name)[0]; var date = new Date(); fs.renameSync(files.upload.path, \"dir\\\\\" + Date.parse(date) + ext); res.writeHead(200, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;); res.write('received upload: \\n\\n'); res.end(util.inspect(&#123;fields: fields, files: files&#125;)); &#125;); return; &#125; if (urlObj.pathname == '/download') &#123; var query = urlObj.query; var name = querystring.parse(query).name; var downloadFilePath = \"./dir/\" + name; var filesize = fs.readFileSync(downloadFilePath).length; res.setHeader('Content-Disposition', 'attachment;filename=' + name);//此处是关键 res.setHeader('Content-Length', filesize); res.setHeader('Content-Type', 'application/octet-stream'); var fileStream = fs.createReadStream(downloadFilePath, &#123;bufferSize: 1024 * 1024&#125;); fileStream.pipe(res, &#123;end: true&#125;); return; &#125; function send(str) &#123; res.writeHead(200, &#123;'content-type': 'text/html'&#125;); res.end( '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt;' + '&lt;input type=\"text\" name=\"title\"&gt;&lt;br&gt;' + '&lt;input type=\"file\" name=\"upload\" multiple=\"multiple\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\" value=\"Upload\"&gt;' + '&lt;/form&gt;' + '&lt;br /&gt;&lt;br /&gt;' + str ); &#125; function respond() &#123; var str = \"\"; fs.readdir('dir/', function (err, files) &#123; if (err) return console.error(err); files.forEach(function (file) &#123; str += `&lt;a href='/download?name=$&#123;file&#125;'&gt;$&#123;file&#125;&lt;/a&gt;&lt;br /&gt;`; &#125;); send(str); &#125;); &#125; respond();&#125;).listen(8080); 看代码应该很清楚了，我们这里调用了一个readdir，然后遍历里面的图片，拿到图片的名称，然后当点击的时候，发起请求到download，并传递自己的name,收到以后，我们找到这个图片，然后设置下载需要的相应头就行了。注意下载里面的setHeader是重点。设置的类型是Disposition。 记录一个我犯的错误，成功以后，发现显示信息一直是乱码，我检查了文件都已经被设置成了utf-8,也设置了相应头writehead是utf-8为什么还乱码呢？后来检查，是{‘Content-Type’: ‘text/plain;charset=utf-8’}这里的charset前面的分号写成了逗号，也是无奈，都怪自己粗心。谨记。 下面就开始把其他的关于file的api给梳理一下了。 File System ApicreateReadStream &amp;&amp; createWriteStream一般情况下，我们可以用这两个API来拷贝文件。nodejs文件操作里面没有直接来copy文件的方法。我们可以先用最开始我们的方法，比如：12var source = fs.readFileSync('source', &#123;encoding: 'utf8'&#125;);fs.writeFileSync('destination', source); 但这容易产生一个问题。因为这种方式是一次性把文件的内容全部读进内存里面，一般小一点的文本文件问题不大，但如果是很大的文件，比如音频视频，一般几个G的，这种。就容易使内存爆仓。这个时候我们流的读写方式就很好了。我们可以先读一会，再写一会。123456789101112\"use strict\";var rs = fs.createReadStream('tmp/7.js');var ws = fs.createWriteStream('tmp/9.js');rs.on('data', function(data)&#123; ws.write(data);&#125;);rs.on('end', function()&#123; console.log(\"end of read\"); ws.end();&#125;); 但很明显，上面这也会有问题，比如我们读的时候速度明显快于写的速度时候，就会可能产生数据丢失或者不完善的现象。所以我们要对这两者的平衡进行一个控制。12345678910111213rs.on('data',function(chunk)&#123; if(ws.write(chunk) === false)&#123; rs.pause(); &#125;&#125;);ws.on('drain',function()&#123; rs.resume();&#125;);rs.on('end', function()&#123; ws.end();&#125;); 所以我们改成上面这样。但是下面这种写法利用pipe，可以更简洁。pipe完成的就是data和end的工作。1fs.createReadStream('tmp/5.js').pipe(fs.createWriteStream('tmp/10.js')); 下面我们看一个这个例子的更详细的例子。这个就是一个拷贝文件的例子。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162\"use strict\";var filePath = \"tmp/2.mp3\";var destPath = \"tmp/5.mp3\";var rs = fs.createReadStream(filePath);var ws = fs.createWriteStream(destPath);//获取文件大小var stat = fs.statSync(filePath);var totalSize = stat.size;//当前已读取长度var currentLength = 0;var lastSize = 0;var startTime = Date.now();rs.on('data', function(data)&#123; ws.write(data);&#125;);rs.on('end', function()&#123; console.log(\"end of read\"); ws.end();&#125;);rs.on('data',function(chunk)&#123; currentLength += chunk.length; if(ws.write(chunk) === false)&#123; rs.pause(); &#125;&#125;);ws.on('drain',function()&#123; rs.resume();&#125;);rs.on('end', function()&#123; ws.end();&#125;);var timer = setTimeout(function displayInfo()&#123; var percent = Math.ceil((currentLength / totalSize )*100); var size = Math.ceil(currentLength /1000000); var diff = size - lastSize; lastSize = size; //利用了process.stdout输出信息 process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(`已完成: $&#123;size&#125;, 百分比: $&#123;percent&#125;, 速度: $&#123;diff*2&#125; MB/s `); if(currentLength &lt; totalSize)&#123; setTimeout(displayInfo,500); &#125;else&#123; clearTimeout(timer); var endTime = Date.now(); console.log(`共用时: + $&#123;(endTime - startTime) / 1000&#125; s `); &#125;&#125;,500); 这里我们主要处理的就是对文件拷贝细节的处理。这各部分关于百分比和速度这块学习自sf的一篇文章。感谢，文章末尾有该文章的链接。 所以对流处理我们可以理解成下面这个样子： 可以想象，如果大水杯也就是stream里面的的水流的太快了，小水杯不久一下就满了，所以多的水就溢出去了。所以我们进行一个控制。水在一点一点的流动，而不是一下子全部倒进去。这就是我理解的流。也不知道对不对。如果错误请指正。其实真正的可以这么理解：我们读是从文件读到内存，写是从内存写入磁盘的另一个文件。如果我们读的太快，写的太慢，东西是不是都还在内存里面？更有点像你买了东西，但是不消费，家里面就越堆越多了，想法，总会有房子太满放不下的情况，但是如果你买了就消费出去了，这样你的家里就会保持平衡很干净，你也有时间在房子里做别的事情。所以对于水杯之外，其实还有中间的管子，这个管子就相当于我们这里的内存啦。 读取文件readFile/readFileSync12345678910111213141516var fs = require(\"fs\");//异步读取fs.readFile('./input.txt',function(err,data)&#123; if(err)&#123; return console.error(err); &#125; console.log(\"read file input.txt:\" + data.toString());&#125;);//同步读取var data = fs.readFileSync('./input.txt');console.log(\"sync read :\" + data.toString());console.log(\"after read\"); 结果很明显，后面同步的先执行，前面的异步会后执行。因为文件的读取也耗费时间。 sync read :this is input txt after read read file input.txt:this is input txt 打开文件123456fs.open('input.txt','r+',function(err,fd)&#123; if(err)&#123; return console.error(err); &#125; console.log(\"文件打开成功\");&#125;) 查看文件信息123456fs.stat('input.txt',function(err,stats)&#123; if(err)&#123; return console.error(err); &#125; console.log(stats);&#125;) 写入文件12345678910fs.writeFile('write.txt','我是写入文件的内容',function(err)&#123; if(err)&#123; return console.log(err); &#125; console.log('文件已写入'); fs.readFile('write.txt',function(err,data)&#123; if(err) return console.log(err); console.log('写入内容为: ' + data.toString()); &#125;)&#125;); 删除文件1234fs.unlink('input.txt',function(err)&#123; if(err) return console.error(err); console.log(\"文件删除成功\");&#125;); 创建目录12345678910111213141516fs.mkdir('tmp/test',function(err)&#123; if(err) return console.error(err); console.log(\"目录创建成功\"); fs.rmdir('tmp/test',function(err)&#123; if(err) return console.error(err); console.log(\"删除目录成功\"); fs.readdir('tmp',function(err,files)&#123; if(err) return console.error(err); files.forEach(function(file)&#123; console.log(file); &#125;) &#125;) &#125;)&#125;) 目录创建成功 删除目录成功 1.js 2.js dirtmp 更改权限12345fs.chmod('tmp/1.js', 0600 ,function(err)&#123; if(err) return console.error(err); console.log(\"修改权限成功\");&#125;); 文件重命名123456789\"use strict\";fs.rename('tmp/5.js','tmp/7.js',function(err)&#123; if(err) throw err; console.log(\"4.js has been renamed\"); fs.stat('tmp/7.js',(err,stat)=&gt;&#123; if(err) throw err; console.log(`stat is : $&#123;JSON.stringify(stat)&#125;`); &#125;);&#125;); 创建硬链接12345678//硬链接就是备份，软连接就是快捷方式fs.link('tmp/3.js','tmp/5.js',function(err)&#123; if(err) return console.error(err); console.log(\"硬链接创建成功\");&#125;);fs.unlink('tmp/3.js'); 获取文件绝对路径1234fs.realpath('tmp/2.js',function(err,resolvedPath)&#123; if(err) return console.error(err); console.log(\"文件的绝对路径是:\" + resolvedPath);&#125;); 注意事项由于利用了异步方法，所以在写的时候一定要注意顺序。比如：1234567891011\"use strict\";fs.rename('tmp/5.js','tmp/7.js',function(err)&#123; if(err) throw err; console.log(\"4.js has been renamed\");&#125;);fs.stat('tmp/7.js',(err,stat)=&gt;&#123; if(err) throw err; console.log(`stat is : $&#123;JSON.stringify(stat)&#125;`);&#125;) 会得到： if(err) throw err; ^ Error: ENOENT: no such file or directory, stat &apos;F:\\uploadNodejs\\testFile\\tmp\\7.js&apos; at Error (native) 我们只需要放进去就可以啦。 总结快花了一天去弄这个东西了，先前总说遇到API就去查，但是我有点不同意，因为这样效率会很低。而且会导致变懒惰的后果。还是要多进行刻意的练习，才能有质的飞跃。这是自己所欠缺的。下面推荐几篇文章和阅读，也感谢这些优秀的文章： Nodejs API /api/fs.html http://my.oschina.net/cmw/blog/110107 http://www.runoob.com/nodejs/nodejs-util.html https://segmentfault.com/a/1190000004057022","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"yield和yield*的区别和用法","slug":"yield和yield-的区别和用法","date":"2016-08-04T01:02:01.000Z","updated":"2016-12-12T03:01:24.000Z","comments":true,"path":"2016/08/04/yield和yield-的区别和用法/","link":"","permalink":"http://sevencai.github.io/2016/08/04/yield和yield-的区别和用法/","excerpt":"","text":"先前在学koa的时候，学习到了很多概念，比如generator,yield,yield *再深一点，比如co,trunk,iterator,async,await这些。当时学习的时候还是有很多疑惑。现在又重新整理了一遍。感觉思路清晰了很多。记录分享如下。大部分都来自MDN的整理和学习。感谢。我觉得MDN那种先定义，再解释，再讲用途的方式特别好。如果再加上自己感性点的理解就是很完美的学习新东西的方式。以后要多学习这种学东西的习惯。很多时候，都是因为开始的时候没有抓住定义，把握住这个东西到底是干什么用的，导致到后来越来越糊涂。正确的做事情，第一次虽然会花费很长时间，但是后来会越来越少。 什么是yield?yield的定义yield 关键字用来暂停和继续一个生成器函数 (function* or legacy generator). 1yield [[expression]]; yield 关键字使生成器函数暂停执行，并返回跟在它后面的表达式的当前值. 可以把它想成是 return 关键字的一个基于生成器的版本. yield 关键字实际返回一个对象，包含两个属性, value 和 done. value 属性为 yield expression 的值, done 是一个布尔值用来指示生成器函数是否已经全部完成. 一旦在 yield expression 处暂停, 除非外部调用生成器的 next() 方法，否则生成器的代码将不能继续执行. 这使得可以对生成器的执行以及渐进式的返回值进行直接控制. 上面你能够理解，是建立在稍微知道一些generator的基础上的。generator我们称之为生成器，当你看到一个function *(){//...}这种有*的函数的时候，你就可以把这个函数称作generator,在这个函数里面，你可以使用yield。 煮个栗子1234567function* foo()&#123; var index = 0; while (index &lt;= 2) // when index reaches 3, // yield's done will be true // and its value will be undefined; yield index++;&#125; 12345var iterator = foo();console.log(iterator.next()); // &#123; value:0, done:false &#125;console.log(iterator.next()); // &#123; value:1, done:false &#125;console.log(iterator.next()); // &#123; value:2, done:false &#125;console.log(iterator.next()); // &#123; value:undefined, done:true &#125; 上面的都是我从MDN上学习到的，我没有做任何改动，因为我觉得它本身的例子就很好。看到这里，你肯定会想，那么为什么yield会跟异步扯上关系呢？因为执行到yield的时候，本次调用就已经结束了。控制权已经转到了外部next方法。并且调用的过程中整个生成器内部状态是一直在改变的。如果外部不条用next的话，那么这个生成器就停在了yield那里。所以我们只需要把异步的东西先做完。然后再在合适的地方调用next方法继续执行该生成器。就可以了。这就像函数在暂停，后面在继续的感觉。也就是我们通常理解的代码分段执行了。在阮一峰老师的es6的书里，他有提到，所谓的异步，就可以理解为代码分段执行了。先执行了一部分，然后这部分没有执行完，就开始执行下一部分。等到第一部分执行完再来执行剩余的部分。这样就可以理解为简单的异步。后面的代码并没有等前面的代码执行完，就开始执行了。 但实际上，我们会经常这么用：123456789function fetchResult()&#123; return new Promise((resolve,reject)=&gt;&#123; // ... &#125;)&#125;function gen*()&#123; var result = yield fetchResult(); console.log(result);&#125; fetchResult是一个异步的操作。比如返回的是一个Promise,那么如果你不用yield的时候，log出来的result是null，因为fetchResult是异步的。这个时候用yield就很需要了。 我们可以用yield来写一个斐波那契函数：123456789101112131415161718function * feb(num)&#123; var count = 0; var current= 1; var last = 0; while(count++ &lt; num)&#123; yield current; var temp = current; current += last; last = temp; &#125;&#125;var f = feb(7),nxt;var arr = [];while(!(nxt = f.next()).done)&#123; arr.push(nxt.value);&#125; 注意这里last和count都是从0开始的。最后的到结果：Array [ 1, 1, 2, 3, 5, 8, 13 ]。因为这里的yield的作用就跟我们递归是很像很像的。 那么在koa里面又是怎么用yield的呢？12345678910111213141516171819202122232425262728var koa = require('koa');var app = koa();// x-response-timeapp.use(function *(next)&#123; var start = new Date; yield next; var ms = new Date - start; this.set('X-Response-Time', ms + 'ms');&#125;);// loggerapp.use(function *(next)&#123; var start = new Date; yield next; var ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms);&#125;);// responseapp.use(function *()&#123; this.body = 'Hello World';&#125;);app.listen(3000); 在app.use里面，只接受有*的generator,在这个里面，你可以调用yield next继续往下一直进行，等下面没有yield可以返回的时候，再从下往上执行。具体koa是怎么实现中间件的，可以翻翻博客里另外一篇文章。 什么时候用yield *yield *的概念在生成器中，yield* 可以把需要 yield 的值委托给另外一个生成器或者其他任意的可迭代对象。1yield* [[expression]]; yield* 一个可迭代对象，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。 yield* 表达式本身的值就是当前可迭代对象迭代完毕时的那个返回值（也就是迭代器的迭代值的 done 属性为 true 时 value 属性的值)。 可以在定义看到，yield是把值委托给*一个生成器或者是一个可以迭代的对象。下面举几个例子来说： 委托给其他生成器以下代码中，g1() yield 出去的每个值都会在 g2() 的 next() 方法中返回，就像那些 yield 语句是写在 g2() 里一样。1234567891011121314151617181920function* g1() &#123; yield 2; yield 3; yield 4;&#125;function* g2() &#123; yield 1; yield* g1(); yield 5;&#125;var iterator = g2();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: 4, done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 委托给其他类型的可迭代对象除了生成器对象这一种可迭代对象，yield* 还可以 yield 其它任意的可迭代对象，比如说数组、字符串、arguments 对象等等。123456789101112131415function* g3() &#123; yield* [1, 2]; yield* \"34\"; yield* arguments;&#125;var iterator = g3(5, 6);console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: \"3\", done: false &#125;console.log(iterator.next()); // &#123; value: \"4\", done: false &#125;console.log(iterator.next()); // &#123; value: 5, done: false &#125;console.log(iterator.next()); // &#123; value: 6, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; yield* 表达式的值1234567891011121314151617181920function* g4() &#123; yield* [1, 2, 3]; return \"foo\";&#125;var result;function* g5() &#123; result = yield* g4();&#125;var iterator = g5();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125;, // 此时 g4() 返回了 &#123; value: \"foo\", done: true &#125;console.log(result); // \"foo\" 如果不用yield *?好，那如果我们想试一下不用yield*,还是用yield会得到什么结果呢？我们把上面的代码改成这样：123456789101112131415161718192021function* g1() &#123; yield 2; yield 3; yield 4;&#125;//去掉*后，看看结果function* g2() &#123; yield 1; yield g1(); yield 5;&#125;var iterator = g2();console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next());console.log(iterator.next()); 我们会得到如下的结果：123456Object &#123; value: 1, done: false &#125;Object &#123; value: Generator, done: false &#125;Object &#123; value: 5, done: false &#125;Object &#123; value: undefined, done: true &#125;Object &#123; value: undefined, done: true &#125;Object &#123; value: undefined, done: true &#125; 为什么会有这个结果呢？这就是yield *的魔力了。yield *后面可以接受一个iterable object，然后这个yield* a的值，就是这个a完成时，也就是状态done:true时的a的返回值。当你调用generator function时，会返回一个generator object,这个对象也是一个iterable object。【yield*表达式本身的值就是当前可迭代对象迭代完毕时的那个返回值】。 其实最常用的就是yield*用来在一个 generator 函数里“执行”另一个 generator 函数，并可以取得其返回值。 这里还可以扯一些关于co的事情。你会发现在co里面，你是可以直接yield 一个generator的，更可怕的是还可以yield一个generator function的。这里面来源自co在实现的时候进行了判断。1if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); 当它判断出来你是一个generator function的时候，是会继续的调用自己的。在co里，如果是yield *fn差不多就等于yield co(fn) co里面是很棒的代码。决定这个星期再仔细学一遍。然后整理下，嘻嘻。 观点这里有几个观点和技巧，是我犯过的错误。总结下： yield后面只能接generator?错误，比如你看到yield fun(),那么这个fun()的返回一定是generator吗？当然不是；fun方法完全可以返回一个 Promise，返回一个 thunk，返回一个数组、对象，或者就是返回generator object。yield后面可以接的值，要多注意容易犯错。 比如说你看到了yield * fun(),yield * 后面这个fun的返回值一定是generator object?yield*后面可以接很多，但是由于我们这里给的前提条件是yield*所以是可以判定的。这个是肯定的啦。你可以很自信的告诉别人这就是generator object。 生成器其实在其它语言很早就有了，比如python、c#，但与python不同的是js的generator更多的是提供一种异步解决方案。yield也是，在python中都有。 yield只能在koa里用？当然不是。koa里面只是利用yield，generator这种方式。yield，generator的用处可大了多了。 总结主要就是学习了yield 和yield *的区别和联系，还有他们的使用方式。参考了下面的几篇文章，感谢： MDN-Operators/yield MDN-Operators/yield* Understanding-the-Yield-principle","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"ES6 rest parameters和spread operator","slug":"ES6-rest-parameters和spread-operator","date":"2016-08-03T01:04:51.000Z","updated":"2017-02-10T03:47:58.000Z","comments":true,"path":"2016/08/03/ES6-rest-parameters和spread-operator/","link":"","permalink":"http://sevencai.github.io/2016/08/03/ES6-rest-parameters和spread-operator/","excerpt":"","text":"这篇文章主要记录和学习Rest parameters和Spread Operator的区别和联系。今天我去了解了下关于Rest解构赋值/扩展运算符的用法和区别。主要是开始的时候容易弄混淆。所以想要记录和学习下来。也分享给大家。 Peviewif you don’t use rest parameter Aggregation of remaining arguments into single parameter of variadic functions. 123456function f(x, y) &#123; var a = Array.prototype.slice.call(arguments, 2); return (x+y) * a.length;&#125;f(1, 3, \"hello\", true, 7); 如果使用Rest Parameter就会简单很多： 12345function f(x, y, ...a)&#123; return (x+y) * a.length;&#125;f(1, 3, \"hello\", true, 7); If you don’t use spread operator Spreading of elements of an iterable collection (like an array or even a string) into both literal elements and individual function parameters. 1234567var params = [\"hello\", true, 7];var extends = [1, 3].concat(params);f.apply(undefined, [1, 3].concat(params)); //因为extends是数据的原因，所以用applyvar str = \"Seven\";var chars = str.split(\"\"); //[\"S\", \"e\", \"v\", \"e\", \"n\"] 如果使用spread operator的话：123456var params = [\"hello\", true, 7];var extends = [1, 3, ...params];f(1,3, ...params);var str = \"Seven\";var chars = [...str]; //[\"S\", \"e\", \"v\", \"e\", \"n\"] 下面具体看下两种新的 Extended Parameter Handling。 Rest parameters The rest parameter syntax allows us to represent an indefinite number of arguments as an array. 在ES6的新特性中，Rest parameters可以为我们带来很多方便的地方。它可以帮助我们去把一系列不确定个数的参数转换成数组。 Rest parameters的语法123function(a, b, ...theArgs) &#123; // ...&#125; 比如我们传入 fun(1,2,3,4),那么a将为1，b将为2，theArgs将为[3,4]。 arguments和rest parameters的区别区别主要有下面三点： rest parameters are only the ones that haven’t been given a separate name, while the arguments object contains all arguments passed to the function; the arguments object is not a real array, while rest parameters are Array instances, meaning methods like sort, map, forEach or pop can be applied on it directly; the arguments object has additional functionality specific to itself (like the callee property).-FROM MDN =&gt; rest_parameters 我觉得讲的很清楚了。具体怎么使用，我们看下面的几个例子来更好的理解这些区别。 煮几个栗子12345678910function sum() &#123; var numbers = Array.prototype.slice.call(arguments), result = 0; numbers.forEach(function (number) &#123; result += number; &#125;); return result;&#125;console.log(sum(1)); // 1console.log(sum(1, 2, 3, 4, 5)); // 15 上面是我们最长看到的一个相加参数的方法。由于arguments不是数组，所以我们在使用前要先将他转换成数组。我们再看看rest的写法。123456789function sum(…numbers) &#123; var result = 0; numbers.forEach(function (number) &#123; result += number; &#125;); return result;&#125;console.log(sum(1)); // 1console.log(sum(1, 2, 3, 4, 5)); // 15 由于使用…numbers的参数就已经是被转换成数组了，所以我们可以直接使用。 再看个几个可以直接使用rest的例子。12345678function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] 上面看两个地方，第一是传参数是从第二个开始传的。1234567891011121314function sortRestArgs(...theArgs) &#123; var sortedArgs = theArgs.sort(); return sortedArgs;&#125;console.log(sortRestArgs(5,3,7,1)); // shows 1,3,5,7function sortArguments() &#123; var sortedArgs = arguments.sort(); return sortedArgs; // this will never happen&#125;// throws a TypeError: arguments.sort is not a functionconsole.log(sortArguments(5,3,7,1)); 再举一个经常见到的例子：12345function logArguments() &#123; for (var i=0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 下面是更好的一种写法：12345function logArguments(...args) &#123; for (let arg of args) &#123; console.log(arg); &#125;&#125; 好，到目前为止，你肯定很清楚，不过估计过一会可能会混淆了，就像我一样。下面我们看看spread。 Spread_operatorspread的基本语法用于函数调用:1myFunction(...iterableObj); 用于数组字面量:1[...iterableObj, 4, 5, 6] 也就是说spread有两种情况。一个是在函数中使用的情况。一个是在数组字面量的情况。在函数中就相当于是分割成单个参数，在数组中是组成一个更大的数组。 spread和rest parameter的区别spread和rest parameters非常像。因为它们都有…这个表达式。但是它们几乎是相反的操作。spread 可以把一个数组分割成单个的参数。然后传递给函数。而刚刚我们讲的rest则是把单个的参数转换成数组传递下去。 还有一种操作符叫做剩余操作符（the rest operator），它的样子看起来和展开操作符一样，但是它是用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。 12345function sum(a, b, c) &#123; return a + b + c;&#125;var args = [1, 2, 3];console.log(sum(…args)); // 6 但是在ES5中我们一般是这么做的：12345function sum(a, b, c) &#123; return a + b + c;&#125;var args = [1, 2, 3];console.log(sum.apply(undefined, args)); // 6 因为apply可以帮助我们把数组变成单个的参数。这样是不是很方便了。12345function sum(a, b, c) &#123; return a + b + c;&#125;var args = [1, 2];console.log(sum(…args, 3)); // 6 也可以像上面一样混淆着写。所以我们总结下。 更好的apply我们都是使用Function.prototype.apply方法来将一个数组展开成多个参数:123function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction.apply(null, args); 用了展开符我们可以这样写：123function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2];myFunction(...args); 也可以展开多个：123function myFunction(v, w, x, y, z) &#123; &#125;var args = [0, 1];myFunction(-1, ...args, 2, ...[3]); 更强大的数组字面量如果在已有的数组中的某个部分添加一个属性，通常会用到push，splice，concat 等数组方法。有了扩展运算符会让代码更简洁:12var parts = ['shoulder', 'knees'];var lyrics = ['head', ...parts, 'and', 'toes']; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"] 更好的 push 方法1234var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];// 将arr2中的所有元素添加到arr1中Array.prototype.push.apply(arr1, arr2); 上面是我们一般将数组push添加到一个数组的情况。下面是我们使用spread操作符。123var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); 将类数组对象转换成数组12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; 举几个很常用的例子如果我们有一个数组，要求它的最大值，通常我们会这么做：123var myArr = [5,3,9];Math.max(myArr); // NaNMath.max.apply(Math,myArr); // 9 一般我们都是利用apply可以把数组转换为单个参数。现在我们可以这样做：12var myArr = [5,3,9];Math.max(...myArr); //9 是不是很方便？还有一个优点：扩展运算符支持构造函数：123new Date(...[2016, 5, 6]);new Date.apply(null, [2016, 8, 2]); // TypeError: Date.apply is not a constructornew (Function.prototype.bind.apply(Date, [null].concat([2016, 8, 2]))); //Date 2016-09-01T16:00:00.000Z 总结主要是了解了ES6的这两个新特性。我觉得很好用。不过都是要刻意的去用才有熟悉的过程。否则估计过不了多久就忘记啦。大部分整理和学习自MDN。感谢。MDN - Spread_operator","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"ES6 Symbol ! Why ? How ? When ? ","slug":"ES6-Symbol-Why-How-When","date":"2016-08-01T03:45:21.000Z","updated":"2017-01-11T12:47:59.000Z","comments":true,"path":"2016/08/01/ES6-Symbol-Why-How-When/","link":"","permalink":"http://sevencai.github.io/2016/08/01/ES6-Symbol-Why-How-When/","excerpt":"","text":"前几天看小胡子哥的网站，发现这么一篇文章里面有下面这样一些代码，可以看到这段代码里面用了很多ES6的新特性，比如import,class,extends,static,for..of循环,还有下面要讲的Symbol。先前知道symbol但是一直没有去用过它，其实也并不知道到底有什么实质的作用，只知道是简单的创建唯一值。觉得是时候好好理解理解了。主要学习自阮一峰老师的书，es6入门。感谢阮老师。 123456789101112131415161718192021222324252627import Baz from 'bazGroup';class Foo extends Baz &#123; static classMethod() &#123; return 'hello'; &#125; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod();for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125; 下面从几个方面介绍：Symbol是什么？Symbol的出现原因？Symbol怎么用 ？Symbol有什么作用？ Symbol的出现Symbol是什么Symbol是ES6新引入的一种数据类型。它是JavaScript语言的第七种数据类型，前面6种是我们熟知的：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 抓住，第一它是一种新的数据类型，它不是字符串，也不是对象。第二是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。 要注意一旦创建后就不可更改，不能对它们设置属性，在严格模式下尝试这样做，你将得到一个 报错得到TypeError。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。另一方面，每个 Symbol 都是独一无二的，不与其它 Symbol 重复（即便是使用相同的 Symbol 描述创建）。 我有看到一些书里说这里的Symbol和Lisp和Ruby里面的Symbol类似，但是不完全一样。他们解释说。在 Lisp 中，所有标识符都是 Symbol；在 JavaScript 中，标识符和大多数属性仍然是字符串，Symbol 只是提供了一个额外的选择。因为我没有用过Lisp和Ruby当然也就没有发言权了。23333 Symbol出现的原因 ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。 – from 阮一峰老师 然后在stackoverflow-why-bring-symbols-to-javascript上面也看到了一个解释，我觉得也很好，因为也告诉了我们，Symbol其实并不能完全的去保护成员变量的privacy,还告诉我们现在主要的用途就是unique。 Enabling private properties, like kangax describes in his answer, was indeed the original motivation for introducing symbols into JavaScript. Unfortunately, however, they ended up being severely downgraded, and not private after all, because you can find them via reflection. Specifically, via the Object.getOwnPropertySymbols method and through proxies. They are now known as unique symbols, and their only use is to avoid name clashes between properties. For example, EcmaScript itself can now introduce extension hooks via certain methods you can put on objects (e.g. to define their iteration protocol) without running the risk of clashing with user names. Whether that is strong enough a motivation to add symbols to the language is debatable. Symbol怎么用？Symbol值通过Symbol函数生成，注意千万不要加new关键字，否则会报错。 12//description 可选Symbol([description]) 注意这里的description是可选的，字符串。注意【符号的描述（description）是用于调试的而不是访问符号本身】。 123var sym1 = Symbol();var sym2 = Symbol(\"foo\");var sym3 = Symbol(\"foo\"); 由symbol生成的都是唯一的，所以当你去判断sym2 == sym3时，得到的是false,实际上，上面的三个值都是不相同的。那这个值到底是什么呢？当你试图去打印： 12345console.log(sym1 === sym3); //falseconsole.log(sym2 === sym3); //falseconsole.log(sym === sym3); //falseconsole.log(sym2); // Symbol(foo)console.log(sym1); //Symbol() 虽然如果你单独打印sym2和sym3的时候，都会得到一个值：Symbol(&#39;foo&#39;),看起来是相同的，但两个值已经由程序生成了两个完全不同的值。你可以去使用这些你生成的变量。而且不用担心会有重名问题。这就是这个Symbol最好的地方。 sym1和sym2/sym3除了值不一样，都是独一无二的，还有就是sym2/sym3多了一个描述，当你打印或者调试的时候就可以很清楚的知道是哪个symbol了。当然最好这个description不要一样了，否则你调试的时候回去怀疑到底是哪一个Symbol。 下面typeof运算符的结果，表明变量sym2是Symbol数据类型，而不是字符串之类的其他类型,是一种新的数据类型。 1234console.log(typeof Symbol())// &lt;- 'symbol'console.log(typeof Symbol('foo'))// &lt;- 'symbol' 注意Symbol不能够与替他类型做运算,也就是不能强制转换，但是可以转换为string或者bool类型。但是不能转换为数字类型。转换为字符串当然都是得到的相同的结果。所以我们最好用String/toString()来转换。由于转换后的值相同，其实没有什么太大的用，是不是？ 12345678910var sym = Symbol('test');String(sym) // 'Symbol(test)'sym.toString() // 'Symbol(test)'var sym = Symbol();Boolean(sym) // trueNumber(sym) // TypeError: can't convert symbol to numbersym - 5 //TypeError: can't convert symbol to number Symbol的用途给对象添加唯一属性和方法由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 也就是现在对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。123456789101112131415161718192021//直接在obj上添加keyconst MY_KEY = Symbol();let obj = &#123;&#125;;obj[MY_KEY] = 123;console.log(obj[MY_KEY]); // 123//在对象内部定义属性const MY_KEY = Symbol();let obj = &#123; [MY_KEY]: 123&#125;;//在对象内部定义方法const FOO = Symbol();let obj = &#123; [FOO]() &#123; return 'bar'; &#125;&#125;;console.log(obj[FOO]()); 这个过程发生了下面的事情： 调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。 我们利用Symbol 类型的值可以作为对象的属性名，正是由于它不与任何其它值相等，对应的属性也不会发生冲突。 和数组一样，我们只能通过[]来获得值，不能够通过. 点号来获取值。 总结下：我们可以用下面几种方法来生成一个对象的唯一属性： 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 上面是定义属性，下面看看定义方法，其实是一模一样的。要注意由于不能使用点运算符，所以在对象里定义属性的时候，也只能用方括号。所以你可以这样写： 123456789101112131415161718let s = Symbol();//普通方法var obj = &#123; [s] : function(args) &#123; //... &#125;&#125;//或者这样写（对象增强）var obj = &#123; [s](args)&#123; //... &#125;&#125;//调用方法obj[s](1,2,3);//错误写法var obj = &#123; s(args) &#123; //... &#125; s : function()&#123; //... &#125;&#125; 在最后一个错误写法中：如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个Symbol值。obj.s(args);这就是把s当作一个普通的键名了。 Using symbols to represent concepts这是第二种我们可以用Symbol的地方。比如一个人写了一个这样的代码：12345678910111213141516171819202122232425var COLOR_RED = 'RED';var COLOR_ORANGE = 'ORANGE';var COLOR_YELLOW = 'YELLOW';var COLOR_GREEN = 'GREEN';var COLOR_BLUE = 'BLUE';var COLOR_VIOLET = 'VIOLET';function getComplement(color) &#123; switch (color) &#123; case COLOR_RED: return COLOR_GREEN; case COLOR_ORANGE: return COLOR_BLUE; case COLOR_YELLOW: return COLOR_VIOLET; case COLOR_GREEN: return COLOR_RED; case COLOR_BLUE: return COLOR_ORANGE; case COLOR_VIOLET: return COLOR_YELLOW; default: throw new Exception('Unknown color: '+color); &#125;&#125; 这样我们避免了hard-coding，也就是硬编码。防止我们每次都去改动函数中的’red’,’blue’，这之类的。但是这还是有问题，比如一个人：1var MOOD_BLUE = 'BLUE'; 他又定义了上面一个颜色。那么这样以来switch的时候就会有重复的值了。就不太好。如果我们用Symbol可以很好的解决这个问题。123456const COLOR_RED = Symbol();const COLOR_ORANGE = Symbol();const COLOR_YELLOW = Symbol();const COLOR_GREEN = Symbol();const COLOR_BLUE = Symbol();const COLOR_VIOLET = Symbol(); 这样以来，当我们使用Symbol而不是字符串的时候，我们再也不用去改动函数了。 Symbols as keys of internal properties123456789101112// One WeakMap per private property const PASSWORD = new WeakMap(); class Login &#123; constructor(name, password) &#123; this.name = name; PASSWORD.set(this, password); &#125; hasPassword(pw) &#123; return PASSWORD.get(this) === pw; &#125; &#125; 符号不提供真正的隐私，因为它很容易找到对象的符号值的属性键。但是，保证一个属性密钥永远不会与任何其他属性密钥冲突往往是不够的。如果你真的想阻止外部访问私有数据，你需要使用WeakMaps或关闭。12345678910const PASSWORD = Symbol();class Login &#123; constructor(name, password) &#123; this.name = name; this[PASSWORD] = password; &#125; hasPassword(pw) &#123; return this[PASSWORD] === pw; &#125;&#125; Symbol do not guarantee true privacy but can be used to separate public and internal properties of objects.123456789101112131415var Pet = (function() &#123; function Pet(type) &#123; this.type = type; &#125; Pet.prototype.getType = function() &#123; return this.type; &#125; return Pet;&#125;());var a = new Pet('dog');console.log(a.getType());//Output: doga.type = null;//Modified outsideconsole.log(a.getType());//Output: undefined 上面的这个例子中type可以被外部所访问。一般我们的方法是通过闭包来解决。1234567891011121314var Pet = (function() &#123; function Pet(type) &#123; this.getType = function()&#123; return type; &#125;; &#125; return Pet;&#125;());var b = new Pet('dog');console.log(b.getType());//dogb.type = null;//Stays privateconsole.log(b.getType());//dog 现在如果我们通过symbol的话，就可以减少不必要的闭包。我们已经提到过很多次，symbol虽然不能够保证正真的隐私，但是可以将外部环境和内部环境分离。12345678910111213141516var Pet = (function() &#123; var typeSymbol = Symbol('type'); function Pet(type) &#123; this[typeSymbol] = type; &#125; Pet.prototype.getType = function()&#123; return this[typeSymbol]; &#125; return Pet;&#125;());var a = new Pet('dog');console.log(a.getType());//Output: doga.type = null;//stays privateconsole.log(a.getType());//Output: dog Symbols are invisible to all “reflection” methods before ES6. This can be useful in some scenarios, but they’re not private by any stretch of imagination, as we’ve just demonstrated with the Object.getOwnPropertySymbols API. 上面学习自：Samar Panda来自stackoverflow的回答。感谢。 几个重点的API使用Symbol() 函数 不会在你的整个代码库中创建一个可用的全局符号。 要创建跨文件可用的symbols，甚至跨域（每个都有它自己的全局作用域） , 使用这个方法Symbol.for() 和 Symbol.keyFor() 从全局symbol的注册处设置和取得symbols。 Symbol.for(‘desc’)Symbol.for为Symbol值登记的名字，是全局环境的，也就是说是全局共享的Symbol。12Symbol.for('foo') === Symbol.for('foo') //trueSymbol('foo') === Symbol('foo') //false 我们知道当我们每次调用Symbol的时候都会生成一个新的值，那如果我们想重用一个Symbol怎么办呢？Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 Symbol.keyFor(‘desc’)Symbol.keyFor方法返回一个已登记的Symbol类型值的key。注意这里的desc必须是已经登记过了的，也就是一定要是用Symbol.for来声明的。 12345var sym1 = Symbol.for(\"foo\");console.log(Symbol.keyFor(\"foo\")); //\"foo\"var sym2 = Symbol(\"bar\");console.log(Symbol.keyFor(\"bar\")); //undefined 上述代码中：变量sym2属于未登记的Symbol值，所以返回undefined。 Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器。123456789101112131415161718192021let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++] &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125; &#125;; for (let x of obj) &#123; console.log(x); &#125; An object is iterable if it has a method whose key is the symbol (stored in) Symbol.iterator. 获取Symbol的方法总结下获取Symbol的几种方法 Symbol() 每次调用时都返回一个唯一的 Symbol。 Symbol.for(string) 从 Symbol 注册表中返回相应的 Symbol，与上个方法不同的是，Symbol 注册表中的 Symbol 是共享的。也就是说，如果你调用 Symbol.for(“cat”) 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。 Symbol.iterator 返回语言预定义的一些 Symbol，每个都有其特殊的用途。 这里需要知道一个很大的区别： Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30次，每次都会返回同一个Symbol值，但是调用Symbol(“cat”)30次，会返回30个不同的Symbol值。 –FROM RUAN YIFeng 属性的遍历Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。看看下面几个例子。 12345678var foo = &#123; [Symbol()]: 'foo', [Symbol('foo')]: 'bar', [Symbol.for('bar')]: 'baz', what: 'ever'&#125;console.log([...foo])// &lt;- [] Object.keys（）也是不行的。12console.log(Object.keys(foo))// &lt;- ['what'] JSON.stringify（）是不行的。12console.log(JSON.stringify(foo))// &lt;- &#123;\"what\":\"ever\"&#125; for in 可以吗？不可以1234for (let key in foo) &#123; console.log(key) // &lt;- 'what'&#125; getOwnPropertyNames当然也不可以。12console.log(Object.getOwnPropertyNames(foo))// &lt;- ['what'] 难道没有方法获得吗？如果认真看了前面我们说的，symbols是不会真正保护隐私，因为会有一个getOwnPropertySymbols的方法可以获得它们。12console.log(Object.getOwnPropertySymbols(foo))// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')] 123456for (let symbol of Object.getOwnPropertySymbols(foo)) &#123; console.log(foo[symbol]) // &lt;- 'foo' // &lt;- 'bar' // &lt;- 'baz'&#125; 总结其实还有好多个symbol的API,到用到的时候再去查吧。基本上常用的就是上面那些。主要学到了symbol是什么，有什么用，可以用到什么地方。其实这新特性还是很好的。参考学习自下面几篇文章，感谢，也分享给大家。 http://es6.ruanyifeng.com/#docs/symbol https://ponyfoo.com/articles/es6-symbols-in-depth why-bring-symbols-to-javascript","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"koa中间件机制和错误处理解决方案","slug":"koa中间件机制和错误处理解决方案","date":"2016-07-14T01:11:13.000Z","updated":"2016-12-12T03:00:58.000Z","comments":true,"path":"2016/07/14/koa中间件机制和错误处理解决方案/","link":"","permalink":"http://sevencai.github.io/2016/07/14/koa中间件机制和错误处理解决方案/","excerpt":"","text":"由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 我觉得其实koa主要就是避免了繁琐的回调函数嵌套，代码看着更和谐。还有就是它的错误处理机制。 其实这几天一直在纠结为什么generator是一种异步方案。觉得真的好奇怪。因为你用generator要一直调用next方法才能继续，我想这就是阻塞的啊，怎么能是异步的呢。后来发现有些书上这样写是错误的。generator不是一种异步方案，它是和其他的一些配合才能实现异步。比如promise。由于yield以前也没用过，yield后面yieldable的内容又是有限的。自然就没有max（我nice的同事）说用的那么顺手。 解决我的疑问后来我在一篇文章experiments-with-koa-and-javascript-generators找到了答案。 也就是说promise+generator或者generator和其他异步方案一起合作才是正解。直接说generator就是异解决方案是不准确的。 koa的中间机制原理那么koa 中间件机制实现原理是什么呢？为什么中间我们一定要传入一个generator当作函数呢？一定需要用yield吗？yield的作用是什么呢？next又是什么？yield next为什么可以就顺序的执行下一个中间件？为什么中间件从上到下执行完后，可以从下到上执行 yield next 后的逻辑？这是我用这个框架的时候的疑问。 先来看一种实现koa中间机制的代码：123456789101112131415161718192021222324252627282930var co = require('co');class koa &#123; constructor ()&#123; this.middlewares = []; &#125; use(middleware)&#123; this.middlewares.push(middleware); &#125; listen()&#123; this._run(); &#125; _run()&#123; var ctx = this; var middlewares = this.middlewares; return co(function *()&#123; var prev = null; while (i--) &#123; prev = middlewares[i].call(ctx, prev); &#125; //执行第一个中间件 yield prev; &#125;)(); &#125;&#125; 然后我们以原始跟原始koa项目一样的代码来运行：1234567891011121314151617var app = new koa();app.use(function *(next)&#123; this.body = '1'; yield next; this.body += '5'; console.log(this.body);&#125;);app.use(function *(next)&#123; this.body += '2'; yield next; this.body += '4';&#125;);app.use(function *()&#123; this.body += '3';&#125;);app.listen(); 可以很清楚的发现是一样的结果。1,2,3,4,5。koa这种思想中yield相当于一个断点。到这个地方就停了。然后接着执行下一个next。很类似我们学过的递归的思想。它的思想就是把一系列中间件放入一个数组中，然后从第一个开始执行。 koa的错误处理机制一般我们在js的错误处理机制中有一下几种方法： 和其他同步语言类似的 throw / try / catch 方法 callback(err, data) 回调形式 通过 EventEmitter 触发一个 error 事件 koa 通过可以通过它的特性让我们可以使用 catch 来捕获异步代码中的错误。 比如： 12345678910const fs = require('fs');const Promise = require('bluebird');let filename = '/nonexists';let statAsync = Promise.promisify(fs.stat);try &#123; yield statAsync(filename);&#125; catch(e) &#123; // error here&#125; koa主要是通过co来实现。co是tj写的用来自动执行generator的小工具。如果我们不利用co，调用generator的时候，需要一直next,co帮助自动执行。 一般我们把中间件可以称作MVC里面的M，也就是逻辑业务处理层。最好的方式，是我们使用中间件来处理koa的错误。 1234567891011121314151617181920212223242526272829303132333435app.use(function* (next) &#123; try &#123; yield* next; &#125; catch(e) &#123; let status = e.status || 500; let message = e.message || '服务器错误'; if (e instanceof JsonError) &#123; // 错误是 json 错误 this.body = &#123; 'status': status, 'message': message &#125;; if (status == 500) &#123; // 触发 koa 统一错误事件，可以打印出详细的错误堆栈 log this.app.emit('error', e, this); &#125; return; &#125; this.status = status; // 根据 status 渲染不同的页面 if (status == 403) &#123; this.body = yield this.render('403.html', &#123;'err': e&#125;); &#125; if (status == 404) &#123; this.body = yield this.render('404.html', &#123;'err': e&#125;); &#125; if (status == 500) &#123; this.body = yield this.render('500.html', &#123;'err': e&#125;); // 触发 koa 统一错误事件，可以打印出详细的错误堆栈 log this.app.emit('error', e, this); &#125; &#125;&#125;);` 当我们只在try块里面执行yield的时候。我们的错误都放在catch里面，然后再对catch到的内容做处理，就是一种很有效的方法。 当我们触发错误的时候：1234567891011const router = new (require('koa-router'));router.get('/some_page', function* () &#123; // 直接抛出错误，被中间件捕获后当成 500 错误 throw new PageError('发生了一个致命错误'); throw new JsonError('发送了一个致命错误'); // 带 status 的错误，被中间件捕获后特殊处理 this.throw(403, new PageError('没有权限访问')); this.throw(403, new JsonError('没有权限访问'));&#125;); 这里的JsoneError和PageError是定义的错误构造器。1234567891011121314const util = require('util');exports.JsonError = JsonError;exports.PageError = PageError;function JsonError(message) &#123; Error.call(this, message);&#125;util.inherits(JsonError, Error);function PageError(message) &#123; Error.call(this, message);&#125;util.inherits(PageError, Error); 通过将代码细分，就可以得到更清晰的结果。这一部分学习自：淘宝fedkoa错误处理。 总结关于co中间的原理，比如返回promise,比如利用到了trunk。这些我还没有完全理解清楚，等理解清楚了再来记录下。推荐几篇文章： 阮一峰es6入门：http://es6.ruanyifeng.com/#docs/async#co模块 promise实现：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise koa中文文档: https://github.com/guo-yu/koa-guide koa异步讲解：http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/ 淘宝fedkoa错误处理:http://taobaofed.org/blog/2016/03/18/error-handling-in-koa/","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"用Nodejs来自定义微信菜单","slug":"用Nodejs来创建微信公众号菜单","date":"2016-07-12T01:26:40.000Z","updated":"2017-01-11T12:45:27.000Z","comments":true,"path":"2016/07/12/用Nodejs来创建微信公众号菜单/","link":"","permalink":"http://sevencai.github.io/2016/07/12/用Nodejs来创建微信公众号菜单/","excerpt":"","text":"以前用php自定义过菜单。当时直接利用curl来post数据就行了。今天用nodejs重新写了下。发现nodejs的坑略多还是。下面是两种方法，第二种用了下promise。其实没有太大区别。 中间遇到了一些问题，我把它们写到csdn上面了。小伙伴们自己看看：csdn问题。中间一定要注意的一个问题是我们通过微信API来get到的菜单和我们create需要的菜单是完全不一样的，比如说没有menu。这会导致创建菜单失败。因为微信对于消息的语法非常严格。 下面直接就上代码了，我们这里就只用了http的原生方法get和request发送请求。下面的menu.json是一个的按钮json文件。注意去微信官方api上看限制条件。config里面配置了我的token,appid,secrete等等。 第一种方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const https = require('https'), config = require('./config.json'), querystring = require('querystring');var menus = require('./menu.json'), strMenus = JSON.stringify(menus), optionAccess = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=\"+config.appid+\"&amp;secret=\"+config.appSecret, access_token;https.get(optionAccess,function(res)&#123; var body = \"\"; res.on('data',function(d)&#123; body += d; &#125;) res.on('end',function()&#123; var parsed = JSON.parse(body); createMenu(parsed.access_token); &#125;) &#125;).on('error',(e)=&gt;&#123; console.log(e.message);&#125;)function createMenu(access_token)&#123; var data = \"\"; var options = &#123; protocol:'https:', host:'api.weixin.qq.com', port:443, path:'/cgi-bin/menu/create?access_token='+access_token, method:'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(strMenus) &#125; &#125; var req = https.request(options,(res)=&gt;&#123; res.on('data',(chunk)=&gt;&#123; data+=chunk; &#125;) res.on('end',()=&gt;&#123; var message = JSON.parse(data); if(message.errmsg)&#123; console.log(\"返回信息:\"+message.errmsg+'; 返回码:'+message.errcode); &#125; &#125;) &#125;) req.on('error',(e)=&gt;&#123; console.log(e); &#125;) req.write(new Buffer(strMenus)); req.end();&#125; 第二种方法细心的小伙伴会发现其实我没有改动什么代码。这里promise的作用体现的不明显。当有很多的次序请求的时候用promise会很好。以前我总是想，我可以直接在调用promise的地方放一个函数，然后在内部调用这个外部调用的函数。这其实就是callback。如果有很多层调用的时候，就会很乱。现在我能知道promise的好了。下面还用到了es6的一些小特性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const https = require('https'), config = require('./config.json');var menus = require('./menu.json'), strMenus = JSON.stringify(menus);/** * [getAccessToken 获取access_token值] * return promise对象 */function getAccessToken()&#123; var access_token = \"\", optionAccess = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=\"+config.appid+\"&amp;secret=\"+config.appSecret; return new Promise(function(resolve,reject)&#123; var body = \"\"; https.get(optionAccess,(res)=&gt;&#123; res.on('data',(chunk)=&gt;&#123; body += chunk; &#125;) res.on('end',()=&gt;&#123; resolve(JSON.parse(body).access_token); &#125;) &#125;).on('error',(e)=&gt;&#123; console.log(e.message); reject(e); &#125;) &#125;)&#125;/** * [执行createMenu,创建菜单] */getAccessToken().then((access_token)=&gt;&#123; var data = \"\"; var options = &#123; protocol:'https:', host:'api.weixin.qq.com', port:443, path:'/cgi-bin/menu/create?access_token='+access_token, method:'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(strMenus) &#125; &#125; var req = https.request(options,(res)=&gt;&#123; res.on('data',(chunk)=&gt;&#123; data+=chunk; &#125;) res.on('end',()=&gt;&#123; var message = JSON.parse(data); if(message.errmsg)&#123; console.log(`返回信息:$&#123;message.errmsg&#125;; 返回码:$&#123;message.errcode&#125;`); &#125; &#125;) &#125;) req.on('error',(e)=&gt;&#123; console.log(e); &#125;) req.write(new Buffer(strMenus)); req.end();&#125;) 总结看起来代码简单，我中间真的花了不少时间。主要原因还是感觉自己的api不熟。每写一个方法还要去查官方文档，比如get和post方法，会跟以前用到的比如express和koa的请求api弄混淆。真是不开心。希望以后会越来越熟练。加油！ :)","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"React-mixins在多个组件中复用代码","slug":"React-mixins在多个组件中复用代码","date":"2016-06-22T14:07:03.000Z","updated":"2016-12-12T03:01:02.000Z","comments":true,"path":"2016/06/22/React-mixins在多个组件中复用代码/","link":"","permalink":"http://sevencai.github.io/2016/06/22/React-mixins在多个组件中复用代码/","excerpt":"","text":"React使用组合而不是继承来处理父子组件,这也是React的特点之一。组件的复合只是React提供的用于定制和特殊化组件的方式之一。React的mixins提供了一种途径，帮助我们定义可以在多组件之间共用的方法。 Mixins will allow you to apply behaviors to multiple React components. 先直观的感受下1234567891011121314151617181920var Timer = React.createClass(&#123; getInitialState:function()&#123; return &#123;secondsElapsed:0&#125; &#125;, tick:function()&#123; this.setState(&#123;secondsElapsed:this.state.secondsElapsed+1&#125;) &#125;, componentDidMount:function()&#123; this.interval = setInterval(this.tick,1000) &#125;, componentWillUnmount:function()&#123; clearInterval(this.interval) &#125;, render:function()&#123; return ( &lt;div&gt;Seconds Elapsed:&#123;this.state.secondsElapsed&#125;&lt;/div&gt; ) &#125;&#125;) ReactDOM.render(&lt;Timer /&gt;,document.getElementById('example')) 调用的顺序是：&quot;getInitialState&quot; ``&quot;componentDidMount&quot; ``&quot;tick&quot;。是一个简单的定时器组件。 当我们用了mixin，不过如果我们有很多的定时器，执行的都是上面的这段代码，难道我们要写很多吗？任何一个语言里面都有复用的方法，任何一个框架也是。连sass，less也都有 :) 。下面是react-mixins的用法。12345678910111213141516171819202122232425var IntervalMixin = function(interval)&#123; return &#123; componentDidMount:function()&#123; this._interval = setInterval(this.tick,1000) &#125;, componentWillUnmount:function()&#123; clearInterval(this._interval) &#125; &#125;&#125;var Timer = React.createClass(&#123; mixins:[IntervalMixin(1000)], getInitialState:function()&#123; return &#123;secondsElapsed:0&#125; &#125;, tick:function()&#123; this.setState(&#123;secondsElapsed:this.state.secondsElapsed+1&#125;) &#125;, render:function()&#123; return ( &lt;div&gt;Seconds Elapsed:&#123;this.state.secondsElapsed&#125;&lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;Timer /&gt;,document.getElementById('example')) 这么看来mixins是不是是相当于把一部分功能提取出来公用？更通俗的解释：就是类似于merge，A 有3个方法 compoment有2个方法，mixin[A]以后,就有5个方法。并且调用没有任何问题。 几个需要注意的地方在mixin中写的生命周期相关的回调都会被合并，也就是他们都会执行，而不会互相覆盖掉。比如123456React.createClass(&#123; mixins:[&#123; getInitialState:function()&#123;return &#123;a:1&#125;&#125; &#125;], getInitialState:function()&#123;return &#123;b:2&#125;&#125;&#125;) 这样下来，最后得到的初始state是{a:1,b:2},如果mixin中的方法和组件类中的方法返回的对象中存在重复的键，React会抛出一个错误来警示。 再比如：你在mixin中可以定义 componentDidMount来初始化组件，他不会覆盖掉使用这个mixin的组件。实际执行的时候，会先执行mixin的 componentDidMount，最后执行组件的 componentDidMount方法。 因为mixin的作用是抽离公共功能，不存在渲染dom的需要，所以它没有render方法。如果你定义了render方法，那么他会和组件的render方法冲突而报错。 同样，mixin不应该污染state，所以他也没有 setState 方法。mixin应该只提供接口（即方法），不应该提供任何属性。mixin内部的属性最好是通过闭包的形式作为私有变量存在。 1234var Timer = function() &#123; var test = 1;//私有属性 return &#123;test + 1&#125; &#125; 除了生命周期方法可以重复以外，其他的方法都不可以重复，否则会报错。比如有一个Amixin,有一个Bmixin,并且Amixin和Bmixin中都有方法find(),当他们同时被引入到一个component时，就会报错。再比如Aminx里面有，引入它的component也有find()方法。那么也会报错。除非他们不是find()的方法，而是声明周期的方法。123456789101112131415161718192021222324252627var Amixin = &#123; find: function () &#123; //... &#125;&#125;;var Bmixin = &#123; find: function () &#123; //... &#125;&#125;;//第一种情况var Component = React.createClass(&#123; mixins: [Amixin,Bmixin], render: function () &#123; return ( //... ) &#125;&#125;);//或者第二种情况var Component = React.createClass(&#123; mixins: [Amixin], find:function()&#123; //... &#125; render: function () &#123; return ( //... ) &#125;&#125;); 这两种情况都报错。那么如果这个时候我们确实用的是生命周期里面的方法，那么在第一种情况里面，声明周期方法调用顺序又是怎么样的？ Mixins数组引入的顺序，决定了Mixins里生命周期方法的执行顺序。并且都在当前组件里面的该方法前面调用。 另一个例子下面这个例子记录了从2014/1/1到现在的总秒数。123456789101112131415161718192021222324252627var IntervalMixin = &#123; setInterval:function(callback,interval)&#123; var token = setInterval(callback,interrval) this._intervals.push(token) return token &#125;, componentDidMount:function()&#123; this._intervals = [] &#125;, componentWillUnmount:function()&#123; this._interval.map(clearInterval) &#125; &#125; var Timer = React.createClass(&#123; mixins:[IntervalMixin], componentDidMount:function()&#123; this.setInterval(this.forceUpdate.bind(this),1000) &#125;, render:function()&#123; var from = Number(new Date(2014,0,1)) var to = Date.now() return ( &lt;div&gt;&#123;Math.round(to-from)/1000&#125;&lt;/div&gt; ) &#125; &#125;) ReactDOM.render(&lt;Timer /&gt;,document.getElementById('example')) 总结还是很好理解的。mixins大大的解决了代码重复的强大的工具。也减少了我们的阅读量。同时允许我们在不污染组件本身的情况下做一些丑陋的处理。当然也应该取思考，什么时候用mixin比较好。不要盲目的用。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"高大上的数据链路层的学习和整理","slug":"高大上的数据链路层的学习和整理","date":"2016-06-15T13:29:01.000Z","updated":"2016-06-15T13:54:20.000Z","comments":true,"path":"2016/06/15/高大上的数据链路层的学习和整理/","link":"","permalink":"http://sevencai.github.io/2016/06/15/高大上的数据链路层的学习和整理/","excerpt":"","text":"感觉这可能是最后一次认真的学习数据链路层了，以后TCP/IP/HTTP还会再去看专门的书，但是数据链路层有可能以后不会接触了。所以我觉得很有必要认真的记录和总结一次。大学已经过去了3/4,大四应该也都在工作中度过。最近体验比较深，珍惜现在的时光。我爱我的室友。这篇文章主要是记录我最想知道，也是我以后还想看到的一些知识点。文章里面可能有一些更细节的地方，我不会讲。比如PPP由哪些部分组成之类的。我感觉我记了以后也不会看，所以就干脆记录下我感兴趣的东西。:) 说明：整理和学习自：《计算机网络第6版》 -谢希仁编著。感谢。 数据链路层是OSI参考模型中的第二层，介乎于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。–from wiki 链路与数据链路首先区分下下面两个概念：链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 其实我先前一直不太明白适配器这个东西。下面会有详细点的解释。 链路层两种通信方式数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 数据链路层的数据单元是帧 数据链路层像个数字管道: 常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。 使用点对点通信三个基本问题(1) 封装成帧(2) 透明传输(3) 差错控制 封装成帧封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。 透明传输 如何解决透明传输问题呢？ 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。 字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 差错检测在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 这里面又涉及了循环冗余检验的原理，-在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 注意还要区分下：帧检验序列 FCS 帧检验序列不同与CRC，CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 PPP协议现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。 用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。 这里面协议具体的格式就不介绍了。就看下里面解决透明传输用的是零比特填充这种方法。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。 为什么点对点协议是数据链路层使用的最多的协议呢？因为它的特点很明显：简单；只检测差错而不是纠正差错；不适用序号，也不进行流量控制，可以同时支持多种网络层协议。 使用广播信道的数据链路层局域网的数据链路层 局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。 局域网具有如下的一些主要优点： 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和残存性。 下面是可能的局域网拓扑结构： 数据链路层的两个子层为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层： 逻辑链路控制 LLC (Logical Link Control)子层。 媒体接入控制 MAC (Medium Access Control)子层。 但是现在已经不适用LLC。LLC成为了过去时。 适配器的作用 网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (Network Interface Card)，或“网卡”。 适配器的重要功能： 进行串行/并行转换。 对数据进行缓存。 在计算机的操作系统安装设备驱动程序。 实现以太网协议。 计算机实际上是通过适配器和局域网进行通信的。 计算机与外界局域网的连接是通过通信适配器。适配器原来是插入主机箱内的一块网络接口板，或者是在个人PC上的一块网络接口板。这种接口板又称为网络接口卡NIC，或者我们经常称它为网卡。 由于现在计算机主板上都已经嵌入了这种适配器，不再单独使用网卡了。因此我们一般可以直接称为适配器了。 适配器和局域网的通信是通过电缆火鹤双绞线以串行传输方式进行的。而适配器和计算机之间的通信则是通过计算机主板上的I/O总线以并行传输的方式进行的。因此适配器的一个重要功能就是要进行数据串行和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有对数据进行缓存的存储芯片。 若在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机操作系统上。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置吧多长的数据块发送到局域网。或者应当在存储器的什么位置吧局域网传送的数据块存储下来。适配器还要能实现以太网的协议。 适配器在接收和发送各种帧的时候不使用计算机的CPU,这是CPU可以处理其他的任务。当适配器收到有差错的帧时，就把这个帧丢弃并且不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交个适配器，组装成帧以后发送到局域网。可以好好看看上面的一个图。 上面的几段文字摘录自《计算机网络第六版》，感谢，因为解决了我很多疑惑，以后别人再说高大上的适配器的时候，我就知道它到底是什么原理了，嘻嘻。 CSMA/CD 协议最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。 总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。 其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。 具有广播特性的总线上实现了一对一的通信。 什么是CSMA/CD协议载波监听多点接入/碰撞检测 CSMA/CD CSMA/CD 表示Carrier Sense Multiple Access with Collision Detection。 “多点接入”表示许多计算机以多点接入的方式连接在一根总线上。 “载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 什么是碰撞检测这里面要注意一个概念叫做：碰撞检测 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 以太网提供的服务以太网提供的服务是不可靠的交付，即尽最大努力的交付。 当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。 如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 使用广播信道的以太网集线器传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。 这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub) 集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。 使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。 集线器很像一个多接口的转发器，工作在物理层。 以太网的 MAC 层MAC 层的硬件地址 ：在局域网中，硬件地址又称为物理地址，或 MAC 地址。 适配器检查 MAC 地址 适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址. 如果是发往本站的帧则收下，然后再进行其他的处理。 否则就将此帧丢弃，不再进行其他的处理。 “发往本站的帧”包括以下三种帧： 单播(unicast)帧（一对一） 广播(broadcast)帧（一对全体） 多播(multicast)帧（一对多） 以太网的 MAC 帧格式 高速以太网速率达到或超过 100 Mb/s 的以太网称为高速以太网。 当吉比特以太网工作在全双工方式时（即通信双方可同时进行发送和接收数据），不使用载波延伸和分组突发。 扩展的局域网在物理层扩展局域网用多个集线器可连成更大的局域网，刚刚说过，集线器运行在物理层。 集线器优点和缺点用集线器扩展局域网的优点： 使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。 扩大了局域网覆盖的地理范围。 用集线器扩展局域网的缺点： 碰撞域增大了，但总的吞吐量并未提高。 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 在数据链路层扩展局域网在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。 网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口 使用网桥的优点 过滤通信量。 扩大了物理范围。 提高了可靠性。 可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。 网桥使各网段成为隔离开的碰撞域 使用网桥带来的缺点 存储转发增加了时延。 具有不同 MAC 子层的网段桥接在一起时时延更大。 网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。 在MAC 子层并没有流量控制功能。 网桥和集线器（或转发器）不同 集线器在转发帧时，不对传输媒体进行检测。 网桥在转发帧之前必须执行 CSMA/CD 算法。 若在发送过程中出现碰撞，就必须停止发送和进行退避。 透明网桥目前使用得最多的网桥是透明网桥(transparent bridge)。“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。 透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。 网桥自学习算法若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。 网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。 在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。 在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。 具体的步骤是 网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。 如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。 如没有，则通过所有其他接口（但进入网桥的接口除外）按进行转发。 如有，则按转发表中给出的接口进行转发。 若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。 总结主要是有下面一些知识点： 以太网是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率运行在多种类型的电缆上。 数据链路层主要使用的两种类型的信道：1：点对点信道 2：广播信道 三个数据链路层协议实现的基本问题：如何 1.封装成帧 2. 透明传输 3.差错检测 链路和数据链路的区别： 链路是指从一个结点到相邻结点的物理路线，而数据链路是指在链路的基础上还加上了保证运输的协议（包括实现这些协议的软件和硬件） 传输单元是: 帧，区别物理层bit 广播信道的实例：局域网（以太网). 由于以太网在局域网中占绝对优势，所以在今天以太网跟局域网是同义词.必须指出的是局域网工作的层次跨越了数据链路层和物理层。 适配器（网卡): 拥有物理层和数据链路层的功能. 包括RAM(处理器)和ROM(储存器),硬件地址在适配器的ROM中，软件地址即IP地址是在存储器中。 扩展以太网的2种方式：在物理层扩展：使用集线器； 在数据链路层扩展：使用网桥 最后看下下面这张图里面：网关是网络层之上的，路由器是网络层的，网关是数据链路层的，集线器是物理层的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"计算机网络的物理层做些什么工作？","slug":"计算机网络的物理层做些什么工作？","date":"2016-06-15T05:27:14.000Z","updated":"2016-06-15T13:52:30.000Z","comments":true,"path":"2016/06/15/计算机网络的物理层做些什么工作？/","link":"","permalink":"http://sevencai.github.io/2016/06/15/计算机网络的物理层做些什么工作？/","excerpt":"","text":"物理层解决什么问题？物理层主要关心如何传输信号,物理层的主要任务描述为确定与传输媒体的接口的一些特性，即： 机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。 电气特性 指明在接口电缆的各条线上出现的电压的范围。 功能特性 指明某条线上出现的某一电平的电压表示何种意义。 过程特性 指明对于不同功能的各种可能事件的出现顺序。 物理层上所传送数据的单位是比特，物理层的主要任务就是透明地传送比特流，其所要考虑的就是如何传输bit,需要用多大的电压代表“1”或“0”，怎样才能在各种传输媒体上传输比特流，而不是指具体的传输媒体。 下面是一个简单的数据通信系统模型。 数据通信系统可以包括三个部分：源系统，传输系统，端系统。 源系统包括：源点（如PC的键盘输入的汉字）+发送器端系统包括：终点+接受器 物理层的几个专业术语数据，信号，模拟，数字，码元 数据(data)——运送消息的实体。 信号(signal)——数据的电气的或电磁的表现。 模拟的(analogous)——代表消息的参数的取值是连续的。 数字的(digital)——代表消息的参数的取值是离散的。 码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 信道信道不等于电路。信道只是一个方向的传送信息的媒体。因此一条通信电路往往包含一条发送信息的通道和一条接受信息的通道。 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 基带(baseband)信号和带通(band pass)信号基带信号（即基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。 带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 几种最基本的调制方法:调幅(AM)调频(FM)调相(PM) 信道的极限容量任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 为之产生了 奈氏准则：为了避免码间串扰，码元的传输速率的上限值 信噪比：信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高 物理层下面的传输媒体导引型传输媒体：双绞线，同轴电缆，光缆非导引型传输媒体：无线，红外，大气激光 其中科普下：光纤的原理是：光线在纤芯中传输的方式是不断地全反射，它的带宽很大，所以传输速度才快。 信道复用技术复用(multiplexing)是通信技术中的基本概念 复用分为：频分复用，时分复用，波分复用，码分复用。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 码分复用 CDM常用的名词是码分多址 CDMA (Code Division Multiple Access)。 宽带接入技术ADSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。DSL 就是数字用户线(Digital Subscriber Line)的缩写。 用户接口盒用户接口盒 UIB (User Interface Box)要提供三种连接，即： 使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。 使用双绞线连接到用户的电话机。 使用电缆调制解调器连接到用户的计算机。 对比物理层和数据链路层曾经困扰我很长时间，就是物理层和数据链路层到底有什么区别？ 数据链路层简称为链路层，两台主机之间的数据传输总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。将网络层下来的数据报封装成帧，在相邻节点之间的链路上传送帧，每个帧包括数据和必要的控制信息。 物理层传送单元是bit,发送方发送0，接收方应当受到0，发送方发送1，则是1。因此物理层要要考虑的就是如何传输bit,需要用多大的电压代表“1”或“0”，怎样才能在各种传输媒体上传输比特流，而不是指具体的传输媒体。物理层还要确定连接电缆的插头应当有多少根引脚和如何连接。要注意的是：传递信息所用的一些物理媒体，如刚刚提到的双绞线，同轴电缆等等，并不是在物理层之内，而是在物理层协议的下面。因此也有人把物理媒体当做第0层，物理层为第一层。 总结这篇文章的主要目的是了解和总结物理层到底做些什么工作。以前很多见过但又讲不出来的东西都有了新的认识。比如ADSL,比如用户接口盒，比如机顶盒，比如半双工，全双工。在这个过程中还解决了我很多的困惑。主要参考资料是课本《计算机网络第6版》-谢希仁著。感谢。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"ES6变量的解构赋值","slug":"ES6变量的解构赋值","date":"2016-06-14T01:51:38.000Z","updated":"2016-12-12T02:59:48.000Z","comments":true,"path":"2016/06/14/ES6变量的解构赋值/","link":"","permalink":"http://sevencai.github.io/2016/06/14/ES6变量的解构赋值/","excerpt":"","text":"什么叫做解构？解构就是按照一定的模式，从数组或者对象中提取到对应的元素，然后把这些元素复制给新的变量。这样的过程叫做解构赋值。其中要注意两个地方，第一是提取对象必须是数组或者对象。如果不是对象或者数组，ES6会先把它转换成对象。如果转换不了，如null,undefined,则会报错。表示不能够解构。第二解构的作用是为了我们方便赋值。这是ES6的新用法。我写这篇文章的时候，火狐是已经实现了的。但是谷歌还没有。 Destructuring allows us to extract values from arrays and objects (even deeply nested) and store them in variables with a more convenient syntax. 直观感受先看两个简单的小例子，直观的感受下，解构的好处。对于数组过去我们是这样的：1234let arr = [1,2];a = arr[0];b = arr[1];//a-&gt;1,b-&gt;2 现在我们是这样的：12let [a,b]=[1,2];//same result 对于对象我们以前是这样的：123let obj = &#123;username:'Seven',password:'123'&#125;;let username = obj.username;let password = obj.password; 现在我们这样就行了：123let obj = &#123;username:'Seven',password:'123'&#125;;let &#123;username,password&#125; = obj;console.log(username); 有没有觉得很方便？：) ，注意这里的{}里面的起名必须和obj里面的键相同，否则得不到正确的值。 数组的解构赋值总结下，当我们使用：123var [var1,var2,var3]=arrconst [var1,var2,var3]=arrlet [var1,var2,var3]=arr 的时候，我们就是在用数组的解构赋值啦。 刚刚讲到概念的时候提到，就算是even deeply nested的时候仍然可以是赋值的。比如说：12345let arr = [2,3,[4,5],6];let [two,three,[four,five],six]=arr;console.log(four);//4//或者可以这样写let [two,three,[four,five],six]=[2,3,[4,5],6]; 所以我们实际上可以这样理解，解构赋值这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 下面看几个例子：1234let [,,three]=[1,,3] //three:3let [x, , y] = [1, 2, 3];//x:1,y:3let [one,...theothers]=[1,2,3,4];//one:1,theothers:[2,3,4]let [x, y, ...z] = ['a'];//x:a,y:undefined,z:[] 如果这种解构不对应，没有成功，也就是不是模式匹配，则就是undefined，如下面两个例子：12let [two]=[]; //two:undefinedlet [one,two]=[1]; //two:undefined 上面是数组的解构赋值，但要注意一个问题，如果右边不是数组的话，是会报错的。比如：12345let [one]=1;let [one]=null;let [one]=false;let [one]=&#123;&#125;;let [one]=undefined; 都会报下面的错：TypeError: (intermediate value)[&#39;@@iterator&#39;] is not a function。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。–from 阮一峰-解构赋值 数组解构可以有默认值如下面几个例子：12var [one=1]=[];//one:1var [one,two=2]=[1];//one:1,two:2 意思就是如果后面有值，就是用后面的值，如果后面没有值，就看有没有默认的，有的话就用默认的。再否则的话，就是取不到值啦。那么什么标准是有值，没值呢？ES6规定，如果严格等于（===）undefined,那么就是没有值，用默认值。比如下面的情况：12let [x=1]=[undefined];let [y=1]=[null]; 这个时候的情况就是：x=1,y=null啦，因为null不严格等于undefined。 并且这个取值还是惰性的，也就是只要后面判断的值不是undefined就不会是理会前面的默认赋值。下面这个例子中：1234function test()&#123; return '1';&#125;let [f=test()]=[1]; 此时f的值是1，因为不为undefined，所以test()这个函数根本不会执行。这叫做惰性取值。 再就是既然表达式可以（注意上面的例子并不是错的，只是因为后面有值，才不执行而已），那么变量也可以。但是变量一定还是要注意哪个原则，先声明后，才可以使用。所以下面的例子中： 1234let [x=1,y=x]=[];//x=1,y=1let [x=1,y=x]=[2];//x=2,y=2let [x=1,y=x]=[3,4];//x=3,y=4let [x=y,y=1]=[1,2];//报错 对象的解构赋值我们最开始的时候提到了：{}里面的起名必须和obj里面的键相同，否则得不到正确的值。这也是数组和对象的解构赋值的最大区别。因为数组是顺序结构，所以都是按找顺序取值就行了。但是对象不是单纯的以栈的数据结构来存储数据的，它包括了堆和栈。所以象的属性没有次序，变量必须与属性同名，才能取到正确的值。 基本的对象的解构赋值，是长这个样子的：12let &#123;A,B&#125;=&#123;A:a,B:b&#125;let &#123;B,A&#125;=&#123;A:a,B:b&#125; 上面的结果都是A=a,B=b;A，B的顺序没有影响，只要名字对应就行喽。 其实它内部是这样的：1let &#123;A=A,B=B&#125;=&#123;A:a,B:b&#125;; 所以如果比如我们想把a取出来，但是不想放在A这个名字里，可以向这样：1let &#123;A=C,B=D&#125;=&#123;A:a,B:b&#125;; 这个时候，我们打印处C，D的时候，就是值为a或者b。真正被赋值的是后面的这个C，D，如果没有C，D的时候赋值的才是A，B。 还要注意如果是用let或者const声明的话，这里的A，B，C，D都不能被赋值过，否则会报错。因为let和const中变量不能重新声明。如果是var还是可以的。12let C='test';let &#123;A=C,B=D&#125;=&#123;A:a,B:b&#125;;//error 如果把第二个let去掉也是可以的。这要注意。 刚刚我们讲过数组嵌套时，只要对应就行。对象也是可以嵌套的。如下面的例子：123var obj = &#123;get:['first',&#123;inner:'second'&#125;]&#125;;var &#123;get:[x,&#123;inner&#125;]&#125;;console.log(x+\" \"+y);//first second 注意这里的get不会被赋值，它在此处代表模式。如果你尝试打印出get,会得到ReferenceError: p is not defined的错。 与数组的解构赋值一样，对象的解构赋值也可以使用默认参数。 对象解构也可以有默认值123456789var &#123;one=1&#125; = &#123;&#125;; //one:1var &#123;one,two=2&#125;=&#123;1&#125;; //one:1,two:2var obj=&#123;username:'Seven',password:'123'&#125;;var &#123;username='匿名',password='null'&#125;=obj; //username:Seven,password:123var &#123;username:name='游客',password='null'&#125; = &#123;&#125;;//name:游客,password:nullvar &#123;username&#125;=&#123;wrong:'游客'&#125;;//username=undefined,解构失败，为undefined 上面这都是声明的时候直接赋值了。如果我们把声明和赋值分开，如下面的情况：123var username;&#123;username&#125;=&#123;username:'Seven'&#125; //wrong(&#123;username&#125;=&#123;username:'Seven'&#125;) //true 会报语法错误，SyntaxError: expected expression, got &#39;=&#39;这是由于{}在开头会被解析为代码块。解决方法是我们用（）把它扩起来。如上面所示。 那么这个对象的解构赋值用途大吗？其实可好用了，比如：1234567891011var obj = &#123; username:'Seven', password:'123', highestScore:function()&#123; console.log(100); &#125;, lowestScore:function()&#123; console.log(60); &#125;&#125;var &#123;username,password,highestScore,lowestScore&#125;=obj; 这样我们分别把普通值和方法赋值给了相应的变量。当我们打印处username的时候是Seven,当我们console.log(highestScore());的时候会得到100啦。 更多用途上面我们已经提到了一种最简单的用途，其实还有很多其他的用途，比如： 可以在函数中用1234function fn([x,y])&#123; return x*y;&#125;console.log(fn([1,2])); 可以在循环中用12[[1,2,3],[4,5,6]].map(([a,b,c])=&gt;a+b+c;) //[6,15][1,undefined,2].map((x='set')=&gt;x) //1,'set',2 上面的这几个例子，可能你会说，如果我不用解构，用原始传参也可以啊，看了下面的几个，你就不会这么说了。：） 返回多个值以前如果我们要返回多个值，就要把值包装成对象 或者数组，然后函数外面时候在拆分，这多麻烦。有了解构赋值，我们可以很容易就实现这一点。123456789function test()&#123; return [1,5,'Seven'];&#125;var [a,b,c]=test();function test1()&#123; return &#123;first:'1',second:'2',str:'this is a string'&#125;;&#125;var &#123;first,second,str&#125;=test1(); 这样我们就很容易的把每个值，直接放到变量里了。但是还是要注意，使用对象的解构时，要名称对应。 将参数和值对应起来以前我们在传参的时候，要时刻注意参数的对应。如果不对应，函数变量对应的值，就是不对的。12function test(a,b,c)&#123;&#125;test(1,2,3); 用数组的话是对应的。也是一组有次序的值。这个时候跟我们以前的用法没有太大的区别。12function test([a,b,c])&#123;&#125;test([1,2,3]); 但是当是对象的时候，就不是这样了。对象可以是一组无序的参数。12function test(&#123;x,y,z&#125;)&#123;&#125;test(&#123;y:1,x:2,z:4&#125;) 快速提取json对象中的值123456var jsonobj = &#123; username:'seven', password:'124', hobbies:['travelling','singing']&#125;var &#123;username,password,hobbies&#125; = jsonobj; 这个跟我们先前讲的highestScore()，有点类似。 默认参数过去我们可能是这样的。1234wechat = function(url,username,message)&#123; username = username || 'Seven'; message = message || 'message is null';&#125; 现在我们这样就行了：123456wechat = function(url,&#123; username='Seven', message='message is null', isLogin = 'no', cache = 'no'&#125;)&#123;&#125; 通过这样的传参形式，就避免了类似a=a||&#39;test&#39;这种写法。 总结主要是把变量的解构赋值，这块给理解了下。ES6的新特性要在平时刻意的多用。等到以后完全被浏览器支持的时候，用起来就方便多了。解构赋值的用途还是很多的，我觉得很棒。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"Internet(因特网)概述","slug":"Internet-因特网-概述","date":"2016-06-10T08:58:11.000Z","updated":"2016-06-11T01:26:32.000Z","comments":true,"path":"2016/06/10/Internet-因特网-概述/","link":"","permalink":"http://sevencai.github.io/2016/06/10/Internet-因特网-概述/","excerpt":"","text":"现在的网络是指“三网”，即电信网络、有线电视网络和计算机网络。发展最快的并起到核心作用的当然是计算机网络。下面介绍下因特网的概述，包括因特网的组成，网络，节点，链路等等概念。大概会有下面这些内容。 基本概念区分网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 （注意此结点不等于节点）互联网是“网络的网络”(network of networks)。连接在因特网上的计算机都称为主机(host)。 网络把许多计算机连接在一起。因特网则把许多网络连接在一起。 1983是因特网的诞生时间。 Internet 和 Internet 的区别以小写字母 i 开始的 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。 以大写字母I开始的的 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。 三级结构的因特网三级计算机网络，分为主干网、地区网和校园网（或企业网）。 因特网服务提供者 ISPInternet Service Provider因特网服务提供者，所以ISP到底是什么呢？ 我们所有的用户都是通过ISP上网的。 根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。 下面是具有三层 ISP 结构的因特网的概念示意图： 因特网的组成 边缘部分 由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换） 端系统处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统(end system)。 主机通信“主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。 即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”。 两种通信方式在网络边缘的端系统中运行的程序之间的通信方式通常可划分为两大类：客户-服务器方式即Client/Server方式 ,对等方式即 Peer-to-Peer方式 。 客户-服务器方式（C/S 方式）客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。客户是服务的请求方，服务器是服务的提供方。 客户软件的特点被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。不需要特殊的硬件和很复杂的操作系统。 服务器软件的特点一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求，因此，服务器程序不需要知道客户程序的地址。一般需要强大的硬件和高级的操作系统支持。 对等连接方式 对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。 对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。 因特网的核心部分网络核心部分是因特网中最复杂的部分。 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器(router)。 在因特网核心部分的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 路由器的作用路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 为了了解分组交换，我们看下有哪些交换。 三种交换方式电路交换两部电话机只需要用一对电线就能够互相连接起来。 5 部电话机两两相连，需 10 对电线。N 部电话机两两相连，需 N(N – 1)/2 对电线。当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。 当电话机的数量增多时，就要使用交换机来完成全网的交换任务。 在这里，“交换”(switching)的含义就是转接——把一条电话线转接到另一条电话线，使它们连通起来。从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。 电路交换必定是面向连接的。 电路交换的三个阶段：建立连接,通信,释放连接. A 和 B 通话经过四个交换机,通话在 A 到 B 的连接上进行.很明显，电路交换传送计算机数据效率低。 分组交换 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段前面添加上首部构成分组。 分组交换网以“分组”作为数据传输单元。 依次把各分组发送到接收端（假定接收端在左边）。 每一个分组的首部都含有地址等控制信息。 分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。 用这样的存储转发方式，最后分组就能到达最终目的地。 接收端收到分组后剥去首部还原成报文。 最后，在接收端把收到的数据恢复成为原来的报文。 注意：这里我们假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。 过程如下： 注意分组的数据包到达目的地的路径可以不相同。中间可能有很多个路由器，每到一个路由器就：在路由器中暂存查找转发表找到转发的端口。 分组交换的优点 高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。分组交换的缺点 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。 报文交换存储转发原理并非完全新的概念，在 20 世纪 40 年代，电报通信也采用了基于存储转发原理的报文交换(message switching)。报文交换的时延较长，从几分钟到几小时不等。现在报文交换已经很少有人使用了。 路由器路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。 这里注意：主机和路由器的作用不同 主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组。路由器对分组进行存储转发，最后把分组交付目的主机。 下面这个图，是书上的经典图。对比了三种交换。 计算机网络的概念发生根本变化早期的面向终端的计算机网络是以单个主机为中心的星形网，各终端通过通信线路共享昂贵的中心主机的硬件和软件资源。 分组交换网则是以网络为中心，主机都处在网络的外围。用户通过分组交换网可共享连接在网络上的许多硬件和各种丰富的软件资源。 计算机网络的分类再来看下网络的定义：最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。 从网络的作用范围进行分类广域网 WAN (Wide Area Network)局域网 LAN (Local Area Network)城域网 MAN (Metropolitan Area Network)个人区域网 PAN (Personal Area Network) 从网络的使用者进行分类公用网 (public network)专用网 (private network) 计算机网络的性能指标速率比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。 速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等。速率往往是指额定速率或标称速率。 带宽“带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。 现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 更常用的带宽单位是： 千比每秒，即 kb/s （103 b/s）兆比每秒，即 Mb/s（106 b/s）吉比每秒，即 Gb/s（109 b/s）太比每秒，即 Tb/s（1012 b/s） 请注意：在计算机界，K = 2的10次方 = 1024，M = 2的20次方, G = 2的30次方, T = 2的40次方 吞吐量吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 时延(delay 或 latency) 发送时延 发送数据时，数据帧从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 传播时延 电磁波在信道中需要传播一定的距离而花费的时间。信号发送速率和信号在信道上的传播速率是完全不同的概念。 处理时延处理时延 交换结点为存储转发而进行一些必要的处理所花费的时间。 排队时延结点缓存队列中分组排队所经历的时延。 排队时延的长短往往取决于网络中当时的通信量。 对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。提高链路带宽减小了数据的发送时延。 时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。时延带宽积 = 传播时延 * 带宽 利用率信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好。 D=D0/1-U,U 是网络的利用率，数值在 0 到 1 之间。 协议与划分层次网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 #### 网络协议的组成要素 语法 数据与控制信息的结构或格式 。 语义 需要发出何种控制信息，完成何种动作以及做出何种响应。 同步 事件实现顺序的详细说明。 划分层次主机 1 向主机 2 通过网络发送文件。两个主机将文件传送模块作为最高的一层 。剩下的工作由下面的模块负责。各层之间是独立的。灵活性好。结构上可分割开。易于实现和维护。能促进标准化工作。 这样分层的好处有很多：比如各层之间是独立的。灵活性好。结构上可分割开。易于实现和维护。能促进标准化工作。若层数太少，就会使每一层的协议太复杂。层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。 计算机网络的体系结构 计算机网络的体系结构(architecture)是计算机网络的各层及其协议的集合。 TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。但最下面的网络接口层并没有具体内容。因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 这里就不介绍七层结构了，因为已经被淘汰了。 整个比如说有两个主机A,B，他们进行通信的过程就是： 什么是实体、协议、服务和服务访问点 实体：实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 协议：协议是控制两个对等实体进行通信的规则的集合。 服务：在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 服务访问点SAP：同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。 注意下面几个问题： 本层的服务用户只能看见服务而无法看见下面的协议。 下面的协议对上面的服务用户是透明的。 协议是“水平的”，即协议是控制对等实体之间通信的规则。 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。 IP over Everything 路由器在转发分组时最高只用到网络层而没有使用运输层和应用层。 IP 可应用到各式各样的网络上 总结总结和整理自《计算机网络第六版》，部分图片也来自该书，感谢。大概的是能够对整个体系中最重要的知识做了个概述和总结。还有一些基本的关键词和专业术语的了解，比如ISP等等。这些也是很重要的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"计算机网络体系结构脑图分享","slug":"计算机网络体系结构脑图分享","date":"2016-06-05T08:14:35.000Z","updated":"2016-06-05T08:34:16.000Z","comments":true,"path":"2016/06/05/计算机网络体系结构脑图分享/","link":"","permalink":"http://sevencai.github.io/2016/06/05/计算机网络体系结构脑图分享/","excerpt":"","text":"今天把计算机网络体系结构梳理了下，用的是百度脑图。地址分享给大家：【脑图地址戳这里】因为整个太大了，导出成图片后，也是不能够直接看的，所以只能放地址了。 整个过程下来，发现百度脑图做的很方便，是个很好的产品，但是也还是有一点小bug。还有就是对整个体系结构有了更深的了解。大概是底下这个模样。 点开+号，就可以看里面更具体的内容啦。然后因为要下个星期就要考网络的原因，我会一边复习，一边整理和记录更加具体的东西，然后发成博客分享给大家。谢谢wuli帅气的网络老师。这学期听的最认真的也就是李鹏老师的课啦。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"操作系统存储管理","slug":"操作系统存储管理","date":"2016-05-29T06:45:10.000Z","updated":"2016-12-12T02:33:46.000Z","comments":true,"path":"2016/05/29/操作系统存储管理/","link":"","permalink":"http://sevencai.github.io/2016/05/29/操作系统存储管理/","excerpt":"","text":"任何的程序指令必须先装入内存。当用户提出主存空间的要求时，应该要能快速响应。并且为它分配相应的内存空间。然后，当用户使用完毕后，应该立即回收其存储空间，以供其他用户使用。 下面这篇文章就是我总结的存储管理需要知道的一些基本知识。最重要的一部分是【实现内存空间的分配和回收】，这也是操作系统存储管理的核心。 下面先来看一张简单的图： 所以存储管理的功能主要包括下面三个部分： 建立内存分配登记表，记录哪些已经被分配，哪些没有被分配 实施分配内存，当有作业提出要求时，按照一定的原则分配，并且要修改一说的内存分配登记表 内存回收，由操作系统的内存管理程序负责回收资源，并修改相应内存分配登记表 地址转换用户装入主存之前是逻辑地址，装入之后是物理地址。要有相应的硬件机构配合，将物理地址转换成物理地址。 逻辑地址和逻辑空间地址空间：一个程序限定的地址范围。 源程序经过汇编或者编译后，形成目标程序，每个目标程序都是以0为基址顺序进行编制的。这样生成的目标程序就会占据一定空间。成为作业的逻辑空间。 物理地址与物理空间内存以字节为编址空间。分别由0，1，2….这样编号。这个唯一的编号就是内存单元中的物理地址。可以直接通过这个编号寻址。 一个编译好的程序在自己的逻辑空间中。运行时，要把它装入内存空间。在多道程序中，每个用户不可能用内存的物理地址来编写程序。我们需要一种存储管理机制提供地址映射功能将用户程序中的逻辑地址转换成运行时机器可以直接寻址的物理地址。这个功能叫做地址映射或者地址重定位。 地址重定位方式静态地址重定位静态重定位是在程序装入过程中，由操作系统的重定位装入程序一次完成作业的地址转换过程。以后不再转换。即直接修改指令中的地址代码，把这些地址代码从逻辑转换成物理。 静态地址重定位优点 由于在程序执行前就完成了地址转换，所以执行速度快。 地址转换方法无需硬件支持，在硬件中容易实现。 静态地址重定位缺点 程序一旦经过转换后，其占用的存储空间就不能变了，所以静态地址重定位不能再内存中移动。 程序必须分配连续的存储空间，不能把程序放在若干个不连续的区域中，这些不利于存储空间的充分利用。 程序中涉及的所有要转换地址的指令，不管程序运行过程是否会执行到，都必须转换。这就有可能有些指令实施了转换，但根本不会执行。因此做了不必要的工作。 程序共享不方便，用户必须事先确定所需的存储量，若所需的存储量超过可用的存储空间，用户必须覆盖结构。 动态地址重定位动态地址重定位的作业是在装入时，不进行地址转换，而是直接把作业装到分配的主存区域中，执行过程中再进行地址重定位。 这个过程中需要重定位寄存器（硬件支持），它用来存放用户作业装入主存空间的起始地址。 在程序执行过程中，执行到访问内存指令的时候，并不立即把指令中的地址码送到地址总线，而是先经过动态地址重定位机制，由地址转换硬件逻辑自动把指令中的相对地址码与定位寄存器的值相加，形成物理地址码，然后把这个地址码送到地址总线，以此来实现对内存存储单元的访问。这个过程中，动态地址重定位的过程是在执行访问内存指令时，由硬件机制自动完成地址转换的。所以对程序执行的速度没有太大影响。 这个过程中，可以看到，执行前或者执行中代码没有任何变化。所以也可以实现内存的移动，对后面内存碎片提供了技术支持。 并且也可以在互补连续的内存空间，只要各程序段有自己对应的重定位寄存器，有利于内存资源的充分利用和共享。 缺点就是硬件支持需要，系统开销大，实现村粗管理的软件比较复杂。 存储保护在多道系统中，内存中的许多用户或系统程序和数据段可以提供不同的用户进程共享。这样会提高内存的利用率。但是，我们也需要限制各个进程只在自己的存储区活动。除了共享的以外，各进程不能对别人的进程的程序和数据段产生干扰和破坏，因此必须对内存中的程序和数据段采用存储保护措施。 主要是两方面： 防止地址越界（上，下界存储保护和基址限长） 存取权限控制（每个进程都有自己的访问权限） 存储扩充多个程序同时在系统中运行，往往受内存容量的限制。使得有些大程序不能装入系统运行，或者只能装入很少的程序。解决办法可能有下面两种： 从硬件上：增加内存芯片的数量从软件上：虚拟存储器，实现逻辑上的扩充 分区存储管理分区存储管理是多道程序运行环境中最简单的存储管理方法，基本思想就是讲内存划分为若干个连续区域，成为分区。每个分区只放一个程序。 单一连续分配方案一段时间内，只能有一个进程在内存的用户可用区。内存空间中，只有一道用户进程。这一般由单道系统采用。 固定分区在作业未进入内存之前，就由操作员吧内存划分为若干个固定存储区。除操作系统占用一个区域外，其他的为用户共享。分区一旦划分，就不可以变。由于一个分区只存放一个进程，所以系统可以同时运行的最大进程道数就是内存分区的大小。通常采用静态地址重定位。注意这个每个分区的大小可以不同。固定分区表，分区的分配，分区的回收。这是要做的主要工作。缺点也很明显。严重浪费，碎片大，影响内存利用率。 可变分区管理内存中除了操作系统的区域外，对内存剩余空间预先不划分分区，初始构成一个大的空闲去。当作业装入时，根据作业的大小，在内存的空闲区划分出一个连续的存储区域。作为分区分配给给作业使用。这里面涉及到碎片问题，还有移动和覆盖。 这里面主要要有：建立空闲区表，内存分配，可变分区的回收，地址转换和存储保护。 内存分配中又涉及到三种方法：最先适应算法，最佳适应算法，最坏适应算法。 最先适应算法(nrst-fit)：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 最佳适应算法(best-fit)：按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适应算法(worst- fit)：按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 页式存储管理将进程分配在不连续但大小先疼痛的存储区域中，实现内存见缝插针的分配，同时又保证进程的连续执行。页式技术包括：先把内存空间分块，再把用户程序逻辑空间分页，再以页为单位分配内存。 具体步骤 等分内存 页式存储管理将内存空间划分成等长的若干区域 每个区域的大小一般取2的整数幂，称为一个物理页面有时称为块。 内存的所有物理页面从0开始编号，称作物理页号。 逻辑地址 系统将程序的逻辑空间按照同样大小也划分成若干页面，称为逻辑页面也称为页。 程序的各个逻辑页面从0开始依次编号，称作逻辑页号或相对页号。 每个页面内从0开始编址，称为页内地址。程序中的逻辑地址由两部分组成：页号和页内位移 内存分配 系统可用一张“位示图”来登记内存中各块的分配情况，存储分配时以页面（块）为单位，并按程序的页数多少进行分配。 相邻的页面在内存中不一定相邻，即分配给程序的内存块之间不一定连续。 对程序地址空间的分页是系统自动进行的，即对用户是透明的。 由于页面尺寸为2的整数次幂，故相对地址中的高位部分即为页号，低位部分为页内地址。 实现原理1．页表 系统为每个进程建立一张页表，用于记录进程逻辑页面与内存物理页面之间的对应关系。地址空间有多少页，该页表里就登记多少行，且按逻辑页的顺序排列。 2．地址映射过程 页式存储管理采用动态重定位，即在程序的执行过程中完成地址转换。处理器每执行一条指令，就将指令中的逻辑地址（p,d）取来从中得到逻辑页号(p)，硬件机构按此页号查页表，得到内存的块号B’，便形成绝对地址（B’,d）,处理器即按此地址访问主存。 3．页面的共享与保护 当多个不同进程中需要有相同页面信息时，可以在主存中只保留一个副本，只要让这些进程各自的有关项中指向内存同一块号即可。同时在页表中设置相应的“存取权限”，对不同进程的访问权限进行各种必要的限制。 页式管理方式的优点没有外碎片，程序不必连续存放，便于改变程序占用空间的大小。 页式管理方式的缺点要求程序全部装入内存，没有足够的内存，程序就不能执行。 除了页式存储管理，还有段式存储管理。 覆盖和交换技术覆盖技术引入覆盖 (overlay)技术的目标是在较小的可用内存中运行较大的程序。这种技术常用于多道程序系统之中，与分区式存储管理配合使用。 覆盖技术的原理：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。将程序必要部分(常用功能)的代码和数据常驻内存；可选部分(不常用功能)平时存放在外存(覆盖文件)中，在需要时才装入内存。不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖 覆盖技术的缺点是编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度；从外存装入覆盖文件，以时间延长换取空间节省。 交换技术交换 (swapping)技术在多个程序并发执行时，可以将暂时不能执行的程序（进程）送到外存中，从而获得空闲内存空间来装入新程序（进程），或读人保存在外存中而处于就绪状态的程序。交换单位为整个进程的地址空间。交换技术常用于多道程序系统或小型分时系统中，因为这些系统大多采用分区存储管理方式。与分区式存储管理配合使用又称作“对换”或“滚进／滚出” (roll-in／roll-out)。 原理：暂停执行内存中的进程，将整个进程的地址空间保存到外存的交换区中（换出swap out），而将外存中由阻塞变为就绪的进程的地址空间读入到内存中，并将该进程送到就绪队列（换入swap in）。 两者比较交换花费大量内，外存交换时间。两者都实现了大作业在小内存上运行。 覆盖于与换技术的区别： a. 覆盖由用户解决空间不足问题（即：覆盖只能在一个程序内部进行） b. 交换由系统解决空间不足问题（即：交换可以在任意程序间进行） c. 覆盖对程序结构有严格的限制，交换对程序结构没有限制（这也是由于a,b的原因） 虚拟存储器什么是虚拟存储器当代计算机系统的主存主要由半导体存储器组成，由于工艺和成本的原因，主存的容量受到限制。然而，计算机系统软件和应用软件的功能不断增强，程序规模迅速扩大，要求主存的容量越大越好，这就产生了矛盾。为了给大的程序提供方便，使它们摆脱主存容量的限制，可以由操作系统把主存和辅存这两级存储系统管理起来，实现自动覆盖。 一个大作业在执行时，其一部分地址空间在主存，另一部分在辅存，当所访问的信息不在主存时，则由操作系统而不是程序员来安排I/O指令，把信息从辅存调入主存。从效果上来看，好像为用户提供了一个存储容量比实际主存大得多的存储器，用户无需考虑所编程序在主存中是否放得下或放在什么位置等问题。我们称这种存储器为虚拟存储器。 虚拟存储器只是一个容量非常大的存储器的逻辑模型，不是任何实际的物理存储器。它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。虚拟存储器指的是主存－外存层次，它以透明的方式为用户提供了一个比实际主存空间大得多的程序地址空间。 物理地址是实际的主存单元地址，由CPU地址引脚送出，是用于访问主存的。设CPU地址总线的宽度为m位，则物理地址空间的大小就是2m。 虚拟地址是用户编程时使用的地址，由编译程序生成，是程序的逻辑地址，其地址空间的大小受到辅助存储器容量的限制。显然，虚拟地址要比实际地址大得多。程序的逻辑地址空间称为虚拟地址空间。 判断过程程序运行时，CPU以虚拟地址来访问主存，由辅助硬件找出虚拟地址和实际地址之间的对应关系，并判断这个虚拟地址指示的存储单元内容是否已装入主存。如果已在主存中，则通过地址变换，CPU可直接访问主存的实际单元；如果不在主存中，则把包含这个字的一个存储块调入主存后再由CPU访问。如果主存已满，则由替换算法从主存中将暂不运行的一块调回外存，再从外存调入新的一块到主存。 总结主要是了解了操作系统是怎么进行内存分配的，怎么进行管理进程进入内存的。了解了覆盖和交换技术的区别和联系。了解了分区管理和页式管理的区别。对存储分配和管理有了一点认识。解决了一点点心中的疑惑，本意记录下来方便以后查阅。","categories":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"闭包深入理解阅读笔记","slug":"闭包深入理解阅读笔记","date":"2016-05-26T09:15:27.000Z","updated":"2016-12-12T03:02:30.000Z","comments":true,"path":"2016/05/26/闭包深入理解阅读笔记/","link":"","permalink":"http://sevencai.github.io/2016/05/26/闭包深入理解阅读笔记/","excerpt":"","text":"今天去看了很多关于闭包的解释，比如MDN上的：Closures的解释或者是在stackoverflow别人的一些总结。发现了自己有很多很多的误区。比如潜意识认为闭包是一定要在一个函数内返回（return）一个函数，才是闭包。这是很错误的。再比如认为闭包会导致内存泄漏。前几个月面试的时候，有时候会说闭包会导致内存泄漏，但是面试官们也没有给我指出来。闭包不会导致内存泄漏，会占用内存，还好及时发现了。看到了一些好的解释都是以讲故事的形式解释的，中间不一定对，但是都是帮助了我理解的。还看了一些咱们自己翻译的外国人的故事，或者文章，在看了原文以后，发现还是看原文比较好懂，也比较清晰。 下面是我找到的一些解释，这些解释大多是英文，放在博客里面也只是方便我翻阅和记录,不用到处找。我没有进行任何翻译，也没有写任何自己的理解。并不是原创，我想保留原作者的原文。也会标注上作者和来源。 a story help you understand下面是我发现最好懂的一个故事，来自stackoverflow:Tero Tolonen,地址在这里 The children will always remember the secrets they have shared with their parents, even after their parents are gone. This is what closures are for functions. The secrets for JavaScript functions are the private variables 123var parent = function() &#123; var name = \"Mary\"; // secret&#125; Every time you call it, local variable “name” is created and given name “Mary”. And every time the function exits the variable is lost and the name is forgotten. As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called Chamber of Secrets or stack or local scope but it doesn’t really matter. We know they are there, somewhere, hidden in the memory. But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.123456var parent = function() &#123; var name = \"Mary\"; var child = function(childName) &#123; // I can also see that \"name\" is \"Mary\" &#125;&#125; So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place. But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them. So to live, the child has to leave before it’s too late 12345678var parent = function() &#123; var name = \"Mary\"; var child = function(childName) &#123; return \"My name is \"+childName+\", child of \"+name; &#125; return child; // child leaves the parent -&gt;&#125;var child = parent(); // &lt; - and here it is outside And now, even though Mary is “no longer running”, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together. So, if you call the child “Alice”, she will respond1child(\"Alice\") =&gt; \"My name is Alice, child of Mary\" That’s all there is to tell. misunderstandingsThis is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers. 来自stackoverflow:地址在这里 A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created as soon as the enclosing function is called since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. A closure does not reference a copy of the old values of variables in its scope. The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called. The “variables” in a closure include any named functions declared within the function. They also include arguments of the function. A closure also has access to its containing closure’s variables, all the way up to the global scope. Closures use memory, but they don’t cause memory leaks since JavaScript by itself cleans up its own circular structures that are not referenced. Internet Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures. Closures provide an environment, a stack frame, for local variables. read examples to understand better1234567function sayHello2(name) &#123; var text = 'Hello ' + name; // Local variable var say = function() &#123; console.log(text); &#125; return say;&#125;var say2 = sayHello2('Bob');say2(); // logs \"Hello Bob\" 123456789function say667() &#123; // Local variable that ends up within closure var num = 666; var say = function() &#123; console.log(num); &#125; num++; return say;&#125;var sayNumber = say667();sayNumber(); // logs 667 12345678910111213141516171819202122var gLogNumber, gIncreaseNumber, gSetNumber;function setupSomeGlobals() &#123; // Local variable that ends up within closure var num = 666; // Store some references to functions as global variables gLogNumber = function() &#123; console.log(num); &#125; gIncreaseNumber = function() &#123; num++; &#125; gSetNumber = function(x) &#123; num = x; &#125;&#125;setupSomeGlobals();gIncreaseNumber();gLogNumber(); // 667gSetNumber(5);gLogNumber(); // 5var oldLog = gLogNumber;setupSomeGlobals();gLogNumber(); // 666oldLog() // 5 12345678910111213141516function buildList(list) &#123; var result = []; for (var i = 0; i &lt; list.length; i++) &#123; var item = 'item' + i; result.push( function() &#123;console.log(item + ' ' + list[i])&#125; ); &#125; return result;&#125;function testList() &#123; var fnlist = buildList([1,2,3]); // Using j only to help prevent confusion -- could use i. for (var j = 0; j &lt; fnlist.length; j++) &#123; fnlist[j](); &#125;&#125; 1234567function sayAlice() &#123; var say = function() &#123; console.log(alice); &#125; // Local variable that ends up within closure var alice = 'Hello Alice'; return say;&#125;sayAlice()(); 123456789101112131415161718192021function newClosure(someNum, someRef) &#123; // Local variables that end up within closure var num = someNum; var anArray = [1,2,3]; var ref = someRef; return function(x) &#123; num += x; anArray.push(num); console.log('num: ' + num + '\\nanArray ' + anArray.toString() + '\\nref.someVar ' + ref.someVar); &#125;&#125;obj = &#123;someVar: 4&#125;;fn1 = newClosure(4, obj);fn2 = newClosure(5, obj);fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4;fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4;obj.someVar++;fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5; 闭包的用途用闭包模拟私有方法来自MDNCLOSURES 诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。 对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：123456789101112131415161718192021222324var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;)();console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。 该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。 这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。 您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。 123456789101112131415161718192021222324252627var makeCounter = function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;;var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */ 请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。 这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。 容易犯的错误-在循环中创建闭包v1234567891011121314151617181920function showHelp(help) &#123; document.getElementById('help').innerHTML = help;&#125;function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;&#125;setupHelp(); 组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。 运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。 该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。 解决这个问题的一种方案是使onfocus指向一个新的闭包对象。123456789101112131415161718192021222324function showHelp(help) &#123; document.getElementById('help').innerHTML = help;&#125;function makeHelpCallback(help) &#123; return function() &#123; showHelp(help); &#125;;&#125;function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125;&#125;setupHelp(); 性能考量如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。 考虑以下虽然不切实际但却说明问题的示例： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; } 上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype = { getName: function() { return this.name; }, getMessage: function() { return this.message; } }; 或者改成： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function() { return this.name; }; MyObject.prototype.getMessage = function() { return this.message; }; 在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。 总结感谢MDN-Web/JavaScript/Closures还有这篇文章stackoverflow。整体的把自己一些错误的想法稍微给纠正了，然后加深了对闭包的理解。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"ES6的箭头函数和块级作用域","slug":"ES6的箭头函数和块级作用域","date":"2016-05-24T10:59:05.000Z","updated":"2016-12-12T02:59:46.000Z","comments":true,"path":"2016/05/24/ES6的箭头函数和块级作用域/","link":"","permalink":"http://sevencai.github.io/2016/05/24/ES6的箭头函数和块级作用域/","excerpt":"","text":"最近要好好学下ES6,下文主要是对箭头函数和const,let的稍微详细点的理解。里面我主要的学习方法是写小例子，然后去分析ES6通过babel转码后有什么区别和和两者的对比。babel的使用可以看下：bable install，这里不涉及babel的使用。 箭头函数（Arrow Functions）箭头函数最好的一点当然是箭头函数preserve the context of this from its lexical scope，保存我们上下文作用域中的this的指向。因为一般我们可能会遇到下面这些问题： 1234567891011function Person(name)&#123; this.name = name&#125;Person.prototype.add = function(arr)&#123; return arr.map(function(item)&#123; return this.name+item &#125;)&#125;var arr=['cld','seven']var person = new Person('n6303-')console.log(person.add(arr)) [ &#39;undefinedcld&#39;, &#39;undefinedseven&#39; ]，最后结果是这个。因为当我们使用nested functions的时候，this的指向会发生变化。所以，我们没有箭头函数以前，是这样解决的： 12345Person.prototype.add = function(arr)&#123; return arr.map(function(item)&#123; return this.name + item &#125;,this)&#125; 或者是通过bind,这样解决的：12345Person.prototype.add = function(arr)&#123; return arr.map(function(item)&#123; return this.name + item &#125;.bind(this))&#125; 或者是这样解决的，通过：that=this:123456Person.prototype.add = function(arr)&#123; var that = this return arr.map(function(item)&#123; return that.name + item &#125;)&#125; 以上三种方法都能够解决。但是当我们有了箭头函数，就更加容易了：123Person.prototype.add = function(arr)&#123; return arr.map((item)=&gt;this.name+item)&#125; 而且最好的就是箭头函数大部分浏览器都支持啦。而且对于返回值只有一个的时候，箭头函数非常简洁，比如：123var arr = [1,3,4]console.log(arr.map(function(item)&#123;return item*item&#125;))console.log(arr.map((item)=&gt;item*item)) 通过babel转码后，箭头函数是这样的,跟自己写的一样：1console.log(arr.map(function(item)&#123;return item*item&#125;)) let and constlet与var之变量提升的区别ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。相当于增加了块级作用域。 先看下下面的输出结果：1234567891011121314151617var global = \"global\"function test1(para)&#123; if(para)&#123; var global = \"inner\" return global &#125; return global&#125;function test2(para)&#123; if(para)&#123; let global = \"inner\" return global &#125; return global&#125;console.log(test1(false))console.log(test2(false)) 结果分别是：undefined,global。第一个是因为var 有变量提升，而let没有变量提升。我们可以看一下当我们通过babel编译以后会得到什么结果：123456789101112131415161718\"use strict\";var global = \"global\";function test1(para) &#123; if (para) &#123; var global = \"inner\"; return global; &#125; return global;&#125;function test2(para) &#123; if (para) &#123; var _global = \"inner\"; return _global; &#125; return global;&#125;console.log(test1(false));console.log(test2(false)); babel把我们的let变成了var,并且把变量名称换了。正是因为let不存在变量提升，所以我们要先声明再使用。否则会报错，而不是输出undefined。 再来看下面这个例子：1234&#123; var a = 3; let b =4;&#125; 会被编译成下面这样。所以最后会报错。因为我们在外部打印b的时候，是ReferenceError: b is not defined。123456&#123; var a = 3; var _b = 4;&#125;console.log(a)console.log(b) let和var在闭包中的作用由于i是var声明的。所以是全局变量。全局范围内都有效。所以当我们不管是调用哪一个a，都是输出最后一个i,也就是3。123456789101112131415var a = []for(var i=0;i&lt;4;i++)&#123; a[i] = function()&#123; console.log(i) &#125;&#125;a[2]()var b = []for(let i=0;i&lt;4;i++)&#123; b[i] = function()&#123; console.log(i) &#125;&#125;b[2]() 我看了下babel编译后的结果。编译后它处理的方法是把函数声明提到了外面。我们通常也可以用里面(function(i){})(i)这中方法。12345678910111213141516var a = [];for (var i = 0; i &lt; 4; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;var b = [];var _loop = function _loop(_i) &#123; b[_i] = function () &#123; console.log(_i); &#125;;&#125;;for (var _i = 0; _i &lt; 4; _i++) &#123; _loop(_i);&#125; 可惜了，我现在用谷歌来测试还是不能用。期待那么一天。火狐还是很好的。 let不允许重复声明我们用var 的时候，都可以一直就重新声明。想重新声明就重新声明。但是let不允许在相同作用域内，重复声明同一个变量。比如先var a=1,再let a=2，这是不行的。再比如let a=1;let a=2这也是不行的。那比如说，我在一个函数内传入了一个param,我们let param = other值，这也是不行的。但是注意这前提室相同作用域如果是不同作用域肯定就是可以了，比如先let a=1,然后{let a=1},这样开辟了一个新的作用域。肯定是可以重复声明的。内层作用域可以定义外层作用域的同名变量。 123456789101112131415function f() &#123; &#123; let x; &#123; // okay, block scoped name const x = \"sneaky\"; // error, const x = \"foo\"; &#125; // okay, declared with let x = \"bar\"; // error, already declared in block let x = \"inner\"; &#125;&#125; 需要块级作用域let的原因 由于var是可以随时重新声明赋值的，又因为有变量提升这么回事，所以经常就会出现undefined的错误。内部变量覆盖了外部变量。 消除刚才我们提到的，由于循环计数的原因，导致了变量泄露成了全局变量。 我在想是不是可以这么理解，当我们使用了{}这个的时候，{}内部的和{}外部的元素就形成了两个不同的块级作用域。无论是我们直接{}还是通过if(){}或者function(){}这样。我不知道我这样总结的是不是太绝对了。 我们先前的是：内部作用域可以访问外部作用域。因为作用域链的存在。外部作用域不能访问内部作用域。因为作用域链只能向上查找。let的出现并没有影响这一点。 而且正是因为let的出现，以后估计我们的匿名函数（用于保护全局变量）用的也就会少很多了。 1234(function () &#123; var food = 'meat';&#125;());console.log(food); // Reference Error 1234&#123; let food = 'vegetables;&#125;console.log(food); // Reference Error const是single-assignmentconst与我们先前学习别的语言一样，代表常量，一旦赋值就不可以改变。这也意味着必须在声明的时候赋值，否则后面不管再怎么赋值，都是错误的了。 这又包括两种情况，一种是普通模式，也就是没有用use strict,这种情况是重新赋值不会报错，但是值是不会变的，一直都是你最开始赋的初值。第二种情况是用了use strick，这种情况，是会报错的。 还有一点要注意，就是const的作用域是跟let一样，在当前的块级作用域里面的。外部作用域无法访问当前定义的const的作用域。 并且const也是不存在变量提升。这是个好事，让我们形成先定义，再使用的习惯，并且也可以有效的避免undefined这种情况发生。 还有一点，是我以前没有注意到的。感谢阮一峰老师的这个书。真棒。就是如果const定义的常量指向的是一个对象。这个时候，它实际上指向的是当前对象的地址。这个地址是在栈里面的，而这个真实的对象是在堆里面的。所以，我们使用const定义这个对象后，是可以改变对象的内容的。但是这个地址是不可以变的。意思也就是不可以给这个对象重新赋值，比如const foo={},foo = {},即使是这样foo好像什么都没有改变，但还是错误的。（然而我在普通模式下，并没有报错。。。）而foo.username=’cld’,这是完全可以的。这跟javascript存储引用对象的值的方式有密切的关系。 12345const obj = Object.freeze(&#123;&#125;)const b = &#123;&#125;obj.name = \"cld\"b.name = \"seven\" 这段代码会在babel下转成这样：12345var obj = Object.freeze(&#123;&#125;);var b = &#123;&#125;;obj.name = \"cld\";b.name = \"seven\"; 事实是不管我们是以const 然后freeze object，或者是不freeze,babel都是会把它转成var这种形势。因为babel本身的作用就是transform我们的es6的代码的。当然我们运行的话，会报错：TypeError: Can&#39;t add property name, object is not extensible。 在阮一峰老师的书里，我看到了他写的这样一块代码：12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 看到了以后，眼睛亮了，因为记得前1，2个月面试的时候，有个面试官问我，知不知道有一个函数，可以直接获得所有obj的key值。我确实没用过js里的这个，只知道php里面有类似的函数是array_keys(),后来下去查，也没查到。就一直记在心里。今天一看这段代码就知道了是Object.keys()，真好。比如下面这个测试： 12345678var obj = &#123;'username':['name1','name2'],'password':'seven'&#125;console.log(Object.keys(obj))Object.keys(obj).forEach(function(key,value)&#123; if(typeof obj[key] == 'object')&#123; console.log(obj[key]) &#125;&#125;) 打印结果是：[ ‘username’, ‘password’ ][ ‘name1’, ‘name2’ ] 有点偏题了。上面我的那段阮一峰老师的代码是为了让除了将对象本身冻结，对象的属性也冻结。 然后看下babel转码后，会得到啥样的结果：12345678var constanize = function constanize(obj) &#123; Object.freeze(obj); Object.keys(obj).forEach(function (key, value) &#123; if (_typeof(obj[key]) == 'object') &#123; constanize(obj[key]); &#125; &#125;);&#125;; babel把箭头函数给转了，然后加了引号。但是typeof前面加_下划线是什么呢？我知道一般来说加下划线的变量为私有变量。。？？ 还有就是加入let后，就算let是在window环境下声明的。通过let定义的属性，也不能通过window获得。var声明的可以通过window对象获得。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"用node写小爬虫","slug":"用node写小爬虫","date":"2016-05-22T15:55:58.000Z","updated":"2016-12-12T03:02:12.000Z","comments":true,"path":"2016/05/22/用node写小爬虫/","link":"","permalink":"http://sevencai.github.io/2016/05/22/用node写小爬虫/","excerpt":"","text":"先前有用php写过小爬虫，其实本质就是获取到网页中的Dom结构，然后分析里面的元素，提取出自己想要的东西。最近想找东西练练node,就想到用node做小爬虫。去看了看慕课网scott老师讲的。感觉很棒，学到了不少东西。自己跟着做了一篇，爬了下慕课网的课程。明天准备再去写一个脚本爬自己博客。下面是学到东西的总结。感谢scott老师。 最后结果大概是这样的。 中间我们要去分析慕课网的地址，然后得到类似下面的结构： 包模块的选择这里除了http核心模块外，还用到了bluebird和cheerio，这两个模块。bluebird封装了promise,可以异步来调用。cheerio则是可以让我们更方便的操作Dom,就可以像jquery一样来操作Dom。我们的目的是，分析dom结构，然后操作dom节点，获取我们想要的，并且拼接成下面的数组： 12345678910var coursesData = &#123; title:title, number:number, videos:[ title:title, videos:[ ] ]&#125; 直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111var http = require('http')var Promise = require('bluebird')var cheerio = require('cheerio')var baseUrl = 'http://www.imooc.com/learn/'var videoIds = [348,259,197,134,75]function filterChapter(data)&#123; var $ = cheerio.load(data) var title = $('#main .w .path span').text() var number = parseInt($($('.statics .static-item')[2]).find('strong').text().trim(),10) var chapters = $('.chapter') var chapterCourses = [] var courseData = &#123; title:title, number:number, videos:[] &#125; //每一个章节的标题和视频,这里把声明放在外面，或许会更好 var chapter; var chapterTitle = \"\" var chapterVideos = [] chapters.each(function(item)&#123; chapter = $(this) chapterTitle = chapter.find('strong').text() chapterVideos = chapter.find('.video').children('li') chapterCourses = &#123; chapterTitle:chapterTitle, chapterVideos:[] &#125; chapterVideos.each(function(item)&#123; var video = $(this).find('.studyvideo') var videoTitle = video.text() var id = video.attr('href').split('/')[1] chapterCourses.chapterVideos.push(&#123; title:videoTitle, id:id &#125;) &#125;) courseData.videos.push(chapterCourses) &#125;) return courseData&#125;//打印数组function printChapter(coursesData)&#123; coursesData.forEach(function(courseData)&#123; //console.log(courseData) console.log(courseData.number + '个人学过 ' + courseData.title+' \\n') &#125;) coursesData.forEach(function(courseData)&#123; console.log(courseData.title+\"###\"+\"\\n\") courseData.videos.forEach(function(item)&#123; var chapterTitle = item.chapterTitle console.log(chapterTitle+'\\n') item.chapterVideos.forEach(function(video) &#123; console.log(' ['+video.id+']'+video.title + '\\n') &#125;) &#125;) &#125;)&#125;//通过promise的resolve和reject返回promisefunction getPageAsync(url)&#123; return new Promise(function(resolve,reject)&#123; http.get(url,function(res)&#123; var html = \"\"; res.on('data',function(data)&#123; html += data &#125;) res.on('end',function()&#123; resolve(html) &#125;) &#125;).on('error',function(e)&#123; reject(e) console.log('获取失败') &#125;) &#125;)&#125;var fetchCourseArr = []videoIds.forEach(function(id)&#123; console.log('开始爬取网站'+baseUrl+id) fetchCourseArr.push(getPageAsync(baseUrl + id))&#125;)//promise的方法all和thenPromise.all(fetchCourseArr) .then(function(pages)&#123; var coursesData = [] pages.forEach(function(html)&#123; var courses = filterChapter(html) coursesData.push(courses) &#125;) coursesData.sort(function(a,b)&#123; return a.number-b.number; &#125;) printChapter(coursesData) &#125;) 中间收获用request发起请求如何用node伪造一个请求。比如就在本地提交评论到慕课网? 注意这里的headers可以直接先去评论一个，去看看请求headers，然后复制过来就可以啦。 中间有个错误。querystring都是小写。虽然官方文档介绍它的时候是queryString。这个地方要注意了。然后可以用request方法发起一个请求。然后最后把数据post过去就可以了。Cookie那个地方要用本地cookie. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var http = require('http')var querystring = require('querystring')var postData = querystring.stringify(&#123; 'content':'老师你真帅,测试', 'cid':348&#125;)var options = &#123; hostname:'www.imooc.com', port:80, path:'/course/docomment', method:'POST', headers:&#123; 'Accept':'application/json, text/javascript, */*; q=0.01', 'Accept-Encoding':'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.8', 'Connection':'keep-alive', 'Content-Length':82, 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Cookie':'......', 'Host':'www.imooc.com', 'Origin':'http://www.imooc.com', 'Referer':'http://www.imooc.com/comment/348', 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/40.0.2214.111 Chrome/40.0.2214.111 Safari/537.36', 'X-Requested-With':'XMLHttpRequest' &#125;&#125;var req = http.request(options,function(res)&#123; console.log('res statecode'+res.statusCode) console.log('res headers'+ JSON.stringify(res.headers)) res.on('data',function(chunk)&#123; console.log(Buffer.isBuffer(chunk)) console.log(typeof chunk) &#125;) res.on('end',function()&#123; console.log('评论完毕') &#125;) res.on('error',function(e)&#123; console.log('评论出现错误'+e.message()) &#125;)&#125;)req.write(postData)req.end() 这中间又出了个错，就是content-length和post过去的数据长度不一致。导致socket hang up解决方法就是改长度啦。 关于promisepromise的话，node新版本是已经当成核心模块了。但是如果是旧版本就可以用bluebird这些东西。然后再看看promise有哪里好。代码或许可以解释好多。下面是三个小球。我们让他们一个接着一个产生动画。 看下dom结构：12345678910111213141516171819202122&lt;style&gt; .box&#123; width:30px; height:30px; -webkit-border-radius:50%; -moz-border-radius:50%; border-radius:50%; &#125; .box1&#123; background:red; &#125; .box2&#123; background:yellow; &#125; .box3&#123; background:blue; &#125;&lt;/style&gt;&lt;div class=\"box box1\" style=\"margin-left:0px\"&gt;&lt;/div&gt;&lt;div class=\"box box2\" style=\"margin-left:0px\"&gt;&lt;/div&gt;&lt;div class=\"box box3\" style=\"margin-left:0px\"&gt;&lt;/div&gt; 没用promise之前，callback嵌套。 1234567891011121314151617181920212223242526272829303132333435363738&lt;script src=\"node_modules/bluebird/js/browser/bluebird.js\"&gt;&lt;/script&gt;&lt;script&gt; var box1 = document.querySelector(\".box1\"); var box2 = document.querySelector(\".box2\"); var box3 = document.querySelector(\".box3\"); function animate(ball,distance,callback)&#123; setTimeout(function()&#123; var marginLeft = parseInt(ball.style.marginLeft,10); if(marginLeft === distance)&#123; callback &amp;&amp; callback(); &#125;else&#123; if(marginLeft&lt;distance)&#123; marginLeft++; &#125;else&#123; marginLeft--; &#125; console.log(marginLeft); ball.style.marginLeft = marginLeft + \"px\"; animate(ball,distance,callback); &#125; &#125;,13) &#125; animate(box1,100,function()&#123; animate(box2,200,function()&#123; animate(box3,300,function()&#123; animate(box3,150,function()&#123; animate(box2,150,function()&#123; animate(box1,150,function()&#123; console.log(\"animate done\"); &#125;) &#125;) &#125;) &#125;) &#125;) &#125;)&lt;/script&gt; 用了promise后，也是异步调用，但是确实同步编写。是不是看着很好？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt; &lt;script src=\"node_modules/bluebird/js/browser/bluebird.js\"&gt;&lt;/script&gt; &lt;script&gt; var box1 = document.querySelector(\".box1\"); var box2 = document.querySelector(\".box2\"); var box3 = document.querySelector(\".box3\"); var Promise = window.Promise; function promiseAnimate(ball,distance)&#123; return new Promise(function(resolve,reject)&#123; function _animate()&#123; setTimeout(function()&#123; var marginLeft = parseInt(ball.style.marginLeft,10); if(marginLeft === distance)&#123; resolve(); &#125;else&#123; if(marginLeft&lt;distance)&#123; marginLeft++; &#125;else&#123; marginLeft--; &#125; ball.style.marginLeft = marginLeft + \"px\"; _animate(); &#125; &#125;,5) &#125; _animate(); &#125;) &#125; promiseAnimate(box1,100) .then(function()&#123; return promiseAnimate(box2,200); &#125;) .then(function()&#123; return promiseAnimate(box3,300); &#125;) .then(function()&#123; return promiseAnimate(box3,150); &#125;) .then(function()&#123; return promiseAnimate(box2,150); &#125;) .then(function()&#123; return promiseAnimate(box1,150); &#125;); &lt;/script&gt; 官网上关于promise有个例子,里面我看到了这个insertAdjacentHTML，觉得好棒。大部分浏览器都支持了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; 'use strict'; var promiseCount = 0; function testPromise() &#123; var thisPromiseCount = ++promiseCount; var log = document.getElementById('log'); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Started (&lt;small&gt;Sync code started&lt;/small&gt;)&lt;br/&gt;'); // We make a new promise: we promise a numeric count of this promise, starting from 1 (after waiting 3s) var p1 = new Promise( // The resolver function is called with the ability to resolve or // reject the promise function(resolve, reject) &#123; log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise started (&lt;small&gt;Async code started&lt;/small&gt;)&lt;br/&gt;'); // This is only an example to create asynchronism window.setTimeout( function() &#123; // We fulfill the promise ! resolve(thisPromiseCount); &#125;, Math.random() * 2000 + 1000); &#125; ); // We define what to do when the promise is resolved/fulfilled with the then() call, // and the catch() method defines what to do if the promise is rejected. p1.then( // Log the fulfillment value function(val) &#123; log.insertAdjacentHTML('beforeend', val + ') Promise fulfilled (&lt;small&gt;Async code terminated&lt;/small&gt;)&lt;br/&gt;'); &#125;) .catch( // Log the rejection reason function(reason) &#123; console.log('Handle rejected promise ('+reason+') here.'); &#125;); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise made (&lt;small&gt;Sync code terminated&lt;/small&gt;)&lt;br/&gt;'); &#125;&lt;/script&gt; 总结觉得学到挺多东西的。其实感觉node不知道怎么入手,书也不知道看啥好，有点迷茫。有看一些node书，感觉大部分都是讲语法和API，还是多做点东西，实践中学习，心里稍微踏实点。再次谢谢scott老师。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"防火墙简单知识","slug":"防火墙简单知识","date":"2016-05-19T03:00:15.000Z","updated":"2016-05-19T03:29:58.000Z","comments":true,"path":"2016/05/19/防火墙简单知识/","link":"","permalink":"http://sevencai.github.io/2016/05/19/防火墙简单知识/","excerpt":"","text":"今天看到知乎上有个讨论，说我们的墙的存在合不合理？有些人说墙的存在限制了国内的发展，是中国的不进步的一种表现，还有人说墙的存在是好的。毕竟保护了中国人的一些隐私。墙的存在，会对我们程序员来说，不太好受，比如我们必须想办法翻墙去google。 我骨子里还是很保守，所以我觉得墙还是要存在的，=。=，隐私还是要保护的，不能让外国人把咱们中国的摸得太透啦。我们操作系统都是用的外国的，不管是linux,mac,windows。编程语言是外国人的，那如果全部的人都去搜索也全用外国的，或者去上外国一些不好的网站，那该多不好。原谅我骨子里那么一点点的保守。但是，咱们又不是墙所有的，stackoverflow不能上吗？github不能上吗？那么多都可以上，就不要抱怨啦。百度出了那个事情，是让人难过，但是如果经过这个事情，他们真的有很大的决心改正，并且实施了行动，我其实还是抱有希望的，=。=，虽然咱们程序员肯定是要去翻墙。感觉扯远了。。 我搜了下，防火墙大概张这个样子，以前还以为是个很大的东西，没想到就是这样一个小机器，涨见识啦。 这篇文章讲解一些关于防火墙的知识。算是解决我的一些疑惑。记录整理如下： 防火墙是啥防火墙的本义原是指古代人们房屋之间修建的墙，这道墙可以防止火灾发生的时候蔓延到别的房屋。 但咱们这里所说的防火墙不是指为了防火而造的墙，而是指隔离在本地网络与外界网络之间的一道防御系统。防火墙是一种非常有效的网络安全系统，通过它可以隔离风险区域（Internet或有一定风险的网络）与安全区域（局域网）的连接，同时不会妨碍安全区域对风险区域的访问。它实际上是一种隔离技术。 所谓防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障.是一种获取安全性方法的形象说法，它是一种计算机硬件和软件的结合，使Internet与Intranet之间建立起一个安全网关（Security Gateway），从而保护内部网免受非法用户的侵入，防火墙主要由服务访问规则、验证工具、包过滤和应用网关4个部分组成，防火墙就是一个位于计算机和它所连接的网络之间的软件或硬件。该计算机流入流出的所有网络通信和数据包均要经过此防火墙。-from wiki 防火墙的功能防火墙一般有下列的功能： 可以限制未授权的用户进入内部网络，过滤掉不安全的服务和非法用户 防止入侵者接近网络防御设施 限制内部用户访问特殊站点 对网络存取和访问进行监控审计 一个防火墙（作为阻塞点、控制点）能极大地提高一个内部网络的安全性，并通过过滤不安全的服务而降低风险。由于只有经过精心选择的应用协议才能通过防火墙，所以网络环境变得更安全。如防火墙可以禁止诸如众所周知的不安全的NFS协议进出受保护网络，这样外部的攻击者就不可能利用这些脆弱的协议来攻击内部网络。防火墙同时可以保护网络免受基于路由的攻击，如IP选项中的源路由攻击和ICMP重定向中的重定向路径。防火墙应该可以拒绝所有以上类型攻击的报文并通知防火墙管理员。 通过以防火墙为中心的安全方案配置，能将所有安全软件（如口令、加密、身份认证、审计等）配置在防火墙上。与将网络安全问题分散到各个主机上相比，防火墙的集中安全管理更经济。例如在网络访问时，一次一密口令系统和其它的身份认证系统完全可以不必分散在各个主机上，而集中在防火墙一身上。 如果所有的访问都经过防火墙，那么防火墙就能记录下这些访问并作出日志记录，同时也能提供网络使用情况的统计数据。当发生可疑动作时，防火墙能进行适当的报警，并提供网络是否受到监测和攻击的详细信息。另外，收集一个网络的使用和误用情况也是非常重要的。首先的理由是可以清楚防火墙是否能够抵挡攻击者的探测和攻击，并且清楚防火墙的控制是否充足。而网络使用统计对网络需求分析和威胁分析等而言也是非常重要的。 通过利用防火墙对内部网络的划分，可实现内部网重点网段的隔离，从而限制了局部重点或敏感网络安全问题对全局网络造成的影响。再者，隐私是内部网络非常关心的问题，一个内部网络中不引人注意的细节可能包含了有关安全的线索而引起外部攻击者的兴趣，甚至因此而暴漏了内部网络的某些安全漏洞。使用防火墙就可以隐蔽那些透漏内部细节如Finger，DNS等服务。Finger显示了主机的所有用户的注册名、真名，最后登录时间和使用shell类型等。但是Finger显示的信息非常容易被攻击者所获悉。攻击者可以知道一个系统使用的频繁程度，这个系统是否有用户正在连线上网，这个系统是否在被攻击时引起注意等等。防火墙可以同样阻塞有关内部网络中的DNS信息，这样一台主机的域名和IP地址就不会被外界所了解。 防火墙的局限性但是防火墙也不是万能的，它也有以下的局限性。 防火墙不能防范网络内部的攻击。比如：防火墙无法禁止变节者或内部间谍将敏感数据拷贝到软盘上。 防火墙也不能防范那些伪装成超级用户或诈称新雇员的黑客们劝说没有防范心理的用户公开其口令，并授予其临时的网络访问权限。 防火墙不能防止传送己感染病毒的软件或文件，不能期望防火墙去对每一个文件进行扫描，查出潜在的病毒。 防火墙的分类常见的是下面三种防火墙： 分组过滤防火墙； 应用代理防火墙； 状态检测防火墙。 分组过滤（Packet Filtering）作用在协议组的网络层和传输层，根据分组包头源地址、目的地址和端口号、协议类型等标志确定是否允许数据包通过，只有满足过滤逻辑的数据包才被转发到相应的目的地的出口端，其余的数据包则从数据流中丢弃。 应用代理（Application Proxy）也叫应用网关（Application Gateway），它作用在应用层，其特点是完全“阻隔”网络通信流，通过对每种应用服务编制专门的代理程序，实现监视和控制应用层通信流的作用。实际中的应用网关通常由专用工作站实现。 状态检测（Status Detection）直接对分组里的数据进行处理，并且结合前后分组的数据进行综合判断，然后决定是否允许该数据包通过。 防火墙的特征防火墙就是一种过滤塞（你这么理解不算错），你可以让你喜欢的东西通过这个塞子，别的玩意都统统过滤掉。在网络的世界里，要由防火墙过滤的就是承载通信数据的通信包。 内部网络和外部网络之间的所有网络数据流都必须经过防火墙这是防火墙所处网络位置特性，同时也是一个前提。因为只有当防火墙是内、外部网络之间通信的唯一通道，才可以全面、有效地保护企业网部网络不受侵害。 根据美国国家安全局制定的《信息保障技术框架》，防火墙适用于用户网络系统的边界，属于用户网络边界的安全保护设备。所谓网络边界即是采用不同安全策略的两个网络连接处，比如用户网络和互联网之间连接、和其它业务往来单位的网络连接、用户内部网络不同部门之间的连接等。防火墙的目的就是在网络连接之间建立一个安全控制点，通过允许、拒绝或重新定向经过防火墙的数据流，实现对进、出内部网络的服务和访问的审计和控制。 典型的防火墙体系网络结构可以是：防火墙的一端连接企事业单位内部的局域网，而另一端则连接着互联网。所有的内、外部网络之间的通信都要经过防火墙。 只有符合安全策略的数据流才能通过防火墙防火墙最基本的功能是确保网络流量的合法性，并在此前提下将网络的流量快速的从一条链路转发到另外的链路上去。从最早的防火墙模型开始谈起，原始的防火墙是一台“双穴主机”，即具备两个网络接口，同时拥有两个网络层地址。 防火墙将网络上的流量通过相应的网络接口接收上来，按照OSI协议栈的七层结构顺序上传，在适当的协议层进行访问规则和安全审查，然后将符合通过条件的报文从相应的网络接口送出，而对于那些不符合通过条件的报文则予以阻断。因此，从这个角度上来说，防火墙是一个类似于桥接或路由器的、多端口的（网络接口&gt;=2）转发设备，它跨接于多个分离的物理网段之间，并在报文转发过程之中完成对报文的审查工作。 防火墙自身应具有非常强的抗攻击免疫力这是防火墙之所以能担当企业内部网络安全防护重任的先决条件。防火墙处于网络边缘，它就像一个边界卫士一样，每时每刻都要面对黑客的入侵，这样就要求防火墙自身要具有非常强的抗击入侵本领。它之所以具有这么强的本领防火墙操作系统本身是关键，只有自身具有完整信任关系的操作系统才可以谈论系统的安全性。其次就是防火墙自身具有非常低的服务功能，除了专门的防火墙嵌入系统外，再没有其它应用程序在防火墙上运行。当然这些安全性也只能说是相对的。 目前国内的防火墙几乎被国外的品牌占据了一半的市场，国外品牌的优势主要是在技术和知名度上比国内产品高。而国内防火墙厂商对国内用户了解更加透彻，价格上也更具有优势。防火墙产品中，国外主流厂商为思科（Cisco）、CheckPoint、NetScreen等，国内主流厂商为东软、天融信、网御神州、联想、方正等，它们都提供不同级别的防火墙产品。 总结主要是记录下简单的防火墙知识，方便以后的查阅。大部分都整理自wiki,感谢。大概可以对防火墙有些简单的了解，科普。","categories":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"vim 下的常用命令","slug":"vim-下的常用命令","date":"2016-05-07T15:15:54.000Z","updated":"2016-12-12T02:31:18.000Z","comments":true,"path":"2016/05/07/vim-下的常用命令/","link":"","permalink":"http://sevencai.github.io/2016/05/07/vim-下的常用命令/","excerpt":"","text":"系统管理员癿重要工作就是得要修改不设定某些重要软件的配置文件，因此至少得要学会一种以上癿文字接口的文书编辑器。 在所有的Linux distributions 上央都会有的一套文书编辑器就是 vi ，而且很多软件默讣也是使用 vi 做为他们编辑的接口， 因此鸟哥建议您务必要学会使用 vi 这个正规的文书编辑器。此外，vim 是进阶版的 vi ， vim 不但可以用丌同颜色显示文字内容，还能够进行诸如 shell script, C program 等程序编辑功能， 你可以将 vim 规为一种程序编辑器！ – from 鸟哥 以前学习linux的时候，就是只用那些常用的命令，完全没有体会到vim的好处，现在想整个系统的学下。因为命令很多，记录如下，主要是便于回头查找。也分享给大家。我看的是《鸟哥的私房菜这本书》，讲的不能再好了。我分享的书里面有这个电子书。但是还是建议买一个正版的。 vi 一共分为三种模式：一般模式，编辑模式，指令命令模式。 一般模式：以vi打开一个文件的时候，默认就是进入这个模式。这个模式中，可以使用上下左右按键移动光标，可以删除，复制，粘贴。 编辑模式：一般模式中可以进行复制，粘贴，删除，移动。但是没有办法编辑文件。这个时候，我们要通过[i,I,o,O,r,R]这些字母进入编辑模式。你会在下面看到[insert][replace]的字样，退出这个模式，请使用[esc]。 指令行命令模式：输入[:/?]三个中的任意一个，就可以移动到光标最底下一行。可以搜索，而读取，存盘，大量取代字符，离开vi,显示行号，这些都是这个模式达成的。 最常用的是：i,esc,a,:wq,:q!,vi filename….等等。 一般模式光标移动h:(←) 光标向左边移动一个字符j:(↓) 光标向下边移动一个字符k:(↑) 光标向上边移动一个字符l:(→) 光标向右边移动一个字符 hjkl是在键盘上连在一起的，30j,30h都可以。 ctrl+f : 屏幕向下移动一页 == pagedownctrl+b : 屏幕向上移动一页 == pageup 还有不是很常用的 ctrl+d : 屏幕向下移动半页ctrl+u: 屏幕向上移动半页+ 光标移动到非空格的下一列- 光标移动到非空格的上一列 n&lt;space&gt; : 如 20（空格） 表示光标向右移动这一行的n个字符。 0 == [home]$ == [end] G 移动到此文件最后一行gg 移动到这个档案的第一行nG n表示数字，移动到这个档案的第n行1G 自然代表移动到这个档案的第一行 == ggn&lt;enter&gt; n表示数字，光标向下移动n行 搜寻与取代/word 向光标之下寻找一个名称为word的字符串 如/seven 向下寻找seven这个字符串?word 向光标之上寻找一个名称伪word的字符串 n 注意这里的n代表的不是数字，是n英文按键，代表[重复前一个搜寻的动作]比如上面我/seven了，表示我要向下搜寻seven这个字符串，如果我此时按下n，代表继续向下搜寻下一个字符串。如果是?seven，同样的道理喽。 N 这个N是英文按键。与n刚好相反，比如刚才先按下/seven，再按下N，代表，会向上搜寻seven,此时作用等同于?seven。 /?n 的配合，可以重复的找到一些你搜寻的关键字。 :n1,n2s/word1/word2/g n1,n2为数字，word1,查询字符串，word2为替换字符串:100,200s/seven/Seven/g :1,$s/word1/word2/g 从第一行到最后一行寻找word1,并且替换成word2. :1,$s/word1/word2/gc 从第一行到最后一行寻找word1，并且取代为word2,并且在替换前提示用户，confirm一下，是否替换。 删除，复制，粘贴x,X : x向后删除一个字符，X向前删除一个字符。x=del,X=backspacenx : n为数字，连续向后删除n个字符。10x,向后删除10个字符dd : 删除游标所在的那一列ndd : 向下删除n列。d1G : 删除光标所在到第一行的所有数据dG: 删除光标所在到最后一行的所有数据 如果只删除一个字符，我倒觉得del,和backspace比较方便，因为不用从编辑模式，切换到命令模式。但是后面的dd,ndd,d1G,dG的好处就很明显体现出来了。 d$ : 删除游标所在处，到该行的最后一个字符d0 : 删除光标所在处，到该行的第一个字符 yy : 复制游标所在的那一行nyy : n为数字，复制光标所在的向下n行，20yy,向下复制20列 y1G : 复制光标所在列到第一列的所有数据yG : 复制光标所在列到最后一列的所有数据y0 : 复制光标所在的那个字符到该行行首的所有数据y$ : 复制光标所在的哪个字符到该行行尾的所有数据 p,P : p将已经复制的数据在光标下一行粘贴，P为上一行。J : 将光标所在列与下一列的数据合成同一列c : 重复删除多个数据，例如向下删除10行 10cj u : 复原前一个动作 == windows下面的ctrl+zctrl+r : 重做前一个动作 == windows下面的ctrl+y 这两个很常用。 . : 重复前一个动作，比如重复删除，重复粘贴，就一直按下小数点就行啦。 一般模式切换到编辑模式i,I : 插入模式，i为从光标所在处插入，I为在目前所在行的第一个非空格处插入a,A : a为从光标所在的下一个字符开始插入，A为从光标所在行的最后一个字符插入o,O : o为在光标所在行的下一行插入，O为上一行插入。r,R : 前面三个都是插入模式，这个是取代模式：r会取代光标所在的哪个字符一次，R会一直取代光标所在的文字，一直到esc esc : 退出编辑模式，回到一般模式 上面那些按键，都会在左下角出现insert或者replace的字样 一般模式切换到指令模式:w 将编辑癿数据写入硬盘档案中(常用):W 若文件属性为『只读』时,强制写入该档案。不过,到底能不能写入, 还是跟你对该档案的案权限有关:q 离开 vi (常用):q! 若曾修改过档案,又不储存,使用 ! 为强制离开当前文件。注意一下啊,那个惊叹号 (!) 在 vi 当中,常常具有『强制』的意思~:wq 存储后离开，:wq!存储后强制离开ZZ 若文档没有更改，则不存储离开，若改动，则存储离开:w [filename] 另存为另一个filenane:r [filename] 将filename这个档案的内容加到游标的行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。:! command 暂时离开 vi 到指令列模式下执行 command 癿显示结果!例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出癿档案信息! :set nu 显示行号:set nonu 不显示行号 多窗口功能如果想要对比一个文件或者多个文件的数据的时候，是否需要ctrl+f或者ctrl+b前后查看数据呢？不需要，vim支持多窗口功能，也就是窗口的分割： 比如 vi 1.txt -&gt; 1G -&gt; :sp -&gt; G两个同样的文件，一个文件开头，一个文件结尾，可以一起看。 比如再输入[:sp /etc/hosts]又会多了一个窗口了。 :sp [filename] 开启一个新窗口ctrl+w+j ([ctrl]+w+↓) 按键的按法是:先按下 [ctrl] 丌放, 再按下 w 后放开所有癿按键,然后再按下 j (戒向下箭央键),则光标可移劢到下方的窗口。 [ctrl]+w+k ([ctrl]+w+↑): 同上,丌过光标移劢到上面的窗口。 [ctrl]+w+q 其实就是 :q 结束离开啦! 丼例来说,如果我想要结束下方癿窗口，那么利用用 [ctrl]+w+↓ 移劢到下方窗口后,按下 :q 即可离开, 也可以按下[ctrl]+w+q 总结下面的图片来自鸟哥的书。有时候模糊不清，会看的更认真是不是？=。=","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"基于Socket.IO的node聊天室，支持私聊","slug":"基于Socket-IO的node聊天室，支持私聊","date":"2016-05-04T02:23:19.000Z","updated":"2016-12-12T02:33:14.000Z","comments":true,"path":"2016/05/04/基于Socket-IO的node聊天室，支持私聊/","link":"","permalink":"http://sevencai.github.io/2016/05/04/基于Socket-IO的node聊天室，支持私聊/","excerpt":"","text":"源码我放在了github上面。【地址在这儿】。首先可以看下【上篇】博客,把环境先搭建好和熟悉socket.io基本用法。整个可以实现下面的这些功能： 用户登陆进行聊天。 用户登陆后，即可发送消息。 对刚登录用户来说，罗列所有在线用户列表 对已在线的用户来说，通知该用户有新用户登陆或者离开 支持对所有人广播聊天内容，即群聊 支持私聊当前在线用户，即私聊 用户即时获得消息列表 当服务器断开连接时，提醒所有用户 整个代码量非常少，可以根据自己的需求修改逻辑。 没有进行太多的限制，比如没有限制重名登陆，主要是关注逻辑代码。 没有写任何样式,所以很难看额，以后有时间慢慢的补起来吧，现在考试略多。。。。 运行：切换到此目录，运行node index.js即可。打开端口3000,localhost:3000。 服务器端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var http = require('http');var sio = require('socket.io');var express = require('express');var app = express();var server = http.createServer(app);var io = sio.listen(server);app.get('/',function(req,res)&#123; res.sendFile(__dirname+'/index.html');&#125;)server.listen('3000',function()&#123; console.log('listening on port 3000');&#125;)var onlineUsers = &#123;&#125;;var onlineCount = 0;var userSockets = &#123;&#125;;io.on('connection',function(socket)&#123; //当客户端有用户登陆的时候 socket.on('login',function(userObj)&#123; socket.uid = userObj.uid; userSockets[userObj.uid] = socket; //检查是否在当前的用户列表中，如果不在count++ if(!onlineUsers.hasOwnProperty(userObj.uid))&#123; onlineUsers[userObj.uid] = userObj.username; onlineCount++; &#125; //向客户端发送用户登陆的信息 io.emit('login',&#123;onlineUsers:onlineUsers,onlineCount:onlineCount,userObj:userObj&#125;); console.log(userObj.username + \" 进入了聊天室\"); &#125;); //当服务器接收到消息时 socket.on('message',function(data)&#123; if(data.to !== \"所有人\")&#123; if(data.to in userSockets)&#123; userSockets[data.to].emit('to'+data.to,data); userSockets[data.uid].emit('to'+data.uid,data); &#125; &#125;else&#123; io.emit('message',data); console.log(data.username+\"对\"+data.to+\"说：\"+data.message); &#125; &#125;); //当客户端退出的时候 socket.on('disconnect',function()&#123; if(onlineUsers.hasOwnProperty(socket.uid))&#123; //记录要退出用户的信息，发送给客户端 var userObj = &#123;uid:socket.uid,username:onlineUsers.uid&#125;; delete onlineUsers[socket.uid]; delete userSockets[socket.uid]; onlineCount--; io.emit('logout',&#123;onlineUsers:onlineUsers,onlineCount:onlineCount,userObj:userObj&#125;); console.log(userObj.username+\" 退出了聊天室\"); &#125; &#125;)&#125;) 客户端代码DOM结构部分12345678910111213141516171819202122232425262728&lt;header&gt; &lt;h3&gt;基于socket.io的聊天室&lt;/h3&gt; &lt;p id=\"notice\"&gt;&lt;/p&gt;&lt;/header&gt;&lt;div class=\"login\"&gt; &lt;h3&gt;聊天前请先登陆&lt;/h3&gt; &lt;input type=\"text\" placeholder=\"输入用户名\" id=\"username\"&gt; &lt;input type=\"submit\" value=\"登陆\" onclick=\"CHAT.submit()\"&gt;&lt;/div&gt;&lt;div id=\"main\" style=\"display:none;\"&gt; &lt;aside&gt; &lt;p&gt;在线用户列表&lt;/p&gt; &lt;ul id=\"onlineUsers\"&gt; &lt;/ul&gt; &lt;/aside&gt; &lt;section&gt; &lt;p&gt;消息列表&lt;/p&gt; &lt;ul id=\"messageList\"&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/div&gt;&lt;footer id=\"footer\" style=\"display:none\"&gt; &lt;textarea name=\"\" id=\"message\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;select name=\"\" id=\"selectUserList\"&gt; &lt;option value=\"\"&gt;所有人&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\" value=\"提交\" onclick=\"CHAT.sendMessage()\"&gt;&lt;/footer&gt; js脚本代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; (function()&#123; window.CHAT = &#123; uid:null, username:null, socket:null, submit:function()&#123; var username = document.getElementById('username').value; if(username!==\"\")&#123; this.init(username); this.socket.emit('login',&#123;uid:this.uid,username:this.username&#125;); this.initStyle(); &#125; &#125;, initStyle:function()&#123; var main = document.getElementById('main'); var footer = document.getElementById('footer'); main.style.display = 'block'; footer.style.display = 'block'; &#125;, getUid:function()&#123; return +new Date(); &#125;, sendMessage:function()&#123; var message = document.getElementById('message').value; var select = document.getElementById('selectUserList'); var selectIndex = select.selectedIndex; var optionValue = select.options[selectIndex].value; var optionText = select.options[selectIndex].text; if(message != \"\")&#123; this.socket.emit('message',&#123;uid:this.uid,username:this.username,message:message,to:optionValue,toUser:optionText&#125;); &#125; &#125;, createEleNode:function(ele,text)&#123; var eleNode = document.createElement(ele); var text = document.createTextNode(text); eleNode.appendChild(text); return eleNode; &#125;, updateUlist:function(data)&#123; var onlineLists = document.getElementById(\"onlineUsers\"); var str = \"\"; for(var i in data.onlineUsers)&#123; str += \"&lt;li id='\"+i+\"'&gt;\"+data.onlineUsers[i]+\"&lt;/li&gt;\"; &#125; onlineLists.innerHTML = str; &#125;, updateSelect:function(data)&#123; var selectUserList = document.getElementById('selectUserList'); var str = \"&lt;option value='所有人'&gt;所有人&lt;/option&gt;\"; for(var key in data.onlineUsers)&#123; str += \"&lt;option value='\"+key+\"'&gt;\"+data.onlineUsers[key]+\"&lt;/option&gt;\" &#125; selectUserList.innerHTML = str; &#125;, updateNotice:function(msg)&#123; var notice = document.getElementById('notice'); var node = this.createEleNode('li',msg) notice.appendChild(node); &#125;, appendMessage:function(data)&#123; var messageList = document.getElementById(\"messageList\"); var node = CHAT.createEleNode('li','用户'+data.username+\"对\"+data.toUser+\"说：\"+data.message); console.log(node); messageList.appendChild(node); &#125;, init:function(username)&#123; this.uid = this.getUid(); this.username = username; this.socket = io.connect(); this.socket.on('login',function(data)&#123; //当用户登陆的时候，更新列表 CHAT.updateUlist(data); CHAT.updateSelect(data); CHAT.updateNotice(data.userObj.username+\"进入了聊天室\"); &#125;); this.socket.on('logout',function(data)&#123; //当用户退出时，更新列表 CHAT.updateUlist(data); CHAT.updateSelect(data); CHAT.updateNotice(CHAT.username+\"退出了聊天室\"); &#125;); this.socket.on('message',function(data)&#123; CHAT.appendMessage(data); &#125;); this.socket.on('to'+CHAT.uid,function(data)&#123; CHAT.appendMessage(data); &#125;) this.socket.on('disconnect',function()&#123; CHAT.updateNotice(\"服务器断开连接\"); &#125;); &#125; &#125; &#125;)()&lt;/script&gt; 这里注意下有个地方，有的时候我们调用方法的时候，不能够直接用this.method调用该方法，因为比如我们使用：this.socket.on的时候，这个内部的this已经不是当前对象了。所以我们要直接使用CHAT.method或者CHAT.属性的方法来调用。 截图结果 总结socket.io很好用，开发也很简单，花了比较少的时间。但是还有一些功能没有实现，比如如何实现群组，也就是房间聊天？如何给不在线的用户发送聊天记录？如何利用redis和聊天室结合起来？","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/tags/WEB开发/"}]},{"title":"使用Socket.IO类库实现WebSocket通信","slug":"使用Socket-IO类库实现WebSocket通信","date":"2016-05-02T09:40:45.000Z","updated":"2016-12-12T03:01:36.000Z","comments":true,"path":"2016/05/02/使用Socket-IO类库实现WebSocket通信/","link":"","permalink":"http://sevencai.github.io/2016/05/02/使用Socket-IO类库实现WebSocket通信/","excerpt":"","text":"Socket.IO是什么？ Socket.IO 是一个类库。 可以做跨平台(浏览器或移动设备)，支持多种连接方式自动切换，在做即时通讯方面的开发也很方便，而且能和expressjs提供的传统请求方式很好的结合。这个类库Node.js中net模块的功能。包括可以WebSocket通信，XHR轮询，JSONP轮询,它会自动根据浏览器选择适合的通讯方式，从而让开发者可以聚焦到功能的实现而不是平台的兼容性，同时Socket.IO具有不错的稳定性和性能。这篇文章，主要以实例的形式，展示如何使用socket.io类库，如何利用socket.io实现客户端和服务器端的通信，如何与express结合，如何使用不同命名空间等等。学习它的目的，是我想做一个node聊天室。 搭建测试服务端环境npm init利用npm init命令生成package.json文件，填入相应的信息。大概是会生成下面的一些样子。123456789101112&#123; \"name\": \"node-chat\", \"version\": \"1.0.0\", \"description\": \"chatroom based on WebSocket\", \"main\": \"index.js\", \"keywords\": [ \"chatroom\", \"node\" ], \"author\": \"Seven\", \"license\": \"ISC\", //....... 安装相应的包12npm install --save expressnpm install --save socket.io 看到文件夹已经生成相应的node_modules目录了。 测试先测试下，创建index.js测试服务器是否搭建好：1234567891011var app = require('express')();var http = require('http').Server(app);var io = require('socket.io')(http);app.get('/',function(req,res)&#123; res.send('&lt;h1&gt;Welcome&lt;/h1&gt;');&#125;);http.listen(3000,function()&#123; console.log('listen on *:3000');&#125;) 这时候可以在localhost上访问3000端口，这样就可以在页面上看到 welcome字样，这样简单的测试就完成了。 socket.io类库的使用方法注意：Socket.IO类库的使用方法比较简单，创建一个Socket.IO服务器即可，但是该服务器依赖于一个已经创建好的HTTP服务器。所以在HTTP服务器运行后，使用listen方法为该HTTP服务器加一个Socket.IO服务器。 123//先创建一个servervar sio = require('socket.io');var socket = sio.listen(server); listen 方法返回的就是一个Socket.IO服务器。 当Socket.IO服务器创建完成后，客户端和服务器端建立联系时，就会触发Socket.IO服务器的connection事件。 然后通过监听该事件回调函数的方法指定当客户端与服务器端建立连接时所需要执行的处理。1234567//参数socket是服务器用于与客户端建立连接的socket端口对象socket.on('connection',function(socket)&#123; //回调函数，这里面可以通过传入的soket参数监听事件 socket.on('message',function()&#123;&#125;) socket.send(msg) socket.on('disconnect',function()&#123;&#125;)&#125;) 一个简单的完整实例下面的代码展示了如何为一个HTTP服务器附加一个Socket.IO服务器。当HTTP服务器接收到客户端的请求时，读取index.html文件中的内容并返回给客户端。当客户端与Socket.IO服务器端建立连接后，向客户端发送‘你好’消息字符串。 1234567891011121314151617181920212223242526272829var http = require('http');var sio = require('socket.io');var fs = require('fs');//先createSevervar server = http.createServer(function(req,res)&#123; res.writeHead('200',&#123;'Content-Type':'text/html'&#125;); res.end(fs.readFileSync('./index.html'));&#125;);server.listen(3000,function()&#123; console.log(\"listen on 3000 port\");&#125;);//listen上面的server创建一个socket.io服务器var socket = sio.listen(server);socket.on('connection',function(socket)&#123; console.log('客户端已建立'); socket.send(\"hello\"); socket.on('message',function(msg)&#123; console.log('接收到一个消息:'+msg); &#125;); socket.on('disconnect',function()&#123; console.log('客户端连接断开'); &#125;)&#125;); index.html文件如下：1234567891011&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(); socket.on('message',function(data)&#123; console.log(data); socket.send(\"messages are received\"); &#125;); socket.on('disconnect',function()&#123; console.log(\"服务器端断开连接\"); &#125;);&lt;/script&gt; 现在，你肯定会有疑问，这个前面引入的文件是什么？？？/socket.io/socket.io.js由服务器端Socket.IO类库自动提供，所以咱们不需要再客户端实际放置一个socket.io.js文件。 在脚本代码中，首先我们利用/socket.io/socket.io.js类库中的io.connect方法连接到服务器端socket.IO服务器。var socket = io.connect();io.connect方法返回了一个socket对象。代表一个用于服务器建立连接的客户端socket端口对象。 客户端与服务器端建立连接后，触发了我们服务器端的send事件，这时候服务器向客户端发送消息，又触发了客户端socket的message事件。这时候客户端会log出收到的data，显示在浏览器控制台上。然后客户端又给服务器端发送了一个messages are received消息，触发了服务器端的message事件，并打印出接收到一个消息:messages are received。 当服务器端和服务器端断开联系时，又调用disconnect事件。 这里也可以看到，客户端和服务器端处理消息机制完全相同，因为Socket.IO确保了客户端和服务器端，共享了相同的API。 socket.io的emit方法在使用Socket.IO类库时，服务器端和客户端之间除了可以互相发送消息之外，也可以使用socket端口对象的emit方法，互相发送事件。 1socket.emit(event,data,[callback]) event表示：参数值为一个用于指定事件名的字符串。data参数值：代表该事件中携带的数据。这个数据就是要发送给对方的数据。数据可以是字符串，也可以是对象。callback参数：值为一个参数，用于指定一个当对方确定接收到数据时调用的回调函数。 一方使用emit发送事件后，另一方可以使用on,或者once方法，对该事件进行监听。once和on不同的地方就是，once只监听一次，会在回调函数执行完毕后，取消监听。 12socket.on(event,function(data,fn)&#123;&#125;)socket.once(event,function(data,fn)&#123;&#125;) 再体会下emit的三个参数：首先是服务器端：1234567891011121314var socket = sio.listen(server);socket.on('connection',function(socket)&#123; console.log('客户端已建立'); socket.emit('setName','Seven',function(data1,data2)&#123; console.log('客户端传来的数据1&gt;'+data1); console.log('客户端传来的数据2&gt;'+data2); &#125;); socket.on('disconnect',function()&#123; console.log('客户端连接断开'); &#125;)&#125;); 再是客户端：123456789101112&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(); socket.on('setName',function(data,fn)&#123; console.log(data); //fn为当对方确认收到数据时，调用的回调函数。 fn(\"Jason\",\"Jade\"); &#125;); socket.on('disconnect',function()&#123; console.log(\"服务器端断开连接\"); &#125;);&lt;/script&gt; 在Express中使用Socket.IO先前我们测试环境的时候，就有用到express,我们可以通过Express很容易的使用Socket.IO。在原来的版本中，我们可以是socket对象的set和get方法来设置和获得数据。但现在已经在新版本中废除了，所以具体这两个方法就不讲解了。底下还是有老写法的示例的。改进的方法是再socket对象上直接设置属性和值。具体可以看报错解决这篇博客。 这里例子跟express的关联到不是很大，只是简单示例，我们就是利用var server = http.createServer(app);把express关联起来了。然后我们就可以去调用express的api。 服务器端代码：1234567891011121314151617181920212223242526272829303132333435363738394041var express = require('express');var http = require('http');var sio = require('socket.io');var app = express();var server = http.createServer(app);app.get('/',function(req,res)&#123; res.sendFile(__dirname+'/index.html');&#125;);server.listen(3000,function()&#123; console.log(\"listening on port 3000\");&#125;);var socket = sio.listen(server);socket.on('connection',function(socket)&#123; socket.on('set nickName',function(name)&#123; //socket.set在1.x版本已经被废除 // socket.set('nickName',name,function(name))&#123; // socket.emit('send nickName',name) // &#125; socket.nickName = name; socket.emit('send nickName',name) &#125;); socket.on('get nickName',function()&#123; //socket.get在1.x也被废除 // socket.get('nickName',function(err,name)&#123; // if(err)&#123; // socket.emit('err',err.message); // &#125;else&#123; // socket.emit('send nickName',name); // &#125; // &#125;) var name = socket.nickName; if(name)&#123; socket.emit('send nickName',name); &#125; &#125;);&#125;) 客户端代码：有一个可以设置昵称的，当设置了后，我们保存到socket对象中。 123&lt;input type=\"text\" id=\"nickname\"&gt;&lt;input type=\"button\" onclick=\"setNickName()\" value=\"设置昵称\"&gt;&lt;input type=\"button\" onclick=\"getNickName()\" value=\"获取昵称\"&gt; 12345678910111213141516&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt;var socket = io.connect();function setNickName()&#123; socket.emit('set nickName',document.getElementById(\"nickname\").value);&#125;function getNickName()&#123; socket.emit('get nickName');&#125;socket.on('send nickName',function(data)&#123; console.log(\"My name is \"+data);&#125;);socket.on('err',function(data)&#123; console.log('服务器出现错误：'+data);&#125;)&lt;/script&gt; 广播消息当多个客户端与服务器建立连接后，Socket.IO服务器具有一个sockets属性，属性值为所有与客户端建立连接的socket对象。可以利用该对象的send方法或者emit方法向所有客户端广播消息，如下： 12IO.sockets.send(\"user connected\");IO.sockets.emit(\"login\",names); 然后，当我们某个客户端与服务器建立连接以后，用于与该客户端连接的socket对象，就有一个broadcast对象，代表所有与其他Socket.IO客户端建立连接的socket对象。可以利用该对象的send方法和emit方法向所有其他客户端广播消息。如下：12socket.broadcast.send('user connected');socket.broadcase.emit('login',names)； 下面我们看一个广播的小实例，可以当做聊天室的雏形了。先看下最后的结果： 例子中我们看的很清楚，当有不同的用户登陆进来的时候，用户列表是不断的更新的。可以动态的显示出在线的人数。主要就是用到的我们上面的方法io.sockets.emit(&#39;login&#39;,names)。 服务器端的代码： 12345678910111213//.....跟前面一样（省略）var io = sio.listen(server);var names = [];io.on('connection',function(socket)&#123; socket.emit('login',names); socket.on('login',function(name)&#123; names.push(name); io.sockets.emit('login',names); &#125;);&#125;) 客户端代码：123456789101112131415161718用户名：&lt;input type=\"text\" id=\"username\"&gt;&lt;input type=\"button\" value=\"登陆\" onclick=\"add()\"&gt;&lt;p id=\"result\"&gt;&lt;/p&gt;&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io.connect(); socket.on('login',function(names)&#123; var str = \"\"; names.forEach(function(name)&#123; str += \"用户 \"+name+\" 已登陆。&lt;br /&gt;\"; &#125;) document.getElementById('result').innerHTML = str; &#125;) function add()&#123; socket.emit('login',document.getElementById('username').value); &#125;&lt;/script&gt; 主要就是这段代码：当客户端有人登陆的时候，emit发送数组人名的信息给客户端。注意这里的注释，是io.sockets.emit的另外一种替代的写法。123456socket.on('login',function(name)&#123; names.push(name); io.sockets.emit('login',names); //socket.emit('login',names); //socket.broadcast.emit('login',names);&#125;); 使用命名空间如果开发者想要在一个特定的应用程序中完全控制消息与事件发送，只需要一个默认的/就够了，但是如果开发者需要将第三方应用程序作为第三方服务提供给其他应用程序，则需要为一个用于与客户端连接的socket端口定义一个独立的命名空间。 在Socket.IO中，可以使用Socket.IO服务器对象的of方法来定义命名空间。代码如：io.of(namespace)。 服务器端代码：1234567891011121314151617//.....跟前面一样（省略）var io = sio.listen(server);var chat = io.of('/chat').on('connection',function(socket)&#123; socket.send('welcome to namespace:chat'); socket.on('message',function(msg)&#123; console.log('chat namespace has received msg: '+msg); &#125;)&#125;);var news = io.of('/news').on('connection',function(socket)&#123; socket.emit('send message','welcome to namespace:news'); socket.on('send message',function(data)&#123; console.log('news namespace has received mes: '+data); &#125;)&#125;) 客户端代码：12345678910111213141516171819&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var chat = io.connect('http://localhost:3000/chat'); var news = io.connect('http://localhost:3000/news'); chat.on('connect',function()&#123; chat.send('您好!'); chat.on('message',function(data)&#123; console.log('从chat命名空间收到消息：'+data); &#125;); &#125;); news.on('connect',function()&#123; news.on('send message',function(data)&#123; console.log('从news命名空间收到消息：'+data); &#125;) news.emit('send message','hello'); &#125;)&lt;/script&gt; 代码基本上没有什么改动，就是多了个使用命名空间的。主要要知道of的用法。 总结主要是介绍了Socket.IO类库的基本介绍，包括语法和作用。如何安装，如何创建Socket.IO服务器。如何发送事件，如何广播，如何在Express框架中用到socket.io类库。那么，你最后肯定想知道，这个Socket.IO和WebSocket的区别和联系时什么？socket.io封装了websocket,同时还包含其他的功能，比如xhr轮询，jsonp轮询等等。因为不是所有的浏览器都支持websocket,通过socket.io的封装，我们不需要知道里面用到什么连接方式，任何浏览器都可以利用socket.io来建立异步的连接。要记住，如果浏览器中使用了socket.io的js，那么服务器端也要一样。学习内容部分来自《Node.js权威指南》，感谢。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"HTTP连接管理","slug":"HTTP连接管理","date":"2016-05-01T03:34:14.000Z","updated":"2016-12-12T02:28:50.000Z","comments":true,"path":"2016/05/01/HTTP连接管理/","link":"","permalink":"http://sevencai.github.io/2016/05/01/HTTP连接管理/","excerpt":"","text":"世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。- from 《HTTP权威指南》 本文较长，建议通过旁边目录检索自己想要看的部分。文章主要讲解这几个问题： HTTP是如何使用TCP连接的?TCP有哪些特点? TCP连接的时延，瓶颈以及存在的障碍。 HTTP优化，包括并行连接、keep-alive（持久连接）和管道化连接。 管理连接时可能会出现的问题，应该以及不应该做的事情。 TCP链接HTTP连接是HTTP报文传输的关键通道。这里的HTTP连接指的就是TCP连接和一些实用链接的规则。 TCP的可靠数据管道TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来 注意这里的可靠的比特传输管道。 TCP会按序，无差错的承载HTTP数据。下面看看Web浏览器通过TCP连接和Web服务器进行交互的过程。 TCP流是分段的、由IP分组传送TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。这样的话，HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL的）密码加密层。 HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。所有这些工作都是由 TCP/IP 软件来处理的，HTTP 程序员什么都看不到。 或许我们可以从下面这张图看出点什么： 每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的。每个 IP分组中都包括： 一个 IP 分组首部（通常为 20 字节）； 一个 TCP 段首部（通常为 20 字节）； 一个 TCP 数据块（0 个或多个字节）。 上面的那张图中可以看到传输层那部分，包含的三个部分。 IP 首部包含了源和目的 IP 地址、长度和其他一些标记。TCP 段的首部包含了 TCP端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。 保持TCP连接的正确运行在任意时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 是通过端口号来保持所有这些连接的正确运行的。 关于IP和端口下面这个比喻我觉得特别棒： 端口号和雇员使用的电话分机号很类似。就像公司的总机号码能将你接到前台，而分机号可以将你接到正确的雇员位置一样，IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。 TCP是通过下面4个值来识别的：&lt; 源 IP 地址、源端口号、目的 IP 地址、目的端口号 &gt; 这个识别标识就像人的ID一样，唯一的定义了一条连接。两个不同的 TCP 连接不能拥有4个完全相同的地址组件值。 这张图：承载 TCP 段的 IP 分组，它承载了 TCP 数据流中的小块数据。是真实流动在TCP通道中的小数据包。 再强调下：注意，有些连接共享了相同的目的端口号（C 和 D 都使用目的端口号 80）。有些连接使用了相同的源 IP 地址（B 和 C）。有些使用了相同的目的 IP 地址（A 和 B，C和 D）。但没有两个不同连接所有的 4 个值都一样。 用TCP套接字编程操作系统提供了一些操纵其 TCP 连接的工具。我们来看一个 TCP 编程接口。下面显示了套接字 API 提供的一些主要接口。这个套接字 API向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。套接字 API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。socket… 注意套接字不是协议，是一个接口。我们用它来编程。 套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP端点进行连接，并对数据流进行读写。TCP API 隐藏了所有底层网络协议的握手细节，以及 TCP 数据流与 IP 分组之间的分段和重装细节。 下面我们看看TCP客户端和服务器是如何通过TCP套接字进行通信的； 其实是Web服务器一直等待客户端的连接。 我们从 Web 服务器等待连接开始。客户端根据 URL 判定出 IP 地址和端口号，并建立一条到服务器的 TCP 连接。建立连接可能要花费一些时间，时间长短取决于服务器距离的远近、服务器的负载情况，以及因特网的拥挤程度。 一旦建立了连接，客户端就会发送 HTTP 请求，服务器则会读取请求。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作，并将数据写回客户端。客户端读取数据，并对响应数据进行处理。 对TCP性能的考虑HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层TCP 通道的性能。理解了 TCP 的某些基本性能特点之后，就可以更好地理解 HTTP 的连接优化特性，这样就能设计实现一些更高性能的 HTTP 应用程序了。 HTTP事务的时延先用一张图看看网络延时。还有HTTP事务的连接，传输以及处理时延。 我以前刚看到这张图的时候，觉得很不理解，怎么连接，请求和相应的时间会比处理的时间多这么多呢？现在想想，很容易就明白了。记住：与建立TCP连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时延就是由 TCP 网络时延构成的。 HTTP 事务的时延有以下几种主要原因。 客户端首先需要根据 URI 确定 Web 服务器的 IP 地址和端口号。如果最近没有对URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 IP地址可能要花费数十秒的时间。（这个10s我表示怀疑=。=） 接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个 HTTP 事务的话，这个值会快速地叠加上去。 一旦连接建立起来了，客户端就会通过新建立的 TCP 管道来发送 HTTP 请求。数据到达时，Web 服务器会从 TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。 然后，Web 服务器会回送 HTTP 响应，这也需要花费时间。 小tip: 大多数 HTTP 客户端都有一个小的 DNS 缓存，用来保存近期所访问站点的 IP 地址。 如果 已经在本地“缓存”（记录）了 IP 地址，查询就可以立即完成。 因为大多数 Web 浏览器浏览的都是少数常用站点，所以通常都可以很快地将主机名解析出来。 这些 TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。 性能聚焦区域下面看几种最常见的TCP相关时延。具体有： TCP 连接建立握手； TCP 慢启动拥塞控制； 数据聚集的 Nagle 算法； 用于捎带确认的 TCP 延迟确认算法； TIME_WAIT 时延和端口耗尽 TCP连接的握手时延建立一条新的 TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的 IP 分组，对连接的有关参数进行沟通。如果连接只用来传送少量数据，这些交换过程就会严重降低 HTTP 的性能。这可以理解成我们说的三次握手。 TCP 连接握手需要经过以下几个步骤。 (1) 请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ～60 个字节）。这个分组中设置了一个特殊的 SYN 标记，说明这是一个连接请求。 (2) 如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受。 (3) 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立。 现代的 TCP 栈都允许客户端在这个确认分组中发送数据。 注意：HTTP程序员永远不会看到这些分组，这些分组都由 TCP/IP 软件管理。HTTP 程序员看到的只是创建 TCP 连接时存在的时延。小的 HTTP 事务可能会在 TCP 建立上花费 50%，或更多的时间。后面的小节会讨论 HTTP 是如何通过重用现存连接，来减小这种 TCP 建立时延所造成的影响的。 延迟确认简单来说，就是如何确认数据正确传输，怎么知道分组被破坏，怎么确定应不应该重发数据呢？ 由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以 TCP 实现了自己的确认机制来确保数据的成功传输。 每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。 由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。 为了增加确认报文找到同向传输数据分组的可能性，很多 TCP 栈都实现了一种“延迟确认”算法。延迟确认算法会在一个特定的窗口时间（通常是 100 ～ 200 毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。 但是，HTTP 具有双峰特征的请求 - 应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。 在对 TCP 栈的任何参数进行修改之前，一定要对自己在做什么有清醒的认识。TCP中引入这些算法的目的是防止设计欠佳的应用程序对因特网造成破坏。对 TCP 配置进行的任意修改，都要绝对确保应用程序不会引发这些算法所要避免的问题。 TCP慢启动什么是TCP 慢启动？简单来说，就是TCP连接的时间是不一样的，开始是慢的，当确定后续可能还有的时候，它的速度是会不断的增加的。 TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 TCP 慢启动（slow start），用于防止因特网的突然过载和拥塞。 TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。 如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为“打开拥塞窗口”。 由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用现存连接的工具。 Nagle算法与TCP_NODELAY如何解决当TCP发送了大量包含少量数据的分组，网络性能会被严重下降的现象？我们知道TCP有一个数据流接口，应用程序可以通过它将任意尺寸的数据放在TCP栈中。即使一次只放一个字节。而且我们也知道，每个TCP段中都至少装在了40个字节的标记和首部。 Nagle 是一个算法，TCP_NODELAY 是一个参数。 Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量TCP 数据绑定在一起，以提高网络效率。RFC 896“IP/TCP 互连网络中的拥塞控制”对此算法进行了描述。 Nagle 算法鼓励发送全尺寸（LAN 上最大尺寸的分组大约是 1500 字节，在因特网上是几百字节）的段。只有当所有其他分组都被确认之后，Nagle 算法才允许发送非全尺寸的分组。如果其他分组仍然在传输过程中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。 HTTP 应用程序常常会在自己的栈中设置参数 TCP_NODELAY，禁用 Nagle 算法，提高性能。如果要这么做的话，一定要确保会向 TCP 写入大块的数据，这样就不会产生一堆小分组了。 TIME_WAIT累积与端口耗尽什么是 TCP/IP 端口耗尽？ 当客户端启动到服务器的 TCP/IP 套接字连接时，客户端通常连接到服务器上的特定端口，并请求服务器通过临时（或暂时）TCP 或 UDP 端口进行响应。如在 Windows Server 2003 和 Windows XP 中，客户端应用程序所使用的临时端口的默认范围为 1025 到 5000。在某些情况下，有可能耗尽默认范围的可用端口。 TIME_WAIT 端口耗尽是很严重的性能问题，会影响到性能基准，但在现实中相对较少出现。大多数遇到性能基准问题的人最终都会碰到这个问题，而且性能都会变得出乎意料地差，所以这个问题值得特别关注。 当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为 2MSL，通常为 2 分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接。 为什么要那样防止在两分钟之内呢？是不是可能是为了防止DDOS??? 现在高速路由器的使用，使得重复分组几乎不可能在连接关闭的几分钟之后，出现在服务器上。有些操作系统会将 2MSL 设置为一个较小的值，但超过此值时要特别小心。分组确实会被复制，如果来自之前连接的复制分组插入了具有相同连接值的新 TCP 流，会破坏 TCP 数据。 2MSL 的连接关闭延迟通常不是什么问题，但在性能基准环境下就可能会成为一个问题。进行性能基准测试时，通常只有一台或几台用来产生流量的计算机连接到某系统中去，这样就限制了连接到服务器的客户端 IP 地址数。而且，服务器通常会在HTTP 的默认 TCP 端口 80 上进行监听。用 TIME_WAIT 防止端口号重用时，这些情况也限制了可用的连接值组合。在只有一个客户端和一台 Web 服务器的异常情况下，构建一条 TCP 连接的 4 个值：1&lt;source-IP-address, source-port, destination-IP-address, destination-port&gt; 其中的 3 个都是固定的——只有源端口号可以随意改变： 1&lt;client-IP, source-port, server-IP, 80&gt; 客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限（比如，60 000 个），而且在 2MSL 秒（比如，120秒）内连接是无法重用的，连接率就被限制在了 60 000/120=500 次 / 秒。如果再不断进行优化，并且服务器的连接率不高于 500 次 / 秒，就可确保不会遇到 TIME_WAIT 端口耗尽问题。要修正这个问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟 IP 地址以增加更多的连接组合。 即使没有遇到端口耗尽问题，也要特别小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。 HTTP连接的处理从 HTTP 的 Connection 首部开始介绍，这是 HTTP 连接管理中一个很容易被误解，但又很重要的部分。然后会介绍一些 HTTP 连接优化技术。 常被误解的Connection首部我们知道 HTTP 允许在客户端和最终的源端服务器之间存在一串 HTTP 中间实体（代理、高速缓存等）。可以从客户端开始，逐跳地将 HTTP 报文经过这些中间设备，转发到源端服务器上去（或者进行反向传输）。 在某些情况下，两个相邻的 HTTP 应用程序会为它们共享的连接应用一组选项。HTTP 的 Connection 首部字段中有一个由逗号分隔的连接标签列表，这些标签为此连接指定了一些不会传播到其他连接中去的选项。比如，可以用 Connection:close 来说明发送完下一条报文之后必须关闭的连接。 Connection 首部可以承载 3 种不同类型的标签： 1. HTTP 首部字段名，列出了只与此连接有关的首部； 2. 任意标签值，用于描述此连接的非标准选项； 3. 值close，说明操作完成之后需关闭这条持久连接 如果连接标签中包含了一个 HTTP 首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发出去。在将报文转发出去之前，必须删除Connection 首部列出的所有首部字段。由于 Connection 首部可以防止无意中对本地首部的转发，因此将逐跳首部名放入 Connection 首部被称为“对首部的保护”。 HTTP 应用程序收到一条带有 Connection 首部的报文时，接收端会解析发送端请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除Connection 首部以及 Connection 中列出的所有首部。而且，可能还会有少量没有作为 Connection 首部值列出，但一定不能被代理转发的逐跳首部。其中包括Prxoy-Authenticate、Proxy-Connection、ransfer-Encoding 和 Upgrade。原因的话，后面会有解释。 串行事务处理时延相当于每次一个HTTP请求都要建立一次TCP连接。假设有一个包含了 3 个嵌入图片的 Web 页面。浏览器需要发起 4 个 HTTP 事务来显示此页面：1 个用于顶层的 HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来。 除了串行加载引入的实际时延之外，加载一幅图片时，页面上其他地方都没有动静也会让人觉得速度很慢。用户更希望能够同时加载多幅图片。 串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸，而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以在加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装载对象的进度很正常，但用户面对的却是一个空白的屏幕，对装载的进度一无所知。 后面几种新兴和现存的方法可以提高HTTP的连接性能。比如 并行连接，通过多条TCP连接发起并发的HTTP请求。 持久连接，重用TCP连接，以消除连接及关闭时延。 管道化连接，通过共享TCP连接发起的并发的HTTP请求。 并行连接如前所述，浏览器可以先完整地请求原始的 HTML 页面，然后请求第一个嵌入对象，然后请求第二个嵌入对象等，以这种简单的方式对每个嵌入式对象进行串行处理。但这样实在是太慢了！HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。在这个例子中，并行加载了四幅嵌入式图片，每个事务都有自己的 TCP 连接。 相当于每次 http 请求都还是要建立一次TCP连接，不同于上面串行的是，这几个TCP链接是并行的而已。所以有可能会出现下面几种问题： 并行连接可能会提高页面的加载速度包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。 主要是合理的李勇网络带宽，就可以达到提高页面加载速度的情况。 这里注意下，这三个链接的时间，不是三条线平行，而是三条线有重叠的情况。这就是并发处理。并行是完全重叠，是一个时间点。并发是在一个时间段上有重叠。 并行连接不一定更快如果带宽不足的话，每一个连接都需要占用一部分带宽。那么意味着，每个对象都会去竞争这样有限的带宽。那么每个对象可能就会按照比较慢的速度加载，那么久有可能性能提升的非常小。甚至没有提升。 即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足（比如，浏览器是通过一个 28.8kbps 的 Modem 连接到因特网上去的）时，大部分的时间可能都是用来传送数据的。在这种情况下，一个连接到速度较快服务器上的HTTP 事务就会很容易地耗尽所有可用的 Modem 带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。 而且，打开大量连接会消耗很多内存资源，从而引发自身的性能问题。复杂的 Web页面可能会有数十或数百个内嵌对象。客户端可能可以打开数百个连接，但 Web 服务器通常要同时处理很多其他用户的请求，所以很少有 Web 服务器希望出现这样的情况。一百个用户同时发出申请，每个用户打开 100 个连接，服务器就要负责处理10 000 个连接。这会造成服务器性能的严重下降。对高负荷的代理来说也同样如此。 实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是 4 个）。服务器可以随意关闭来自特定客户端的超量连接。 并行连接可能让人“感觉”更快一些刚刚我们知道了并行连接并不总是能使页面加载得更快一些。但如前所述，即使实际上它们并没有加快页面的传输速度，并行连接通常也会让用户觉得页面加载得更快了。因为多个组件同时出现在屏幕上时，用户可以看到加载的进展。 持久连接先看看一个名词：站点本地性。什么是站点本地性？ Web客户端经常会打开到同一个站点的连接，比如：一个Web页面上的大部分内嵌图片通常都来自同一个Web站点，而且相当一部分指向其他对象的超链接也都指向同一个站点。 因此当初始化了对某服务器HTTP请求的应用程序，可能会在不久的将来对那台服务器发起更多的请求，比如获取在线图片。这就是站点的本地性。 因此，HTTP1.1及以上的版本，允许HTTP设备在处理事务结束后，依然将TCP连接保持在打开状态。以便在未来请求重用现在的连接。 持久连接：在事务处理结束后仍然保持在打开状态的TCP连接成为持久连接。非持久连接会在每个事务结束之后关闭，持久连接会在不同事务之间仍然保持连接，一直到客户端或者服务器决定关闭为止。 这样的好处也很明显。重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快的进行传输。 持久连接和并行连接比较并行连接可以提高复合页面的传输速度，但是并行连接也有一些缺点，比如： 每个事务都会打开、关闭一个新的连接，会耗费时间和带宽 由于TCP慢启动特性的存在，每一条新连接的性能都会降低。 可打开并行连接的数量实际是有限的。 持久连接有一些比并行连接更好的地方，持久链接降低了时延和连接建立的开销，将状态保持在已调谐状态。但是，要注意，要管理好持久连接，否则可能会出现大量的空闲连接，耗费本地和远程服务器的资源。 现在的一种趋势和比较高效的方式，就是WEB应用程序都会打开少量的并行连接，其中的每一个都是持久连接。 持久连接有两种类型：第一种是HTTP、1.0+的keep-alive和现代的HTTP1.1的persistent连接。 Keep-Alive操作现在keep-alive已经不在被使用了，在HTTP/1.1规范中也没有了对它的说明。但浏览器和服务器对keep-alive的使用仍然非常频繁。 实现HTTP/1.0 keep-alive 连接的客户端通过包含Connection:Keep-Alive首部请求一条连接保持在打开状态。 此时如果服务器如果愿意为下一条请求保持在打开状态，就在响应中包含同样的首部。同时，如果响应中没有包含Connection:Keep-Alive,客户端就会认为服务器不支持Keep-Alive。 12Connection: Keep-AliveKeep-Alive: max=5, timeout=120 表示的是服务器最多还会为5个事务保持连接的打开状态，或者打开状态保持到2分治之后。 Keep-Alive和哑代理Connection首部和盲中继盲中继：blind relay很多老的或者简单的代理都是盲中继，他们只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。 这幅图发生了下面的情况： 客户端发送了Connection:Keep-Alive的首部，请求持久连接。客户端会等待响应，确认服务器是否认可它的请求。 哑代理收到这个HTTP请求，它不知道Connection是什么东西，就把它当做是一个扩展的首部对待，代理不知道Keep-Alive是什么，所以就只是沿着转发链路将报文一字不漏的发给服务器。但是Connection首部是个逐跳首部，只适用于单条传输链路，不应该沿着传输链路向下传输，这样就会出现问题了。 经过中继的HTTP到了服务器，服务器收到了Connection:Keep-Alive,会认为代理希望进行Keep-alive对话，因为代理对服务器来说就是客户端。然后服务器就同意了，并回送了一个Connect:Keep-Alive的响应首部。但代理却不知道什么是Keep-alive是什么。问题出现了。 哑代理将服务器的响应报文发送给了客户端，并且把keep-alive首部也传回去了，客户端看到了，就认为服务器统一了keep-alive对话。所以这个时候，客户端和服务器认为它们在进行keep-alive对话。但是代理什么都不知道。 由于代理对keep-alive什么都不知道，所以会把收到的数据都给客户端，然后等待资源服务器关闭资源。但是源服务器会认为代理已经显示的请求它，所以不会关闭，那么代理就会一直挂着等待连接关闭。 这个时候，客户端收到回送的响应报文的时候，就会立即转向下一条请求，在Keep-alive连接上向代理发送另外一个请求。但是 ，，，，代理不会认为同一条连接上，还会有其他的请求到来，所以请求被忽略了。浏览器就在这里转圈，不会有下一步了。 这种错误的通信方式会导致浏览器一直处于挂起的状态，直到客户端或服务器连接超时，将其关闭。 代理和逐跳首部为了避免上面的代理通信的问题，现在的代理都不允许转发Connection首部和所有名字中出现Connection值中的首部。因此，如果一个代理收到了Connection:Keep-Alive首部，是不应该转发Connection首部，或所有名为Keep-Alive的首部的。 管道连接HTTP/1.1允许在持久连接上可选的使用请求管道。这是在Keep-Alive连接上的进一步优化，在响应到达前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二条第三条就可以开始发送了。 持久连接只是复用了TCP连接，其中的每个HTTP请求仍然是串行的。但是管道连接就是在这个基础上使得每个HTTP请求是并行的。 总结整个就是介绍了下HTTP通道事务处理。了解一些基本的连接方法。解决了以前我的很多疑惑。关键是里面有一些名词解释：比如TCP慢启动，比如延迟确认，比如Nagel算法，端口耗尽，还有管道化连接。这些以前只是听说过，但是具体的都不是很了解，学习了。最后那一张图，就可以代表整个文章的大部分内容了。学习整理自《HTTP权威指南》感谢。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"HTTP报文详解","slug":"HTTP报文详解","date":"2016-04-29T05:17:54.000Z","updated":"2016-12-12T02:28:42.000Z","comments":true,"path":"2016/04/29/HTTP报文详解/","link":"","permalink":"http://sevencai.github.io/2016/04/29/HTTP报文详解/","excerpt":"","text":"HTTP报文我们已经很熟悉了。如果说HTTP是因特网的信使，那我们可以把HTTP报文当做它用来搬东西的包裹了。下面是关于HTTP报文这块的详细总结和记录。主要内容有：报文时如何流动的？HTTP报文的组成是什么？我们知道报文可以分为请求报文和响应报文，那么这两个又有什么区别呢？请求报文支持的各种功能和方法有？响应报文状态常见的码总结。图片全部来源《http权威指南》，感谢。 报文流HTTP报文是再HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的原信息开头。这些信息描述了报文的内容及含义。这些报文时再客户端，服务器，代理之间不断的流动的。我们一般用“流入”，“流出”，“上游”，“下游”来描述报文流动的方向。 报文流入服务器端并流回客户端这个很好理解。 报文向下游流动注意，这里不管是请求还是响应报文，所有报文都是会向下游流动。所有报文的发送者都在上游，接受者都在下游。报文就像河水一样。河水不能往上游流，是不是？一样的道理。 报文的组成部分-重要每一条报文都是包含一个来自客户端的请求，或者是一条来自服务器的响应。它们由三个部分组成，对报文进行描述的起始行，包含属性的首部块，以及可选的包含数据的主体部分。即：start line+header+body。 起始行和首部都是由行分割的ASCII文本。每一行都是以一个由两个字符组成的序列作为结束。一个回车13，一个换行10。我们把这个终止序列可以写作CRLF。 这里要注意下，虽然标准是说要CRLF表示终止行，但是稳健的应用程序也应该接受单个换行符作为行的终止。因为有一些老的不完成的应用程序并不能总是即发送回车，又发送换行。 实体，也就是body部分。是一个可以选择的数据块。但是与起始行和首部不同，body部分可以是文本，可以是二进制，当然也可以为空。注意下上面图里的content-length是说的主体部分的长度。 报文的语法请求报文的语法&lt;method&gt;&lt;request-url&gt;&lt;version&gt; &lt;headers&gt; &lt;entity-body&gt; 响应报文的语法&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt; &lt;headers&gt; &lt;entity-body&gt; 具体解释上面语法 方法（method）：客户端希望服务器对资源执行的动作，是一个单独的词，比如GET,POST,HEAD。 请求URL（request-url）:命名了所请求的资源，如果是直接跟服务器对话，则只要是绝对路径，但如果通过了代理就是要写全。 版本（version）:HTTP/&lt;major&gt;.&lt;minor&gt;主要是版本号和次要版本号。都是整数，1.22和1.3,版本号不会被当做小树来处理，都是单独的数据。所以2.22比2.3要高。因为22&gt;3。 状态码（status-code）:这三个数字描述了请求过程中所发生的情况。 原因短语：数字状态码的可读版本，包含行终止序列之前所有的文本。原因短语只供我们阅读，比如HTTP/1.0 200 NOT OK和HTTP/1.0 200 OK都是表示成功指示。原因短语和状态码成对出现。 首部（headers）：可以有多个header,名字： 值 CRLF 实体（entity-body):可以选择的数据块。实体，也就是body部分。就是HTTP要传输的内容。是一个可以选择的数据块。可以是文本，二进制，空。可以承载很多类型，图片，视频，HTML文档，软件应用陈旭，信用卡事物，电子邮件等。 方法method注意这些方法的请求报文中有主体，有些则是没有主体的请求，并且也并不是所有的服务器都实现了上面的7中方法。而且就算服务器实现了所有的这些方法，这些方法的使用也会受到限制。比如put和delete方法，服务器不可能让任何人都可以删除或者存储资源。这些现实都会在服务器进行配置。因此会随着站点的不同而不同。 下面详细介绍常见的几个方法。 GET请求服务器上的某个资源。 POSTPOST方法起初是要向服务器输入数据的。实际上，通常用来支持表单。 TRACE当客户端发起一个请求的时候，这个请求可能要穿过防火墙，代理，网关，或者其他一些应用程序。每个中间节点都可能会修改该原始HTTP请求。Trace方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样。Trace请求会在目的服务器发起一个换回诊断。航程最后一站的服务器会弹送一个Trace响应。并且把响应主体中携带它收到的原始请求报文。这样就可以在客户端查看在所有中间HTTP应用程序组成的请求上。原始报文是否或者如何被毁坏或修改过。 注意，trace请求中不能带有实体部分的主体内容，trace响应的实体主体部分包含了响应服务器收到的请求的精确副本。 HEADHEAD方法与GET方法很类似，但服务器在响应中只返回首部，不会返回实体，这就允许客户端在未获取实体资源的情况下，对资源的首部进行检查，使用HEAD的作用具体如下： 1. 在不获得资源的情况下了解资源的情况（比如判断类型）。 2. 通过查看响应中的状态码，看看某个对象是否存在。 3. 通过查看首部，测试资源是否被修改。 DELETE请服务器删除请求URL所指定的资源，但是客户端应用程序无法保证删除的操作一定会被执行。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。 PUT与GET从服务器中读取文档相反，PUT方法会向服务器写入文档。有些发布系统允许用户创建WEB页面并用PUT直接安装到服务器上去。 它的语义就是让服务器用请求主体部分来创建一个由所请求的URL命名的新文档。或者，如果这个URL已经存在，就用这个主体代替它。一般Web服务器都要要求在执行PUT之前，用密码登陆。原因你懂的。 OPTIONSOPTIONS方法请求Web服务器告之其支持的各种功能。可以询问服务器通常支持的哪些方法。或者堆某些特殊资源支持哪些方法。 这的作用就是为客户端应用程序提供了一种手段。使其不用实际访问哪些资源就能判定访问的资源的最优方式。 状态码方法是用来告诉服务器要做什么事情的，状态码是用来告诉客户端发生了什么事情的。可以通过三维数字代码对不同的状态码进行分类。 我们可以看到目前定义了的状态码不是很多。但是分类很明确。 主要了解下： 100（continue）,101(Switching Protocols), 200(ok),201(created),202(accepted), 300(Multipul Choices),301(moved permanently),302(Found),303(See other),304(Not Modified), 400(Bad Request),401(Unauthorized),402(Payment Required),403（Forbidden）,404(Not Found), 500(Internal Server Error),501(Not Implemented),502(Bad Gateway),503(Service Unavailable),504(Gateway Timeout) 301：永久重定向，302临时重定向。 307：HTTP1.1指出，对于HTTP1.1客户端，用307状态码来取代302状态码来进行临时重定向，这样就可以把302状态码保留起来，为HTTP1.0客户端使用。这样一来，服务器要选择适当的重定向状态码放入重定向响应中发送。 402：该状态码暂时未使用，但是被保留了，以做未来使用 502：作为代理或者网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应。（比如：无法连接到其他网关上） 503：用来说明服务器目前无法 为请求提供服务。但将来可以。 首部首部和方法配合工作，可以共同决定客户端和服务器能做什么事情。这有分为了通用首部，请求首部，响应首部，实体首部，扩展首部这些分类。 通用首部：客户端和服务器端都可以使用的首部。比如Date首部。Date: Tue,3 Oct... 请求首部：请求首部是请求报文特有的。比如Accept:*/*。它们为服务器提供了一些额外的信息。比如客户端希3. 望接收什么类型的数据。 响应首部：响应报文特有的，以便为客户端提供信息，比如客户端正在跟哪种服务器发生通信。Server: Tiki... 实体首部：是用于实体部分的首部，比如可以说明主体部分的数据类型。Content-type: text/html;charset... 扩展首部：非标准首部，由应用程序开发者创建，但还是没有添加到规范中去。 总结主要是对整个报文部分做了一个稍微完整点的了解和记录。其实还有比如状态码部分都是很粗略的介绍，还有关于首部，里面的各个分类分别有哪些信息都只是大概的记录下。我觉得这些可以遇到的时候再去查，现在大概的看下有哪些和大致的作用就可以了。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"Web组件结构和URL的简单介绍","slug":"Web组件结构和URL的简单介绍","date":"2016-04-28T15:30:45.000Z","updated":"2016-12-12T02:31:38.000Z","comments":true,"path":"2016/04/28/Web组件结构和URL的简单介绍/","link":"","permalink":"http://sevencai.github.io/2016/04/28/Web组件结构和URL的简单介绍/","excerpt":"","text":"以前大二的时候，接触到了《HTTP权威指南》这本书，当时觉得这本书好棒，容易懂，而且配了很多图，很容易就明白作者的意思。除去附录，其实也不厚。是不是可能有这样一种趋势，好像外国人都是喜欢把难的东西写的更简单，咱们国内的书可能就喜欢写的很复杂，=。=。当时看了前面三章，到后面讲代理，隧道，网关的时候不太明白就放下了。这段时间有点积累，再加上最近又上了一点点网络课了，再去看的时候就觉很容易明白，也轻松了很多。那时候在CSDN上面写了两篇博客，主要是记录所学的。HTTP概述和TCP/IP。（ps，忽略排版这件事）。所有的图片都是来自这本书。接下来我会每个星期都看几章，然后把东西都整理到博客。主要目的也是整理思路，方便查阅，系统的学习下，也分享给大家。 Web的组件结构我们知道了万维网的基本组件是HTTP客户端和HTTP服务器，他们其实还有与很多其他的Web应用程序进行交互。下面简单的说明下这些Web组件的是什么和他们的作用。具体有代理，网关，隧道，缓存。以后会有专门的文章专门再讲他们。 代理HTTP代理服务器是Web安全，应用集成以及性能优化的重要组成模块。 代理是什么?代理是个HTTP中间实体，它位于客户端和服务器端。 这个图上我们看的出来，代理位于他们中间，并且接收所有的客户端HTTP请求，并且将这些请求转发给服务器，这个过程中，代理服务器可能会做一些修改和变动然后转发给服务器。 代理有很多作用，我们一般把代理作为转发所有Web流量的可信任中间节点使用，因为它可以接触到所有流过的流量。比如代理可以作为过滤器，让儿童就不能看不好的内容。再比如，网络工程师用代理服务器提高安全性，把代理服务器当做安全防火墙。再比如我们利用代理服务器做缓存，利用代理做反向代理，内容路由器等等。 代理还可以分为正向代理和反向代理。这个我有先前写过一篇博客。文章地址 这中间可以思考下面的几个问题： 代理请求中的URI和服务器请求中的URI有什么不同呢？ 我们刚刚知道了代理服务器可以修改内容，那么修改URI的原则是什么呢？ 拦截和反向代理是怎么把服务器主机的信息隐藏起来的呢？我们知道反向代理时，用户不知道代理服务的存在。 代理怎么样印象浏览器的只能URI自动完成机制，或主机扩展名特性呢？比如我输入cailidan,浏览器会去搜什么呢？http://cailidan.com?还是http://cailidan.cn? 缓存Web缓存，也成为代理缓存，它是上面的一种特例，是一个特殊的代理服务器。可以常常把代理传送的常用文档存起来。这样下一个请求同一个文档的客户端就可以直接在代理商享受私有副本提供的服务了。 为什么要这样呢？客户端从离他近的地方下载文档不很明显比从远程的Web服务器上下载要快很多吗？Http定义了很多功能，很多头部，用来更高效的缓存，也规范了新鲜度和缓存内容的隐私性。 网关网关是什么？网关是一个特殊的服务器，作为其他服务器的中间实体使用。主要用来将HTTP流量转化为其他的协议，用户在发送请求的时候，并不知道自己正在是和网关通信，网关这时候表现的就像资源的源端服务器一样。 如上面的图，一个HTTP/FTP的网关会通过HTTP请求对FTP URI的请求，但通过TFP来获取文档。得到了文档会被FTP服务器封装成成一条HTTP报文。并且发送给客户端。 好，到这里，网关和代理又有什么区别呢？ 严格来说，代理连接的是两个或者多个使用相同协议的应用程序，而网关却连接的是两个或者使用不同协议的端点。网关扮演的是“协议转换器”的角色。及时客户端和服务器使用的是不同协议，客户端也能够通过它完成和服务器之间的事物处理。 隧道通过Web隧道，我们可以通过HTTP应用程序访问使用费HTTP协议的应用程序。 隧道是建立起来后，就会在两条连接中间对原始数据进行盲转发的HTTP应用程序。Http隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，并且转发时也不会窥探数据。 Web隧道允许用户通过HTTP连接而发送非HTTP流量，这样就可以在HTTP上稍带其他的协议数据了。使用Web隧道最常见的原因就是要在HTTP连接中嵌入非HTTP流量，这样，这类流量就可以穿过只允许Web流量通过的防火墙了。 如在上面这个图中，看到HTTP隧道的常见用途，是通过HTTP连接承载加密的安全套接字流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。在HTTP/SSL隧道中收到了一条HTTP请求，要求建立一条道目的地址和端口的输出连接，然后在HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其忙转发到目的服务器上去了。 简单的说，HTTP隧道技术就是把所有要传送的数据全部封装到HTTP协议里进行传送。 URL与资源URL，我们已经再熟悉不过了。URL是因特网资源的标准化名称，URL是URI的子集，下面主要介绍：URL语法，URL编码和字符集规则，常见的URL方案，URL的未来-URN。 URL因特网的语法URL包括三个部分,URL方案，服务器位置，资源路径–schema,host,path。URL可以指定HTTP之外的其他协议来访问，但大多数都有同样的这种结构。 方案：//服务器位置/路径 1&lt;schema&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;param&gt;?&lt;query&gt;#&lt;frag&gt; 如下所示： http://www.cailidan.cn/images/1.png ftp://ftp.lots-o-books.com/pub/1.xls rtsp://www.joes.com:554/a/vt_video URL有绝对路径和相对路径之分。这中间有专门的算法来将相对路径转化为绝对路径。 自动扩展URL我们知道当用户在输入URL的时候，浏览器会自动进行扩展，不需要用户输入完整的URL。扩展主要是有下面两种方式扩展的。 主机名扩展比如，如果你再地址栏输入cailidan，浏览器会自动在主机名中插入www和.com，构建出www.cailidan.com。显然我使用的是cn.所以这个时候是得不到正确的解析的。找不到时，浏览器会在放弃前尝试集中扩展形式。浏览器通过这些简单的技巧来节省你的时间。但这在代理的时候会出现问题。 历史扩展还有一种节省用户输入URL时间的方法，就是把用户以前访问过的URL存储起来。这样你输入的时候浏览器会提供一些选择给你。 字符URL是可以移植的，这意味着，它要统一的命名因特网上所有的资源，这也意味着要通过各种不同的协议来传送这些资源。安全传输意味着URL的传输不能够丢失。有些协议，比如，传输电子邮件的简单邮件传输协议。所使用的传输方法就会博取一些特定的字符。为了避免这些问题。URL只能使用一些相对比较小的，通用的安全字母表中的字母。并且我们还希望URL可以供人类阅读。因此，即使看不到的，不可打印的字符，从而成为可以移植的。URL还得是完整的。我们需要转移机制，能够把不安全的字符编码为安全字符。再进行传输。 编码机制为了避开安全字符集表示法的限制，人们设置了一种编码机制，用来在URL中表示各种不安全字符。这种方法就是通过转义表示法来表示不安全字符的。转义表示法包括了一个百分号%，后面是两个表示字符ASCII码的十六进制数。 字符限制在URL中，有几个字符被保留起来，有着特殊的含义。这些字符不再定义的US-ASCII可打印字符中，这些字符在将其用在保留用途之外的场合时，要在URL中对其进行编码。比如：%，/,.，#，？,$,&amp;,=之类的。 未来展望URL是可以在各种因特网协议间共享的统一命名机制。但是URL，它表示的是实际地址，而不是准确的名字。URL会告诉你资源在哪个地方。它会为你提供特定端口上特定的服务器的名字，告诉你可以在这个地方找到这个资源。它的缺点是，如果资源被移走了，URL也不再有效了。那个时候，就无法对对象进行定位了。 然后就有人想，如果一个对象有了一个准确的名称，就像人的身份证一样，那么不管这个资源在哪里，我们都可以通过这个名称找到这个对象。这个时候URN出来了。但是这个目前使用的人不是很多额。因为由URL转换成URN是一个很巨大的工程，更何况在URL已经如此普及的情况下。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"《Javascript for PHP Developers》读书笔记","slug":"《Javascript-for-PHP-Developers》读书笔记","date":"2016-04-25T13:56:33.000Z","updated":"2016-12-12T03:01:32.000Z","comments":true,"path":"2016/04/25/《Javascript-for-PHP-Developers》读书笔记/","link":"","permalink":"http://sevencai.github.io/2016/04/25/《Javascript-for-PHP-Developers》读书笔记/","excerpt":"","text":"这本书一共才130多页，当时在图书馆借这本书的时候，纯粹是因为它把部分php和javascript放在一起对比。后来看下去，知识点讲的不细，但是对Javascript整体容易犯错的地方都有解释。而且由于书特别薄，所以读起来也比较方便，目录很清晰。所以还是不错的。下面记录的是我看书的时候发现的一些知识点的漏洞或者是总结。先让我们看看这本书的真面目： 默认参数可能要注意的一个坑12345function sum(a,b)&#123; b = b||2; return a+b;&#125;console.log(sum(2,0)); 我想要把2和0相加，最后得到2，但是这个的输出结果确实4，大家一看肯定明白为什么会输出4了吧。因为当我们传入0的时候，这种比较会得到结果为false。一个可行解决方案是使用typeof。平时要注意这个。12345function sum(a,b)&#123; b = typeof b === \"undefined\"?2:b; return a+b;&#125;console.log(sum(2,0)); substr是非标准的顺便总结下截取字符串的三种方法。123console.log(s.slice(4,7));console.log(s.substring(4,7));console.log(s.substr(4,3)); 几种编码URL方法和它们的区别和联系encodeURI和decodeURI类似于encodeURIComponent和decodeURIComponent，区别在于前者只是编码需要编码的那一部分，将类似于Http://的这个部分是不用动的。并且要注意encodeURI不编码&amp;，具体想用哪个可以根据具体的需求来。 123456789var testUrl = \"https://www.baidu.com/s?r ds v_bp=0&amp;bar=&amp;rsv_spt=3\";console.log(encodeURIComponent(testUrl));console.log(decodeURIComponent(encodeURIComponent(testUrl)));console.log(encodeURI(testUrl));console.log(decodeURI(encodeURI(testUrl)));console.log(escape(testUrl));console.log(unescape(escape(testUrl))); 这里提一下escape和unescape,他们不是ECMAScript的一部分，他们来自于BOM，我们尽量应该避免使用它们。 关于null和undefinedundefined返回的值总是字符串，所以下面这种情况要注意。123456var a;console.log(a);console.log(a == undefined);console.log(a == \"undefined\");console.log(typeof a == undefined);console.log(typeof a == \"undefined\"); 答案是： undefined， true， false， false， true。null要注意的就是typeof null结果是object就行了。 删除属性1234var obj = &#123;one:1,two:2&#125;;delete obj.one;//obj.one = null;console.log(obj); 以前删除一个属性，大部分都是用的obj.one = null这种形式，现在看来我真的是大错特错了。用delete删除，最后obj是Object {two: 2}，one确实被去掉了，而且通过obj.one再去访问的时候，返回的是undefined。但是当我们通过赋值为null这种形式时，它只是被重新赋值为null了，而不是完全的删除了。 php和js的try-catch有什么区别?区别记录如下： 1. js抛出的是Error对象，而不是Exception对象。 2. 捕获时，js没有声明类型。 3. 访问message属性，而不是调用getMessage方法。 具体来看看代码：123456789var msg = \"\";try&#123; throw new Error(\"ouch\");&#125;catch(e)&#123; msg += e.message;&#125;finally&#123; msg += \"-finally\";&#125;console.log(msg); 答案是ouch-finally;看看php是怎么写的：12345try&#123; throw new Exception(\"ouch\");&#125;catch(Exception $e)&#123; $msg = $e.getMessage();&#125; 全局变量和全局对象的属性的细微区别12345678910var john = \"Jo\";console.log(john);console.log(window.john);window.jane = \"Jane\";console.log(jane);console.log(window.jane);console.log(delete window.john);console.log(delete window.jane); 结果是Jo,Jo,Jane,Jane,false,true。主要注意下这个false。我们可以把全局变量当成是全局对象的属性来看，唯一的不同之处在于，你无法删除它们。看这里的john是无法被delete删除的。 利用parseInt把CSS十六进制颜色定义转换为rgb()123456789function getRGB(color)&#123; var r = parseInt(color[1]+color[2],16); var g = parseInt(color[3]+color[4],16); var b = parseInt(color[5]+color[6],16); return \"rgb(\"+r+\",\"+g+\",\"+b+\")\";&#125;var color = \"#ff0000\";console.log(getRGB(color)); 最后的结果是：rgb(255,0,0),总结下全局函数中四个与数字相关的函数分别是：isNaN(),isFinite(),parseInt(),parseFloat()。 toString（）方法12345var o = &#123;&#125;;console.log(o.toString());console.log(Object.prototype.toString.call(o));//字符串\"[object Object]\"对于任何对象都是相同的，所以下面返回trueconsole.log(Object.prototype.toString.call(&#123;&#125;) === Object.prototype.toString(&#123;a:1&#125;)); toString()方法存在于Object.prototype之上，因此，可以像上面那样使用它们。toString方法一般用于测试数组，由于一些原因，其他的一些测试数组方法都会有缺陷，下面的是目前稍微好一点的解决办法。 1234567function isArray(arr)&#123; if(!Array.isArray)&#123; return Object.prototype.toString.call(arr) === \"[object Object]\"; &#125; return Array.isArray(arr);&#125;isArray([1,2]); 构造器函数Number，String,Boolean,这些，如果直接使用构造器函数，而不是以new一个对象的形式，就返回的是原始类型，而不是对象。这个先前博客里有提到过。比如typeof Number(1.1)返回结果是&quot;number&quot;，typeof new Number(&quot;1,1&quot;),结果是object。Number(1.1)返回的结果是1.1。Number(123).toFixed(2);结果是123.00。 123console.log(Number(123).toFixed(2));console.log((100000000000).toExponential());console.log((100000000000).toPrecision(3)); forEach传递给回调函数的参数我容易把第一个和第二个写反。比如写成function(index,item)这样是不能得到正确结果的。正确的格式如下：[元素，元素索引，整个数组]123[\"a\",\"b\",\"c\"].forEach(function()&#123; console.log(arguments);&#125;) 通过JSON深拷贝创建一个深拷贝的最简单方式，是使用JSON编码后再解码该对象，这可能不是最高效的方式，特别是在不能使用JSON的浏览器中。1234567var stuff = &#123; a:&#123; b:[1,2] &#125;&#125;;console.log(JSON.stringify(stuff));console.log(JSON.parse(JSON.stringify(stuff))); 构造器和类下面的篇幅有点长，涉及到构造器，类，返回对象和this指针。123456789function Dog()&#123; this.name = \"littleDog\"; this.sayName = function()&#123; return this.name; &#125;&#125;var myDog = new Dog();console.log(myDog.sayName()); 上面是一个再简单不过的我们创建的构造器函数了。我们回顾下，在我们使用new调用任何一个函数时，会发生下面的事情： 1. 在后台自动创建一个空的对象，通过this引用该对象。var this = {};//伪代码，直接这样是会报错的。 2. 程序员可以给任意的this添加属性。如this.name=&quot;littleDog&quot;。 3. 在函数的末尾，我们隐式的返回了this。return this,这不是一个错误，但是我们不需要使用它。 我们可以通过返回一个对象，从而改变步骤3，但是这个会发生下面的问题。12345678910function Dog()&#123; this.name = \"littleDog\"; var notthis = &#123;noname:\"noname\"&#125;; return notthis;&#125;var myDog = new Dog();console.log(myDog.noname);console.log(myDog.name); noname， undefined这是我们会得到的结果结果，我们在这个构造器中返回了一个自定义对象，但也使用了this,当我们用返回的对象，访问对象的属性是肯定没有问题，但我们访问this定义的却是undefined。原因是： 在这个实例中，我们给this添加的任何内容，在函数返回的时候都直接销毁了，你可以删除它，并且在这种情况下，我们不需要借助new的魔力，我们可以就把它当作一般的函数调用，也可以实现相同的效果。如下： 12345678910function Dog()&#123; this.name = \"littleDog\"; var notthis = &#123;noname:\"noname\"&#125;; return notthis;&#125;var myDog = Dog();console.log(myDog.noname);console.log(myDog.name); 这个过程中我们又要注意，如果我们返回的任何this以外的内容，都会导致instanceof运算符和constructor属性无法正常工作。123var myDog = new Dog();console.log(myDog instanceof Dog);console.log(myDog.constructor === Object); 结果是，false,true。 当我们使用new的时候，可以返回一个定制的对象，而不是this,但是它必须是一个对象，如果你尝试返回一个非对象，将导致返回值被忽略，最后还是会得到this 12345678910function Dog()&#123; this.name = \"littleDog\"; this.sayName = function()&#123; return \"hello, \"+this.name; &#125; return 1;&#125;var myDog = new Dog();console.log(myDog.sayName()); 这个例子里1将会被忽略。同样是返回this。但如果我们var myDog = Dog();肯定结果就是1了，对吧。 增强构造器我们是可以通过变成来确保即便调用者忘记了new,函数也会像是构造器函数一样工作。可以使用instanceof，它接受一个对象和一个构造器函数的引用，返回true或者false。1234567891011121314function Dog()&#123; if(!(this instanceof Dog))&#123; return new Dog(); &#125; this.name = \"littleDog\"; this.sayName = function()&#123; return \"hello, \"+this.name; &#125; return 1;&#125;var myDog = Dog();console.log(myDog.sayName()); 总结主要就是一个记录，方便以后查阅，也是给花的时间的一个交代，每次看完一个书，如果不把重点记下来，估计过了不久就又忘了，心痛。是我记忆太差了吗？明天就可以把书还回去啦，完美。感谢这本书的作者，Stoyan Stefanov。学习了。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"记我最近犯过的错和知识不熟悉的地方","slug":"记我最近犯过的错和知识不熟悉的地方","date":"2016-04-20T15:33:01.000Z","updated":"2016-12-12T03:02:28.000Z","comments":true,"path":"2016/04/20/记我最近犯过的错和知识不熟悉的地方/","link":"","permalink":"http://sevencai.github.io/2016/04/20/记我最近犯过的错和知识不熟悉的地方/","excerpt":"","text":"前些时候，发现了自己的很多问题，因为手头当时有项目要做，所以找到问题的原因,写了demo后，就放在了一边，并没有整理心得，今天把先前的稍微整理下。对大家来说可能并没有实际意义。可以忽略。 js获得时间戳的东西下面是总结的五种获得时间戳的方法。12345console.log(new Date().getTime());console.log(+new Date());console.log(Date.parse(new Date()));console.log(new Date().valueOf());console.log(Date.now()); chrome里面测试代码用时的小tip在代码前面使用console.time。在代码之后使用console.timeEnd();即可 children和childNodes的区别直接打印下，直观的感受下：12345678&lt;div id=\"test\"&gt; hello start; &lt;p class=\"a\"&gt;this is p1&lt;/p&gt; &lt;p&gt;this is p2&lt;/p&gt; &lt;p id=\"test\"&gt;this is p3&lt;/p&gt; hello end; &lt;p&gt;this is p4&lt;/p&gt;&lt;/div&gt; 1234var o = document.getElementById(\"test\");console.log(o.hasChildNodes());console.log(o.children);console.log(o.childNodes); 不看答案，看都能不能说对。 我们可以看到childNodes返回html节点和文本等节点。children只返回html节点，不返回文本节点。 childNodes，是一个标准属性，它返回指定元素的子元素集合，包括HTML节点，所有属性，文本。可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。 children，非标准的属性，它返回指定元素的子元素集合。它只返回HTML节点，甚至不返回文本节点。 所以当我们如果要用childNodes获取html节点的时候，就要进行过滤，如下： 12345for(var i=0,len=o.childNodes.length;i&lt;len;i++)&#123; if(o.childNodes[i].nodeType == 1)&#123; console.log(o.childNodes[i]); &#125;&#125; 中间还有一个问题，如果我们想要获得元素的第一个html节点或者最后一个节点，我们肯定先想到的是firstChild和lastChild,如下，我们是获取不到的，获得到的是text文本。而且仔细看上面，空格也算是文本，所以一定是获取不到节点的。空格和换行我们都可以在控制台看到。12console.log(o.firstChild);console.log(o.lastChild); 但是如果我们稍微改一下，把&lt;p&gt;和&lt;/div&gt;中间的空格去掉，我们就可以获得到最后一个节点是p啦。 1234567&lt;div id=\"test\"&gt; hello start; &lt;p class=\"a\"&gt;this is p1&lt;/p&gt; &lt;p&gt;this is p2&lt;/p&gt; &lt;p id=\"test\"&gt;this is p3&lt;/p&gt; hello end; &lt;p&gt;this is p4&lt;/p&gt;&lt;/div&gt; 这里就要接着认识下，element和node的区别是什么呢？ 元素(Element)和结点(Node)有区别，节点包含了元素，元素一定是节点，而必须是含有完整信息的结点才是一个元素。DOM将文档中的所有都看作节点 node&gt;element，两个标签之间的空白也是这棵树的一个节点（Text节点） 想一想下面会输出什么呢？ 1234567console.log(o);console.log(o.firstChild);console.log(o instanceof Node);console.log(o instanceof Element);console.log(o.firstChild instanceof Node);console.log(o.firstChild instanceof Element); 我们可以看到用document.getElementById(“xxx”)取到的既是Element也是Node。children是Element的属性，childNodes是Node的属性。 dom选取页面元素对象的子对象时，children 选取不包括空白节点， 而childNodes在firefox会选取空白节点。 记录一个可以异步加载js文件并可以调用回调函数的脚本主要想法是创建script标签，然后给script设置异步执行，然后每次加载完一个js文件，就把count+1，并且检查当前的已经加载了的文件是否等于传入的文件的数量，如果已经相等了，表示所有的文件已经加载完毕，这时候，调用回调函数。这里我利用的是以构造函数的形式创建对象。123456789101112131415161718192021222324252627282930313233343536373839function Loader()&#123; var head = document.getElementsByTagName(\"head\")[0]; var loadCount = 0; this.require = function (scripts,callback)&#123; this.totalScripts = scripts.length; this.callback = callback; for(var i=0;i&lt;this.totalScripts;i++)&#123; this.createScript(scripts[i]); &#125; &#125;; this.createScript = function(url)&#123; var script = document.createElement(\"script\"); var self = this; script.src = url; script.defer = true; script.type = \"text/javascript\"; script.addEventListener(\"load\",function(e)&#123; loadCount++; self.check(); &#125;,false); head.appendChild(script); &#125;; this.check = function()&#123; if(this.totalScripts == loadCount &amp;&amp; typeof this.callback == 'function')&#123; this.callback(); &#125; &#125;&#125;var load = new Loader();load.require(['33.js','44.js'],function()&#123; console.log(\"all scripts have been loaded\");&#125;); 引用赋值时的坑123456789var a = &#123;\"x\": 1&#125;;var b = a;a.x = 2;console.log(b.x);a = &#123;\"x\":3&#125;;console.log(b.x);a.x = 4;console.log(b.x); 这个例子我觉得很经典。答案是b.x的值一直是2。我们要理解这个过程中发生了什么事。首先声明了一个a对象，b=a，因为是引用赋值，所以b和a指向同一个对象。所以这个时候，a改变或者b改变都是会影响对方的。后来，我们给a重新赋值，这个时候，是重新开辟了一个空间，a指向新的对象，b还是指向原来的对象，这个时候a和b已经没有关系了。 用JS画一个圆这个主要就是利用数学的原理，然后把点画出来定位就可以了。就是记录一下。1234567891011121314151617181920212223var Circle = function()&#123; var PI = Math.PI; return &#123; draw:function(r,_x,_y)&#123; var x,y; for(var i=0;i&lt;360;i++)&#123; x = Math.cos(PI/180 * i)*r+_x; y = Math.sin(PI/180 * i)*r+_y; var point = document.createElement(\"span\"); point.appendChild(document.createTextNode(\".\")); document.body.appendChild(point); point.style.position = \"absolute\"; point.style.top = y+\"px\"; point.style.left = x+\"px\"; &#125; &#125; &#125;&#125;();Circle.draw(100, 500, 600); jquery中.closet和.parents的区别 有时候看代码可能会更容易理解，我们看下面这个例子。具体的来看下面这个例子：1234567891011121314151617&lt;ul&gt; &lt;li&gt;I&lt;/li&gt; &lt;li&gt;II &lt;ul&gt; &lt;li class=\"item-a\"&gt;A&lt;/li&gt; &lt;li&gt;B &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;III&lt;/li&gt;&lt;/ul&gt; 如果我们用parents得到的结果是这样的：1$('li.item-a').parents('ul').css('background-color', 'red'); 如果我们用parents得到的结果是这样的：1$('li.item-a').closest('ul').css('background-color', 'red'); fiddler的工作原理从图中我们可以看到，fiddler充当的就是一个代理的作用，当我们的从客户端发送请求时，就是先通过代理服务器，让后由代理服务器发送给服务器。这样我们就可以通过fiddler中间做很多事情。回头我仔细会用fiddler了，再来专门写一篇。现在不是很会用。 闭包的坑看看下面是输出什么，如果一眼看不出来，就是闭包掌握的还不好，最后输出的都是Z。1234567891011121314151617function A(params) &#123; params = params || &#123;&#125;; for (var key in params) &#123; this[key] = function() &#123; return params[key];&#125;; &#125;&#125;var a = new A(&#123; 'x': 'X', 'y': 'Y', 'z': 'Z'&#125;);console.log(a.x());console.log(a.y());console.log(a.z()); 记录和整理二，接着上次的整理。主要记录的是容易犯的错和一些知识点的归纳总结。 关于typeof和instanceof的坑typeof 123 typeof new Number(123) typeof null typeof NaN 123 instanceof Number new Number(123) instanceof Number Number(123) instanceof Number 上面的答案是什么呢？ typeof的返回值有number,boolean,string,function,object,undefined这6个。记住只有这6个，而且里面没有array。typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。 这里面要注意的就是第4个，NaN是一个特殊的东西，它和任何东西都不相等，用typeof返回的是Number。注意只有new的结果返回的是一个对象，Number和直接定义数字直接量都是返回的数字值。 123console.log(Number(123));console.log(new Number(123));console.log(123); 再来一波测测是否理解：12345678910111213console.log(typeof(1));console.log(typeof(NaN));console.log(typeof(Number.MIN_VALUE));console.log(typeof(Infinity));console.log(typeof(\"123\"));console.log(typeof(true));console.log(typeof(window));console.log(typeof(document));console.log(typeof(null));console.log(typeof(eval));console.log(typeof(Date));console.log(typeof(sss));console.log(typeof(undefined)); 看看fragment的用法12345678var frament = document.createDocumentFragment();for(var i = 0;i&lt;10;i++)&#123; var ele = document.createElement(\"p\"); var node = document.createTextNode(\"hello\"); ele.appendChild(node); frament.appendChild(ele);&#125;document.body.appendChild(frament); createdocumentfragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。当你想提取文档的一部分，改变，增加，或删除某些内容及插入到文档末尾可以使用createDocumentFragment() 方法。你也可以使用文档的文档对象来执行这些变化，但要防止文件结构被破坏，createDocumentFragment() 方法可以更安全改变文档的结构及节点。 说明：添加多个dom元素时，先将元素append到DocumentFragment中，最后统一将DocumentFragment添加到页面。 该做法可以减少页面渲染dom元素的次数。经IE和FireFox下测试，在append1000个元素时，效率能提高10%-30%，FireFox下提升较为明显。 看下下面这几个输出123console.log(Number.MAX_VALUE);console.log(Number.MIN_VALUE);console.log(Math.pow(2,53)); 打乱数组的一种方法随机生成一个在数组长度内的数，每次把数组中的一个元素和该生成数对应的值调换即可。据说是目前打乱数组的最好方法（交换）；123456789101112131415function shuffle (arr)&#123; var length = arr.length; while(length)&#123; var index = Math.floor(Math.random()*length); length--; var temp = arr[length]; arr[length] = arr[index]; arr[index] = temp; &#125; return arr;&#125;var myArray = ['1','2','3','4','5','6','7','8','9'];console.log(shuffle(myArray)); arguments对象12345678(function()&#123; console.log(arguments instanceof Array); var argArr = Array.prototype.slice.call(arguments); console.log(argArr instanceof Array); console.log(Function instanceof Object); console.log(Object instanceof Function);&#125;)() 输出值分别为false和true,true,true。记住Array.prototype.slice.call(arguments)这也是一种把arguments转化成数组的方法。 sort方法有一个数组，其中保存的都是小写英文字符串，现在要把它按照除了第一个字母外的字符的字典顺序(字典顺序就是按首字母从a-z顺序排列，如果首字母相同则按第二个字母……)排序。1234567891011121314var compare = function (a,b)&#123; if(typeof(a) === \"string\" &amp;&amp; typeof(b) === \"string\")&#123; var new_a = a.slice(1); var new_b = b.slice(1); if(new_a&gt;new_b)&#123; return 1; &#125;else if(new_a&lt;new_b)&#123; return -1; &#125; &#125; return 0;&#125;var arr = [\"abd\",\"cba\",\"ba\"]; 关于document.links获取文档中的所有links标签，然后获取里面的内容。1234567891011var links = document.links;var length = links.length;for(var i = 0;i&lt;length;i++)&#123; (function(i)&#123; links[i].onclick = function(e)&#123; alert(e.target.innerHTML); e.preventDefault(); &#125; &#125;)(i)&#125; 写一个ua函数，判断当前浏览器是什么浏览器12345678910111213141516var Sys = &#123;&#125;;var ua = navigator.userAgent.toLowerCase();console.log(ua);var s;(s = ua.match(/msie ([\\d.]+)/)) ? Sys.ie = s[1] :(s = ua.match(/firefox\\/([\\d.]+)/)) ? Sys.firefox = s[1] :(s = ua.match(/chrome\\/([\\d.]+)/)) ? Sys.chrome = s[1] :(s = ua.match(/opera.([\\d.]+)/)) ? Sys.opera = s[1] :(s = ua.match(/version\\/([\\d.]+).*safari/)) ? Sys.safari = s[1] : 0;//以下进行测试if (Sys.ie) console.log('IE: ' + Sys.ie);if (Sys.firefox) console.log('Firefox: ' + Sys.firefox);if (Sys.chrome) console.log('Chrome: ' + Sys.chrome);if (Sys.opera) console.log('Opera: ' + Sys.opera);if (Sys.safari) console.log('Safari: ' + Sys.safari); 尽量用最简单的达到想要的要求123456789101112131415function spacify(str)&#123; return str.split('').join(' ');&#125;console.log(spacify('hello world'));String.prototype.spacify = function()&#123; return this.split('').join(' ');&#125;console.log(\"hello world\".spacify());function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift(\"(app)\"); console.log.apply(console,args);&#125;log(\"hello\",\"world\"); 编写一个方法 求一个字符串的字节长度123456789101112function getLength(str)&#123; var length = str.length; var init = length; for(var i = 0;i&lt;init;i++)&#123; if(str.charCodeAt(i) &gt;255)&#123; length++; &#125; &#125; return length;&#125;console.log(getLength(\"woshi好人\"));","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"监控脚本代码异常并上报的方法","slug":"监控脚本代码异常并上报的方法","date":"2016-04-19T12:42:51.000Z","updated":"2016-12-12T03:02:16.000Z","comments":true,"path":"2016/04/19/监控脚本代码异常并上报的方法/","link":"","permalink":"http://sevencai.github.io/2016/04/19/监控脚本代码异常并上报的方法/","excerpt":"","text":"如何完成一个记录网站加载脚本时发生的错误，并把错误上报呢？这是网站上线时最经常的需求。 一般当我们的脚本发生错误时，浏览器都会在console里体现出错误信息，并且会提示我们出错的文件，行号，堆栈信息，此时js停止往下执行：比如这样： 到这里先问自己一个问题，前端异常具体是指什么呢？ 第一种情况：JS脚本里边存着语法错误，第二种情况：JS脚本在运行时发生错误 一般有两种情况可以处理这两种错误： 一种是try,catch方案，我们针对性的在可能出错的地方使用try,catch块。这个代码块如果出错了我们可以在catch块中收集并处理。 一种是监听window的onerror事件，比如我们使用window.onerror=function(){}或者是window.addEventListener(&quot;error&quot;,function(event){}),这个onerror可以收集语法错误和运行时的错误，还可以知道出错的信息，文件，行号，列号等。 利用try,catch的方法先来回忆复习下try,catch的基本用法。下面是我们最初学try,catch时会写的一个小demo。主要是throw的用法。throw 语句允许我们创建自定义错误。正确的技术术语是：创建或抛出异常（exception）。如果把 throw 与 try 和 catch 一起使用，就能够更加精准控制程序流，并生成自定义的错误消息。throw exception,这个异常可以是我们创建的字符串，数字，逻辑值，对象等。注意要小写。 123&lt;input type=\"text\" placeholder=\"请填入一个5到10之间的数字\" id=\"inputValue\"&gt;&lt;button onclick=\"test()\"&gt;测试输入值是否合法&lt;/button&gt;&lt;p id=\"tip\"&gt;&lt;/p&gt; 12345678910111213141516171819202122function test()&#123; try&#123; var value = document.getElementById(\"inputValue\").value; if(value == \"\")&#123; throw \"数字不能为空\"; &#125; if(value&gt;10)&#123; throw \"数字不能大于10\"; &#125; if(value&lt;5)&#123; throw \"数字不能小于5\"; &#125; if(isNaN(value))&#123; throw \"必须为数字\"; &#125; &#125;catch(e)&#123; var tip = document.getElementById(\"tip\"); tip.innerHTML = e; //console.log(e); &#125; &#125; 但是，try,catch有两个很严重的问题，第一个就是如果代码块有语法错误，此时JS解释器不会执行当前这块代码块，也更加不会执行catch里面的东西了。第二个问题就是try,catch可以理解成一个函数块，这有这个里面的运行错误才会被捕捉，也就是没有办法捕捉到全局错误事件。 第一个就是语法错误，不会捕捉，会停止运行，上代码： 123456try&#123; if =1;&#125;catch(e)&#123; console.log(\"testerror\"); console.log(e);&#125; 如图所示，并不会打印出错误信息，只是在控制台直接输出了错误信息。如果我们把这个语法错误变为执行时的错误，就是可以捕捉到的。如下图所示： 123456try&#123; i&lt;l;&#125;catch(e)&#123; console.log(\"testerror\"); console.log(e);&#125; 第二种情况怎么理解呢？ try,catch只能捕捉到当前执行流里面的运行错误，对于异步回调来说，是不能被try,catch来捕捉的。我们知道js是单线程的，回调里面的都被放到了任务队列里面。如下例子：12345678try&#123; var btn = document.getElementsByTagName(\"button\")[0]; btn.onclick = function()&#123; i&lt;l; &#125;&#125;catch(e)&#123; console.log(e);&#125; 这时候我们打开浏览器是不会有任何东西输出的。 利用window.onerror方法先具体看下onerror在什么情况下会被触发：An event handler for the error event. Error events are fired at various targets for different kinds of errors: When a JavaScript runtime error (including syntax errors) occurs, an error event using interface ErrorEvent is fired at window and window.onerror() is invoked. When a resource (such as an &lt;img&gt; or &lt;script&gt;) fails to load, an error event using interface Event is fired at the element, that initiated the load, and the onerror() handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a single capturing window.addEventListener. 具体的参数和语法如下，可以去MDN上看. 比如我们就把onerror的arguments对象打印出来就可以得到下面的结果： 或者可以获得到出错信息的文件名，行号，列号，并且通过设置返回值为true或者false来保证信息不输出到控制台上。比如下面的例子：123456789101112window.onerror = function(message, source, lineno, colno, error) &#123; console.log(\"-----------\"); console.log(message); console.log(source); console.log(lineno); console.log(colno); console.log(error); return true;&#125;//line1if = 1; 会得到下面的结果： 这里注意下，语法错误不能放在onerror代码块内部，如果放在里面，因为语法在这个onerror里面都没有被通过，就更不可能会被执行了，就会跟平常一样代码直接打印到控制台。所以我们要把onerror单独提取出来，并放在其他脚本前面执行。 这里还要注意一点，就是如果我们的js文件不是本地文件，是跨域文件，当这个文件出现了错误时，我们是不能够获得详细的信息的。只会简单报错： Script error，这样是为了防止信息泄露，避免不安全。那如果我们确实要跨域访问，怎么办呢？ 我们需要在客户端和服务器端同时设置可跨域访问。客户端中的image和script标签都有 crossorigin参数，这个属性是告诉浏览器我要加载的这个资源是可以信任的。并在服务器端再设置：Access-Control-Allow-Origin的响应头。比如header(&#39;Access-Control-Allow-Origin: *&#39;);。下面这段话仔细看下可能更加好理解。 When a syntax(?) error occurs in a script, loaded from a different origin, the details of the syntax error are not reported to prevent leaking information (see bug 363897). Instead the error reported is simply “Script error.” This behavior can be overriden in some browsers using the crossorigin attribute on &lt;script&gt; and having the server send the appropriate CORS HTTP response headers. 解决方案在解决具体问题前，我们来看下window.onerror里面的第五个参数，error,这个信息。它看起来并不是那么特别。因为它里面包含几个例如：message, fileName, and lineNumber。这些事已经直接在前面参数提供给了你的。但是这个里面有一个非标准的属性，Error.prototype.stack。这个是追踪错误信息的关键所在。而且虽然不是标准的，但是是在主流浏览器中都支持的。这个error对象是会发生变化的，比如如果是语法错误，就会显示的是下面的SyntaxError,如果是未定义错误，会是ReferenceError。打印下error.stack。 这个里面的stack属性，就是可以追踪的所在，我们这里的错误比较简单，所以是只有一层。 如果是比较复杂的，打印出来可能是类似这样的。 Error: foobar at bar (Unknown script code:2:5) at foo (Unknown script code:6:5) at Anonymous function (Unknown script code:11:5) at Anonymous function (Unknown script code:10:2) at Anonymous function (Unknown script code:1:73) 这里具体的代码我在网上看到有人写了两种，我觉得两种都有自己的优缺点。学习了。 第一个来自知乎的水歌,链接为：水歌的回答。学习了。 12345678910111213141516171819202122232425262728(function (BOM, $) &#123; var Console_URL = $('head link[rel=\"console\"]').attr('href'); BOM.onerror = function (iMessage, iURL, iLine, iColumn, iError)&#123; BOM.setTimeout(function () &#123; var iData = &#123; message: iMessage, url: iURL, line: iLine, column: iColumn || (BOM.event &amp;&amp; BOM.event.errorCharacter) || 0 &#125;; if (iError &amp;&amp; iError.stack) iData.stack = (iError.stack || iError.stacktrace).toString(); if (Console_URL) &#123; if (iData.stack) $.post(Console_URL, iData); else $.get(Console_URL, iData); &#125; &#125;, 0); return true; &#125;;&#125;)(self, self.jQuery); 这段代码是只追踪了一层stack,并提交给了server。看到下面的post和get方法分别提交了吗？这个作者的回答是： 如果有详细的调用堆栈信息，就用 POST 这种理论上无限容量的方法发送，否则就只把 错误简介、文件名、出错行号 等信息用 GET 发送，以提高网络传输、服务器端解析的性能～ 第二种写法来自rapheal的博客，rapheal的这种写法，是追踪了3层错误信息。学习了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344window.onerror = function(msg,url,line,col,error)&#123; //没有URL不上报！上报也不知道错误 if (msg != \"Script error.\" &amp;&amp; !url)&#123; return true; &#125; //采用异步的方式 //我遇到过在window.onunload进行ajax的堵塞上报 //由于客户端强制关闭webview导致这次堵塞上报有Network Error //我猜测这里window.onerror的执行流在关闭前是必然执行的 //而离开文章之后的上报对于业务来说是可丢失的 //所以我把这里的执行流放到异步事件去执行 //脚本的异常数降低了10倍 setTimeout(function()&#123; var data = &#123;&#125;; //不一定所有浏览器都支持col参数 col = col || (window.event &amp;&amp; window.event.errorCharacter) || 0; data.url = url; data.line = line; data.col = col; if (!!error &amp;&amp; !!error.stack)&#123; //如果浏览器有堆栈信息 //直接使用 data.msg = error.stack.toString(); &#125;else if (!!arguments.callee)&#123; //尝试通过callee拿堆栈信息 var ext = []; var f = arguments.callee.caller, c = 3; //这里只拿三层堆栈信息 while (f &amp;&amp; (--c&gt;0)) &#123; ext.push(f.toString()); if (f === f.caller) &#123; break;//如果有环 &#125; f = f.caller; &#125; ext = ext.join(\",\"); data.msg = ext; &#125; //把data上报到后台！ &#125;,0); return true;&#125;; 涨知识顺便提到这里，最近被问到了一个问题，怎么测试网页前端性能。我以前有用过webpagetest这个网站在线测试过我的网站的性能。但是当时并没有认真的去分析到底里面有些什么使网站的加载变得慢，或者哪些是可以优化的地方。反思。最近我又看了看，这个真的是很好。仔细看的话，可以详细掌握网站加载过程中的瀑布流、性能得分、元素分布、视图分析等数据。其中比较直观的视图分析功能可以直接看到页面加载各个阶段的截屏。还可以看到：白屏时间和首屏时间，即用户多久能在页面中看到内容，以及多久首屏渲染完成(包含图片等元素加载完成)。这两个时间点直接决定了用户需要等待多久才能看到自己想看到的信息。谷歌优化建议中也提到减少非首屏使用的 css 及 JS,尽快让首屏呈现。回头我专门再研究下，再写一篇博客。 总结主要是学习了两种追踪错误的写法，一种是try,catch。一种是onerror。主要学习自下面这几篇文章。推荐阅读： client-javascript-reporting-window-onerror GlobalEventHandlers/onerror rapheal:javascript-error-monitor","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"由workerman-chat再认识HTML5的WebSocket","slug":"由workerman-chat再学习HTML5的WebSocket","date":"2016-04-15T03:45:34.000Z","updated":"2016-12-12T02:35:16.000Z","comments":true,"path":"2016/04/15/由workerman-chat再学习HTML5的WebSocket/","link":"","permalink":"http://sevencai.github.io/2016/04/15/由workerman-chat再学习HTML5的WebSocket/","excerpt":"","text":"先前已经看了几次把workerman-chat源码，对于里面的worker和gateway具体的实现现在还是不是很清楚，但是还是学到不少东西，比如关于WebSocket的一些知识，以及在这个框架中他是怎么实现WebSocket通信的。下面做一些整理,主要是WebSocket的一些基础知识，以及对于workerman-chat里关于WebSocket那一块的代码解读和记录。 WebSocket的出现背景我们知道Web应用的传统交互过程通常是： 1. 客户端通过浏览器发送一个请求 2. 服务器端收到请求，然后进行处理并把结果返回给客户端 3. 客户端浏览器将收到的信息呈现出来 这种机制对于信息变化不是特别频繁的应用尚可，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在当前业界移动互联网蓬勃发展的趋势下，高并发与用户实时响应是 Web 应用经常面临的问题，比如金融证券的实时信息，Web 导航应用中的地理位置获取，社交网络的实时消息推送等。 具体的来说： 监控系统：后台硬件热插拔、LED、温度、电压发生变化； 即时通信系统：其它用户登录、发送信息； 即时报价系统：后台数据库内容发生变化； 对于上面的情况，也是有传统的解决方案的。通常是采用实时通讯方案，常见的就有两种，第一种是轮询，第二种是基于Flash。 轮询：简单来说，就是客户端以固定的频率向服务器端发送请求，来保持客户端和服务器端的数据同步，但服务器端的数据可能没有更新，所以效率底，浪费带宽。 现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的有用数据可能只是一个很小的值，这样会占用很多的带宽。 基于Flash:AdobeFlash 通过自己的 Socket 实现完成数据交换，再利用 Flash 暴露出相应的接口为 JavaScript 调用，从而达到实时传输目的。此方式比轮询要高效，且因为 Flash 安装率高，应用场景比较广泛，但在移动互联网终端上 Flash 的支持并不好。IOS 系统中没有 Flash 的存在，在 Android 中虽然有 Flash 的支持，但实际的使用效果差强人意，且对移动设备的硬件配置要求较高。2012 年 Adobe 官方宣布不再支持 Android4.1+系统，宣告了 Flash 在移动终端上的死亡。 我们看到上面这两种方法都有各自的缺点，尤其在处理高并发和实时的需求时。我们需要一种能够很好的双向通信机制来保证数据的实时传输，这个时候我们的WebSocket就出现了。 WebSocket机制到这里先问几个问题：WebSocket到底是什么？是一个协议，是HTML5的一个新协议。它能用来干什么呢？用来实现浏览器与服务器的双全工通信。它建立于TCP之上，同HTTP一样利用TCP来传输数据，但是又和HTTP有很大的不同。不同在哪里呢？先看这个图： 上面是传统的HTTP请求响应和WebSocket的请求相应交互图，我们可以看到在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 所以上面的答案是：区别最大的地方在：双向通信，服务器和客户端都可以主动发送或者接收数据。就像打电话一样，两个人先建立连接，然后接通后，两个人想说啥就说啥，A可以和B主动说话，B也可以主动跟A说话。这里隐含着，也是要先建立连接的，也就是第一次还是需要三次握手的。建立连接成功后，就可以一直通信了。最开始还是需要一次TCP连接的。 相对于传统 HTTP 每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。 通过WebSocket的客户端和服务器端的报文WebSocket客户端连接报文 GET / HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg== Origin: http://localhost:8080 Sec-WebSocket-Version: 13 解释下：这里的upgrade表明这是一个WebSocket类型的请求。（为了更方便地部署新协议，HTTP/1.1 引入了 Upgrade 机制，它使得客户端和服务端之间可以借助已有的 HTTP 语法升级到其它协议）。“Sec-WebSocket-Key”是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept”应答，否则客户端会抛出“Error during WebSocket handshake”错误，并关闭连接。 WebSocket 服务端响应报文 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= “Sec-WebSocket-Accept”的值是服务端采用与客户端一致的密钥计算出来后返回客户端的,“HTTP/1.1 101 Switching Protocols”表示服务端接受 WebSocket 协议的客户端连接，经过这样的请求-响应处理后，客户端服务端的 WebSocket 连接握手成功, 后续就可以进行 TCP 通讯了。 WebSocket客户端APIWebSocket的实现分为客户端和服务器端两个部分，客户端通过浏览器发送WebSocket连接请求，服务端响应，然后TCP三次捂手，然后就在客户端和服务器端形成了一条HTTP长连接快速通道，两者后面就不要再次建立链接了。看看workerman-chat是分别怎么实现客户端和服务器端的。 先看下我们一般在客户端用Javascript如何建立WebSocket连接：首先，new一个WebSocket，然后在socket上监听WebSocket对象。主要通过onopen，onmessage，onclose和onerror四个事件实现对socket消息的异步响应。123456789101112131415161718var wsServer = 'ws://localhost:8888/Demo'; var websocket = new WebSocket(wsServer); websocket.onopen = function (evt) &#123; onOpen(evt) &#125;; websocket.onclose = function (evt) &#123; onClose(evt) &#125;; websocket.onmessage = function (evt) &#123; onMessage(evt) &#125;; websocket.onerror = function (evt) &#123; onError(evt) &#125;; function onOpen(evt) &#123; console.log(\"Connected to WebSocket server.\"); &#125; function onClose(evt) &#123; console.log(\"Disconnected\"); &#125; function onMessage(evt) &#123; console.log('Retrieved data from server: ' + evt.data); &#125; function onError(evt) &#123; console.log('Error occured: ' + evt.data); &#125; 看下workerman-chat的客户端代码首先是onload=&quot;connect();&quot;onload的时候调用connect创建连接socket。 它在connect里面创建了socket，并且设置了onopen，onmessage，onclose和onerror这几个事件。 123456789101112131415function connect() &#123; // 创建websocket ws = new WebSocket(\"ws://\"+document.domain+\":7272\"); // 当socket连接打开时，输入用户名 ws.onopen = onopen; // 当有消息时根据消息类型显示不同信息 ws.onmessage = onmessage; ws.onclose = function() &#123; console.log(\"连接关闭，定时重连\"); connect(); &#125;; ws.onerror = function() &#123; console.log(\"出现错误\"); &#125;;&#125; 再来看看它的onopen和onmessage函数。在这两个函数中，获取到客户端用户的client_name后，利用ws.send把数据（包括type类型，是login）发送给服务器。服务器那边收到消息会做相应的处理，然后把数据返回给客户端，这个时候调用onmessage,里面也包括了type的类型，将该用户设置入client_list,并且广播给所有的用户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 连接建立时发送登录信息function onopen()&#123; if(!name) &#123; show_prompt(); &#125; // 登录 var login_data = '&#123;\"type\":\"login\",\"client_name\":\"'+name.replace(/\"/g, '\\\\\"')+'\",\"room_id\":\"&lt;?php echo isset($_GET['room_id']) ? $_GET['room_id'] : 1?&gt;\"&#125;'; console.log(\"websocket握手成功，发送登录数据:\"+login_data); ws.send(login_data);&#125;// 服务端发来消息时function onmessage(e)&#123; console.log(e.data); var data = eval(\"(\"+e.data+\")\"); switch(data['type'])&#123; // 服务端ping客户端 case 'ping': ws.send('&#123;\"type\":\"pong\"&#125;'); break;; // 登录 更新用户列表 case 'login': //&#123;\"type\":\"login\",\"client_id\":xxx,\"client_name\":\"xxx\",\"client_list\":\"[...]\",\"time\":\"xxx\"&#125; say(data['client_id'], data['client_name'], data['client_name']+' 加入了聊天室', data['time']); if(data['client_list']) &#123; client_list = data['client_list']; &#125; else &#123; client_list[data['client_id']] = data['client_name']; &#125; flush_client_list(); console.log(data['client_name']+\"登录成功\"); break; // 发言 case 'say': //&#123;\"type\":\"say\",\"from_client_id\":xxx,\"to_client_id\":\"all/client_id\",\"content\":\"xxx\",\"time\":\"xxx\"&#125; say(data['from_client_id'], data['from_client_name'], data['content'], data['time']); break; // 用户退出 更新用户列表 case 'logout': //&#123;\"type\":\"logout\",\"client_id\":xxx,\"time\":\"xxx\"&#125; say(data['from_client_id'], data['from_client_name'], data['from_client_name']+' 退出了', data['time']); delete client_list[data['from_client_id']]; flush_client_list(); &#125;&#125; 当用户要提交对话的时候，我们获取到表单里的内容，将数据同样利用ws.send()发送给服务器，服务器同样做相应的处理，并将数据返回给客户端。然后再调用客户端的onmessage,这个时候的类型很明显就不是login了，而是say。 1234567891011121314//提交数据function onSubmit() &#123; var input = document.getElementById(\"textarea\"); var to_client_id = $(\"#client_list option:selected\").attr(\"value\"); var to_client_name = $(\"#client_list option:selected\").text(); ws.send('&#123;\"type\":\"say\",\"to_client_id\":\"'+to_client_id+'\",\"to_client_name\":\"'+to_client_name+'\",\"content\":\"'+input.value.replace(/\"/g, '\\\\\"').replace(/\\n/g,'\\\\n').replace(/\\r/g, '\\\\r')+'\"&#125;'); input.value = \"\"; input.focus();&#125;// 发言就是把数据append进入对应的回话区function say(from_client_id, from_client_name, content, time)&#123; $(\"#dialog\").append('&lt;div class=\"speech_item\"&gt;&lt;img src=\"http://lorempixel.com/38/38/?'+from_client_id+'\" class=\"user_icon\" /&gt; '+from_client_name+' &lt;br&gt; '+time+'&lt;div style=\"clear:both;\"&gt;&lt;/div&gt;&lt;p class=\"triangle-isosceles top\"&gt;'+content+'&lt;/p&gt; &lt;/div&gt;');&#125; 看下workerman-chat的服务器端代码这里的代码很少，主要是定义了Event类的两个方法，一个是onMessage方法，这里根据客户端传过来的type来返回不同的数据。比如如果是login就加入到client_list中去，然后设置session什么的。这里他有调用Gateway里面的一些方法如：Gateway::getClientInfoByGroup()等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class Event&#123; /** * 有消息时 * @param int $client_id * @param mixed $message */ public static function onMessage($client_id, $message) &#123; // debug echo \"client:&#123;$_SERVER['REMOTE_ADDR']&#125;:&#123;$_SERVER['REMOTE_PORT']&#125; gateway:&#123;$_SERVER['GATEWAY_ADDR']&#125;:&#123;$_SERVER['GATEWAY_PORT']&#125; client_id:$client_id session:\".json_encode($_SESSION).\" onMessage:\".$message.\"\\n\"; // 客户端传递的是json数据 $message_data = json_decode($message, true); if(!$message_data) &#123; return ; &#125; // 根据类型执行不同的业务 switch($message_data['type']) &#123; // 客户端回应服务端的心跳 case 'pong': return; // 客户端登录 message格式: &#123;type:login, name:xx, room_id:1&#125; ，添加到客户端，广播给所有客户端xx进入聊天室 case 'login': // 判断是否有房间号 if(!isset($message_data['room_id'])) &#123; throw new \\Exception(\"\\$message_data['room_id'] not set. client_ip:&#123;$_SERVER['REMOTE_ADDR']&#125; \\$message:$message\"); &#125; // 把房间号昵称放到session中 $room_id = $message_data['room_id']; $client_name = htmlspecialchars($message_data['client_name']); $_SESSION['room_id'] = $room_id; $_SESSION['client_name'] = $client_name; // 获取房间内所有用户列表 $clients_list = Gateway::getClientInfoByGroup($room_id); foreach($clients_list as $tmp_client_id=&gt;$item) &#123; $clients_list[$tmp_client_id] = $item['client_name']; &#125; $clients_list[$client_id] = $client_name; // 转播给当前房间的所有客户端，xx进入聊天室 message &#123;type:login, client_id:xx, name:xx&#125; $new_message = array('type'=&gt;$message_data['type'], 'client_id'=&gt;$client_id, 'client_name'=&gt;htmlspecialchars($client_name), 'time'=&gt;date('Y-m-d H:i:s')); Gateway::sendToGroup($room_id, json_encode($new_message)); Gateway::joinGroup($client_id, $room_id); // 给当前用户发送用户列表 $new_message['client_list'] = $clients_list; Gateway::sendToCurrentClient(json_encode($new_message)); return; // 客户端发言 message: &#123;type:say, to_client_id:xx, content:xx&#125; case 'say': // 非法请求 if(!isset($_SESSION['room_id'])) &#123; throw new \\Exception(\"\\$_SESSION['room_id'] not set. client_ip:&#123;$_SERVER['REMOTE_ADDR']&#125;\"); &#125; $room_id = $_SESSION['room_id']; $client_name = $_SESSION['client_name']; // 私聊 if($message_data['to_client_id'] != 'all') &#123; $new_message = array( 'type'=&gt;'say', 'from_client_id'=&gt;$client_id, 'from_client_name' =&gt;$client_name, 'to_client_id'=&gt;$message_data['to_client_id'], 'content'=&gt;\"&lt;b&gt;对你说: &lt;/b&gt;\".nl2br(htmlspecialchars($message_data['content'])), 'time'=&gt;date('Y-m-d H:i:s'), ); Gateway::sendToClient($message_data['to_client_id'], json_encode($new_message)); $new_message['content'] = \"&lt;b&gt;你对\".htmlspecialchars($message_data['to_client_name']).\"说: &lt;/b&gt;\".nl2br(htmlspecialchars($message_data['content'])); return Gateway::sendToCurrentClient(json_encode($new_message)); &#125; $new_message = array( 'type'=&gt;'say', 'from_client_id'=&gt;$client_id, 'from_client_name' =&gt;$client_name, 'to_client_id'=&gt;'all', 'content'=&gt;nl2br(htmlspecialchars($message_data['content'])), 'time'=&gt;date('Y-m-d H:i:s'), ); return Gateway::sendToGroup($room_id ,json_encode($new_message)); &#125; &#125; /** * 当客户端断开连接时 * @param integer $client_id 客户端id */ public static function onClose($client_id) &#123; // debug echo \"client:&#123;$_SERVER['REMOTE_ADDR']&#125;:&#123;$_SERVER['REMOTE_PORT']&#125; gateway:&#123;$_SERVER['GATEWAY_ADDR']&#125;:&#123;$_SERVER['GATEWAY_PORT']&#125; client_id:$client_id onClose:''\\n\"; // 从房间的客户端列表中删除 if(isset($_SESSION['room_id'])) &#123; $room_id = $_SESSION['room_id']; $new_message = array('type'=&gt;'logout', 'from_client_id'=&gt;$client_id, 'from_client_name'=&gt;$_SESSION['client_name'], 'time'=&gt;date('Y-m-d H:i:s')); Gateway::sendToGroup($room_id, json_encode($new_message)); &#125; &#125; &#125; 涨知识-建立socket连接建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 我们这里还要区分一个概念就是http和socket的区别。这两个千万不能混为一谈，Http（无状态）是超文本传输协议，是协议，是基于TCP/IP协议基础上的应用层协议。Socket不是协议，是一个调用接口，Socket是基于TCP/IP的协议封装。Socket是长连接，http只能走tcp,sockett不仅能走tcp还能走udp。总的来说：Socket是应用层与TCP/IP协议族通信的中间软件抽象层，一组接口，把复杂的TCP/IP协议族隐藏在Socket接口后面。 总结主要是总结了下WebSocket,然后以workerman-chat的例子为讲解，看下别人的代码怎么写的这么好。WebSocket 的优点上面我们看到了有很多，但是现在用它是也有风险，因为它正处于还不是非常成熟的阶段。另外的一个风险就是微软的 IE 作为占市场份额最大的浏览器，和其他的主流浏览器相比，对 HTML5 的支持是比较差的，这是我们在构建企业级的 Web 应用的时候必须要考虑的一个问题。现在它这个是并没有和数据库打交道的。但是我是要从数据库中读出相应的群组，然后可以群组对话，或者专一对话。并且不是只有在线才能发消息。这里workerman-chat也没有把消息存到数据库中去，这肯定对我的项目来说是不行的，我需要建表，然后把对应的会话存入数据库。它是有一些DB类的，可以用这个。回头改完，再写一篇文章。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/tags/WEB开发/"}]},{"title":"PHPExcel简单列表导出","slug":"PHPExcel简单列表导出","date":"2016-04-11T14:30:23.000Z","updated":"2016-12-12T02:30:42.000Z","comments":true,"path":"2016/04/11/PHPExcel简单列表导出/","link":"","permalink":"http://sevencai.github.io/2016/04/11/PHPExcel简单列表导出/","excerpt":"","text":"PHPExcel是用来操作Office Excel 文档的一个PHP类库，它基于微软的OpenXML标准和PHP语言。可以使用它来读取、写入不同格式的电子表格。下面主要介绍的是：PHPExcel简单列表导出。 生成Excel表的思路对照首先我们需要到官网上，下载PHPExcel的包，包里我们把classes单独提取出来，classes里面有一个文件使PHPExcel.php这个是我们主要用到的，在下面的例子中，我把classes文件夹重命名为了PHPExcel。下面这张图对比了我们平常创建一个excel需要做什么和我们用代码创建一个excel的相同的地方，我们应该看到他们非常相似： 生成Excel表基本代码123456789101112131415161718192021222324&lt;?php //获取当前路径 $dir = dirname(__FILE__); //包含PHPExcel文件 require_once(\"./PHPExcel/PHPExcel.php\"); //创建了一个表格 $phpExcelObj = new PHPExcel(); //获取当前活动sheet $activeSheet = $phpExcelObj-&gt;getActiveSheet(); //var_dump($activeSheet); $activeSheet-&gt;setTitle(\"demo\"); //给当前的表格填充数据 $activeSheet-&gt;setCellValue(\"A1\",\"姓名\")-&gt;setCellValue(\"B1\",\"分数\"); $activeSheet-&gt;setCellValue(\"A2\",\"Seven\")-&gt;setCellValue(\"B2\",\"75\"); //按照指定格式生成excel文件 $objWriter = PHPExcel_IOFactory::createWriter($phpExcelObj,\"Excel2007\"); //保存文档 $objWriter-&gt;save($dir.\"/demo.xlsx\");?&gt; 就可以在当前目录下生成一个demo.xlsx,里面的内容： 先前可以试着打印下$phpExcelObj对象，如果看到下面的可以说明引入成功： 还有下面这样的一种方式，以数组来填充：123456789101112131415161718&lt;?php $dir = dirname(__FILE__); //string 'D:\\wamp\\wamp\\www\\phpexcel' (length=25) require_once(\"./PHPExcel/PHPExcel.php\"); $phpExcelObj = new PHPExcel(); //创建了一个表格 $activeSheet = $phpExcelObj-&gt;getActiveSheet(); //var_dump($activeSheet);//获取当前活动sheet $activeSheet-&gt;setTitle(\"demo\"); //给当前的表格填充数据 $array = array( array(), array(\"\",\"姓名\",\"分数\"), array(\"\",\"李四\",\"60\"), array(\"\",\"王五\",\"90\") ); $activeSheet-&gt;fromArray($array); $objWriter = PHPExcel_IOFactory::createWriter($phpExcelObj,\"Excel2007\"); $objWriter-&gt;save($dir.\"/demo1.xlsx\");?&gt; 这种方法肯定和上面的比有优点，比如设置起来比较方便，但是也有不好的地方，比较耗内存。 把数据库的数据录入excel中刚刚我们的是直接手动录入，这种情况在项目中是使用比较少的，下面这种我们把数据从数据库录入excel中是最常见的。比如我们在生成订单表的时候，生成excel对卖家来说会是经常需要的。 比如我们在数据库中有这样一张表： 我们需要按照年级把成绩分出来，并得到下面的结果,如果我们手动录入肯定会很麻烦，看看下面的PHPExcel方法： 首先我们有一个数据库配置文件：config.php,在这里面要设置数据库，字符集等信息。123456789&lt;?php $config = array( &apos;host&apos;=&gt;&apos;127.0.0.1&apos;, &apos;username&apos;=&gt;&apos;root&apos;, &apos;password&apos;=&gt;&apos;****&apos;, &apos;database&apos;=&gt;&apos;test&apos;, &apos;charset&apos;=&gt;&apos;utf8&apos; );?&gt; 然后我们需要一个db类，用于我们从数据库取出数据，我们命名为db.php123456789101112131415161718192021222324252627&lt;?php require_once('./config.php'); class db&#123; public $conn = null; public function __construct($config)&#123; $this-&gt;conn = mysql_connect($config['host'],$config['username'],$config['password']) or die(mysql_error()); mysql_select_db($config['database']) or die(mysql_error()); mysql_query(\"set names \".$config['charset']) or die(mysql_error()); &#125; public function getResult($sql)&#123; $res = mysql_query($sql); $arr = array(); while($row = mysql_fetch_assoc($res))&#123; $arr[] = $row; &#125; return $arr; &#125; public function getDataByGrade($grade)&#123; $sql = \"select * from student where grade = \".$grade.\" order by score desc\"; $res = self::getResult($sql); return $res; &#125; &#125;?&gt; 下面是我们的主文件，我们把上面的文件都包含进来，这里注意因为我们在db里已经require了config.php,所以这里不用再包含config.php了，或者我们用require_once也可以。123456789101112131415161718192021222324252627&lt;?php $dir = dirname(__FILE__); require $dir.\"/db.php\"; require $dir.\"/PHPExcel/PHPExcel.php\"; $db = new db($config); $objPHPExcel = new PHPExcel(); for ($i=1; $i &lt;= 3; $i++) &#123; if($i&gt;1)&#123; $objPHPExcel-&gt;createSheet(); &#125; $objPHPExcel-&gt;setActiveSheetIndex($i-1); $objSheet = $objPHPExcel-&gt;getActiveSheet(); $objSheet-&gt;setTitle($i.\"年级\"); $data = $db-&gt;getDataByGrade($i); $objSheet-&gt;setCellValue(\"A1\",\"姓名\")-&gt;setCellValue(\"B1\",\"年级\")-&gt;setCellValue(\"C1\",\"成绩\"); $j=2; foreach ($data as $key =&gt; $value) &#123; $objSheet-&gt;setCellValue(\"A\".$j,$value['name'])-&gt;setCellValue(\"B\".$j,$value['grade'])-&gt;setCellValue(\"C\".$j,$value['name']); $j++; &#125; &#125; $objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel,'Excel5'); $objWriter-&gt;save($dir.\"/export_1.xls\");?&gt; 主要的思路就是我们按照先前我们的步骤新建表，创建sheet,这里不同的是，我们要把三个年级的放到不同的sheet里，所以不能只create一个sheet,要根据grade有多少个循环创建，并且把相应的数据放进去。 将excel输出到浏览器我们也可以吧excel保存到浏览器，这个时候我们只用改动一点代码就行了，比如这里我们设置header头，告诉浏览器生成的类型。注意这里save方法发生了变化的。123456789101112131415161718192021222324252627282930313233343536373839&lt;?php $dir = dirname(__FILE__); require $dir.\"/db.php\"; require $dir.\"/PHPExcel/PHPExcel.php\"; $db = new db($config); $objPHPExcel = new PHPExcel(); for ($i=1; $i &lt;= 3; $i++) &#123; if($i&gt;1)&#123; $objPHPExcel-&gt;createSheet(); &#125; $objPHPExcel-&gt;setActiveSheetIndex($i-1); $objSheet = $objPHPExcel-&gt;getActiveSheet(); $objSheet-&gt;setTitle($i.\"年级\"); $data = $db-&gt;getDataByGrade($i); $objSheet-&gt;setCellValue(\"A1\",\"姓名\")-&gt;setCellValue(\"B1\",\"年级\")-&gt;setCellValue(\"C1\",\"成绩\"); $j=2; foreach ($data as $key =&gt; $value) &#123; $objSheet-&gt;setCellValue(\"A\".$j,$value['name'])-&gt;setCellValue(\"B\".$j,$value['grade'])-&gt;setCellValue(\"C\".$j,$value['name']); $j++; &#125; &#125; $objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel,'Excel5'); //$objWriter-&gt;save($dir.\"/export_1.xls\"); browser_export(\"Excel5\",'browser_export01.xls'); $objWriter-&gt;save(\"php://output\"); function browser_export($type,$filename)&#123; if($type==\"Excel5\")&#123; header('Content-Type: application/vnd.ms-excel');//告诉浏览器将要输出excel03文件 &#125;else&#123; header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');//告诉浏览器数据excel07文件 &#125; header('Content-Disposition: attachment;filename=\"'.$filename.'\"');//告诉浏览器将输出文件的名称 header('Cache-Control: max-age=0');//禁止缓存 &#125;?&gt; 如果不告诉浏览器名称的话，就会把当前文本的名称当成输出excel的名称。header就是告诉浏览器文件类型。必须有。 最后的结果，就是我一刷新就出来了下载这个： 总结这个还有很多方法我没有写到，比如我们怎么样设置居中，怎么样添加线性表，怎么样导入Excel表，这个我会回头有时间再写一篇博客的。还有很多设置样式的，我们其实要做的就是调用它的接口就行。因为这样的东西我觉得不是经常用就会忘，所以做一次大概知道是什么思路和样子就行了，以后要用的时候再查一查文档，看看以前做的例子，应该能很快就想起来的，那些函数的调用也没有太大的必要记住。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://sevencai.github.io/tags/PHP/"}]},{"title":"Workerman-chat学习之路一（基本概念了解）","slug":"Workerman-chat学习之路一（基本概念了解）","date":"2016-04-10T14:46:05.000Z","updated":"2016-12-12T03:01:22.000Z","comments":true,"path":"2016/04/10/Workerman-chat学习之路一（基本概念了解）/","link":"","permalink":"http://sevencai.github.io/2016/04/10/Workerman-chat学习之路一（基本概念了解）/","excerpt":"","text":"因为项目需求，要学习workerman框架，下面是我的笔记和理解。主要是用的它的workerman-chat。workerman-chat基于GatewayWorker,GatewayWorker基于workerman。感觉写这个人好厉害啊。纯PHP写的。 先看看几个之间的关系下面是具体的解释。官网上有，此处做记录，并附有图片方便理解。 什么是workerman? Workerman是一款纯PHP开发的开源高性能的PHP socket 服务器框架。被广泛的用于手机app、手游服务端、网络游戏服务器、聊天室服务器、硬件通讯服务器、智能家居、车联网、物联网等领域的开发。 支持TCP长连接，支持Websocket、HTTP等协议，支持自定义协议。基于workerman开发者可以更专注于业务逻辑开发，不必再为PHP Socket底层开发而烦恼。 纯PHP开发，多进程支持，支持hhvm 支持TCP/UDP，单机可支持数百万以上TCP长连接 支持分布式，集群能支持数百万甚至更高的并发TCP连接 支持libevent事件触发网络库 支持热更新及服务器平滑重启 支持守护进程化和统计监控模块 什么是GatewayWorkerGatewayWorker基于Workerman开发的一个项目，用于快速开发长连接应用，例如移动通讯、物联网、游戏服务端、聊天室等等。 GatewayWorker进程模型GatewayWorker分为Gateway进程和Worker进程和register注册服务进程，Gateway进程维持着客户端的连接并转发连接上发来的数据给Worker进程处理；Worker进程只负责处理转发来的客户端数据，并通过Gateway进程推送数据给任意客户端。register注册服务进程负责注册通知Gateway进程和Worker进程之间的通讯地址。主要是要知道Gateway进程和Worker进程负责的东西，Gateway只是负责网络IO,并且是非阻塞的，Worker只负责处理业务数据这些。其通信协议是开放的，可定制的，因此我们是可以设置使用任何协议来完成与客户端的通信的。我们再开发客户端的时候，就可以根据我们设置的这个协议来完成与服务器的通信。 workerman-chat聊天室框架这个是我主要要用到的其中的一个实现框架，它基于workerman作为服务器容器，使用PHP开发，基于Websocket,采用gateway workers进程模型。 在这个过程中gateway只负责IO,全异步非阻塞。每个gateway进程可以与上千万客户端连接。workers是同步模型，并提供了开发者基本的接口 onConnect、onMessage、onClose、sendToClient、sendToAll等方法。 开发者只要在onConnect、onMessage、onClose三个方法中添加上自己的业务逻辑即可，开发维护非常简单。 由于采用的是gateway workers 进程模型，gateway和workers之间是无状态的，gateway和workers可以分别部署在不同的物理机上，所以扩容和升级都非常方便。 workerman-chat也非常适合游戏后台开发。 明天写具体的用法和框架结构。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://sevencai.github.io/tags/PHP/"}]},{"title":"学习HTML5 API （pushState/replaceState）","slug":"学习HTML5-API-（pushState-replaceState）","date":"2016-04-02T13:20:26.000Z","updated":"2016-12-12T03:01:54.000Z","comments":true,"path":"2016/04/02/学习HTML5-API-（pushState-replaceState）/","link":"","permalink":"http://sevencai.github.io/2016/04/02/学习HTML5-API-（pushState-replaceState）/","excerpt":"","text":"ajax大家都很熟悉了，我们知道ajax会有一些弊端，H5出来了两个新的API叫做pushState和replaceState，这两个可以很好的解决ajax不能历史返回的问题。先推荐一个博客，推荐的原因是要知其所以然，知道历史才能够更好的理解。下面是我的整理，由于是自己的整理，所以很多无关这两个API的，可以直接忽略，跳过直接看后面重点部分和demo。。 前言-ajax与传统web应用的比较简单来说：第一：是局部刷新，传统web应用要请求并重新读取一个整个页面。第二：仅仅向服务器发送并取回必要的数据，不会像传统的web应用一样浪费很多带宽。第三：减少了数据交换，减少了响应时间,响应的更快。 用户体验好，用户体验好，用户体验好 传统的Web应用交互由用户触发一个HTTP请求到服务器,服务器对其进行处理后再返回一个新的HTHL页到客户端, 每当服务器处理客户端提交的请求时,客户都只能空闲等待,并且哪怕只是一次很小的交互、只需从服务器端得到很简单的一个数据,都要返回一个完整的HTML页,而用户每次都要浪费时间和带宽去重新读取整个页面。这个做法浪费了许多带宽，由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。与此不同，AJAX应用可以仅向服务器发送并取回必需的数据，它使用SOAP或其它一些基于XML的Web Service接口，并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减少，结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成，所以Web服务器的处理时间也减少了。 ajax的工作原理Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 其实Ajax主要就是通过XMLHttpRequest对象来向服务器发送异步请求，然后从服务器端获得相应的数据，利用相应的数据来局部更新相应的页面。 ajax的缺点和优点咱们先讲优点： 无刷新更新数据避免修改了那些不需要改变的信息，从而减少等待时间，用户体验很好。 异步通信中途不会阻止用户操作，具有更加迅速的响应能力。优化了b/s的沟通。 前后端负载均衡，后面的ajax的工作原理会讲到，ajax可以吧以前必须要服务器承担的工作留给客户端。利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 基于标准，被支持 数据与呈现分离有利于分工合作。减少非技术人员对web应用程序错误。 再来看看缺点： ajax破坏了浏览器本身的机制，不能够有back和history的功能。 ajax的安全问题，这使得开发者在不经意间会暴露更多的数据和服务器逻辑。ajax也难以避免一些一直的安全弱点，sql注入，xss等等。 破坏程序的异常处理机制（这一点在怎么理解？） 违背URL和资源定位的初衷，例如，我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 对搜索引擎支持较弱。对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。 还有不容易调试那些问题。 重点：怎么解决不能有back和history这一问题？先来看看history对象：123456window.history.back();window.history.forward();window.history.go(-1);window.history.go(2);//通过检查浏览器历史记录的length属性来找到历史记录堆栈中的页面总数var num = window.history.length; H5引入了history.pushState(),history.replaceState()这两个API，他们允许添加和修改history实体。需要和window.onpopstate事件一起工作。这两个方法用来修改referrer，可以被用在修改状态后而为XMLHttpRequest对象创建的http header中。 pushState就是向history添加当前页面的记录，replaceState的参数和用法和pushState相同，区别在于replaceState是用于修改当前页面在history中的记录。这个我们后面也会在例子中用到。 其实pushState就是一个往堆栈添加一条历史记录。可以形象的理解成push。 pushState(data,title,[,url])：data为一个对象或者为null,它会在触发window的popstate事件时，作为参数的state属性传递过去，title为页面的标题，现在的浏览器忽略掉了这个参数，所以写啥都没用，url为页面的URL，如果不写的话，就是当前页了。 replaceState(data,title,[,url])：参数时相同的，这种更改不会访问该URL。也就是不会刷新。会让用户看到的url发生变化，如果我们需要访问该URL，还要去手动的触发。 replaceState不会在window.history里新增历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的某些操作，而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。 PJAX刚刚我们已经说到了那两个API,我们的PJAX就是基于上面新特性来的。PJAX是别人开发的一个项目，地址是：https://github.com/defunkt/jquery-pjax。 它不仅仅支持了局部刷新这一特点，而且在刷新页面的同时，浏览器地址栏上面的地址是会更改的，用浏览器回退功能也能够回退回去，正常我们用ajax是实现不了的。。 PJAX的基本思路是，当用户点击一个链接，通过ajax更新页面变化的部分，然后使用HTML5的pushState修改浏览器的URL地址，这样有效地避免了整个页面的重新加载。如果浏览器不支持history的两个新API或者JS被禁用了，那这个链接就只能跳转并重新刷新整个页面了。和传统的ajax设计稍微不同，ajax通常是从后台获取JSON数据，然后由前端解析渲染，而PJAX请求的是一个在服务器上生成好的HTML碎片 看看如果我们自己写是怎么样利用这两个API的。 先来看一个完整的例子demo的地址我放在了http://cailidan.cn/web/demo/testajax这里。一个很简单的php文件，通过接收不同的id，并且返回不同的数据。显示到textarea上。 12345678910111213141516&lt;?php $id = isset($_POST['id'])?$_POST['id']:1; switch($id)&#123; case 1: echo \"这是一个ajax请求---page1\"; break; case 2: echo \"这是一个ajax请求---page2\"; break; case 3: echo \"这是一个ajax请求---page3\"; break; default: echo \"default ajax\"; &#125;?&gt; 下面的例子是这样一个过程: 当我们访问index.html的时候，会自动显示成http://localhost:801/testajax/index.html?page=1,原因就是我们使用了用history.replaceState更改当前的浏览器历史;并且在textarea部分显示这是一个ajax请求---page1 当我们点击每一个li的时候，对应的textarea会发生变化，这没有什么新奇的，但当我们看浏览器的URL，发现对应的url也会发生变化，如http://localhost:801/testajax/index.html?page=2这个是我们利用replaceState来做到的。 然后我们试一下点击回退，发现是可以回到上一级哒。是不是很棒呢？ 我们的思路是，先给每个li绑定一个事件，然后当我们点击这个li的时候，调用ajax，并把当前的url拼凑后pushState。当我们首次访问的时候query=undefined,我们获取到undefined后，就默认是第一个，此时我们利用replaceState改变状态栏的信息。若状态栏的query有值。，则判断query对应的li是哪个。如果找到了该li，触发其click事件，如果没有的话，证明query传参错误。然后默认去触发第一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;测试pjax&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"list\"&gt; &lt;li&gt;&lt;a href=\"test.php?page=1\" data-id=\"1\"&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"test.php?page=2\" data-id=\"2\"&gt;page2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"test.php?page=3\" data-id=\"3\"&gt;page3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"test.php?page=4\" data-id=\"4\"&gt;page4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;textarea name=\"\" id=\"textarea\" cols=\"30\" rows=\"10\"&gt; &lt;/textarea&gt; &lt;script src=\"./jquery-1.12.0.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function()&#123; var list = $(\"#list a\").bind(\"click\",function(e)&#123; var id = $(e.target).attr('href').split('?')[1].split(\"=\")[1]; var query = this.href.split(\"?\")[1]; //调用ajax,返回相应的值入textarea if(history.pushState &amp;&amp; query)&#123; $.ajax(&#123; type:\"POST\", data:&#123;id:id&#125;, url:\"test.php\", success:function(data)&#123; $(\"#textarea\").html(data); &#125; &#125;) var title = \"测试page\"+$(this).text(); document.title = title; if(e)&#123; history.pushState(&#123;title:title&#125;,title,location.href.split('?')[0]+\"?\"+query); &#125; &#125; return false; &#125;); var trigger = function(target)&#123; var query = location.href.split(\"?\")[1]; var target = target || null; //开始时query为空，就让target为第一个li选项 if(typeof query == \"undefined\")&#123; target = list[0]; //把url状态栏中的内容显示为如http://localhost:801/testajax/index.html?page=1 history.replaceState(null, document.title, location.href.split(\"#\")[0] + \"?\" + target.href.split(\"?\")[1]) + location.hash; trigger(target); &#125;else&#123; //如果已经有query了，获取里面的query值找到对应的li,并设置target为相应的li list.each(function()&#123; if(target === null &amp;&amp; this.href.split(\"?\")[1] === query)&#123; target = this; &#125; &#125;); //如果上面target没有赋值，也就是说query找不到对应的li，证明query不存在相应的记录 //此时就设置为如http://localhost:801/testajax/index.html //如果target有值，则触发click事件，调用ajax. if(!target)&#123; history.replaceState(null,document.title,location.href.split('?')[0]); trigger(); &#125;else&#123; $(target).trigger(\"click\"); &#125; &#125; &#125; if(history.pushState)&#123; trigger(); //每次浏览器前进或者后退的时候触发 $(window).bind(\"popstate\",function()&#123; trigger(); &#125;); &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 顺便记录几个XMLHttpRequest的属性onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据。 总结感谢osChina和张鑫旭的这篇文章。了解了H5新的API,也大致的知道是怎么用的了。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"如果想用script做自己的网名？","slug":"如果想用script做自己的网名？","date":"2016-03-31T14:46:54.000Z","updated":"2016-12-12T03:01:52.000Z","comments":true,"path":"2016/03/31/如果想用script做自己的网名？/","link":"","permalink":"http://sevencai.github.io/2016/03/31/如果想用script做自己的网名？/","excerpt":"","text":"思考这样一个题目，有一个人他想注册一个网名叫做&lt;script&gt;alert(1);&lt;/script&gt;。怎么样实现呢？一般情况下，我们在注册登陆或者评论或与用户有数据交互的时候，都是会把这些给过滤掉的，当我们不允许用户这么做的时候，是为了可以防止部分xss。但如果网站允许这么叫，那怎么实现呢？也就是说我们既要输出相应的标签，又要防止xss。。 Web是一个集众多不同环境同时开发的平台，我们经常要夸平台传输数据。比如客户端与服务器的通信就是在客户端和服务器这两个不同的环境上传输数据。如果我们传输的数据没经过过滤就有可能在各种环节被注入攻击，所以在传输过程中的字符转义是很重要的。 先看看怎么解决这个问题方法一-自定义转义后输出1234567891011121314&lt;div id=\"box2\"&gt; &lt;pre&gt; &lt;a href=\"\"&gt;baidu&lt;/a&gt; &lt;/pre&gt; &lt;pre&gt; &amp;nbsp;&amp;lt;a&amp;gt;alert('1');&lt;/a&gt; afdfs adsfas fdsfafdasf dafdsS &lt;/pre&gt; &amp;nbsp;&amp;lt;a&amp;gt;alert('1');&lt;/a&gt; afdfs ttttt &lt;/div&gt; 大家猜猜上面这会输出一种什么样的效果：正常情况下，我们所有的html标签如果直接输出的话，是不可能显示出来的，那些标签都是经过浏览器解析然后显示到页面上的，所以我们要通过转义这样一种方法来实现。 也就是说比如小明要注册一个网站，他注册的是&lt;script&gt;alert(1);&lt;/script&gt;这样一个名字，我们可以不用对script标签进行完全过滤，我们只需要进行一下转义，把里面的&lt;&gt;这种全部转义成实体。并存到数据库，当我们要显示小明的网名的时候，我们输出到浏览器的不是script标签，而是被转义了以后的，这样也就不会造成安全问题。 但是这样也可能存的问题：【数据传输最普遍的形式就是字符串传输，这也是最容易被注入的。要保证在解析时候不被注入，字符的转义就很有必要！做字符转义除了可以避开注入外还可以解决双字节字符的编码问题。】但是转义之后数据的量会变大，所以在传输的带宽方面会有一定的开销。 方法二-方法优化利用白名单刚刚我们提到了，如果我们把所有的都转义后数据量会变大，所以很占据带宽，所以虑数字、字母，空格，这些可能会被大量使用，因此把他们加入白名单，在白名单之外的字符一律转义。想想为啥叫做白名单，黑名单与之对应。 再看看一般我们是怎么转义过滤的删除所有的HTML TAG1234function rmHtmlTab(tab) &#123; return tab.replace(/&lt;\\/?[^&gt;]*&gt;/g,'');//删除所有HTML标签&#125;console.log(rmHtmlTab(\"&lt;script&gt;alert('1');&lt;/script&gt;\")); 输出：alert(&#39;1&#39;);,稍微解释下这个正则的意思：匹配&lt;&gt;或者&lt;/&gt;，中间啥都可以，但是不能有&gt;。这样就可以把所有的这样的标签全部过滤掉，只输出文本。 不删除所有的TAG,全部转义1234567function escape(str)&#123; return str.replace(/[&lt;&gt;&amp;\"]/g,function(c)&#123; var obj = &#123;'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','\"':'&amp;quot;'&#125;; return obj[c]; &#125;);&#125;console.log(escape(\"&lt;a&gt;alert('1');&lt;/a&gt;\")); lt;a&amp;gt;alert(&#39;1&#39;);&amp;lt;/a&amp;gt;最后转义成了你想要的样子。如果是要将转义符换成普通字符，就把obj里的属性和值差不多换一下就行啦。如下：123456789function entityEscape(str)&#123; var obj = &#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'\"'&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123; console.log(all); return obj[t]; &#125;);&#125; console.log(entityEscape(\"&amp;nbsp;&amp;lt;a&amp;gt;alert('1');&lt;/a&gt;\")); 最后结果为： 这里顺便总结下replace的回调函数：当replace方法执行的时候每次都会调用该函数，返回值作为替换的新值。 1. 第一个参数为每次匹配的全文本（$&amp;）。 2. 中间参数为子表达式匹配字符串，个数不限.( $i (i:1-99)) 3. 倒数第二个参数为匹配文本字符串的匹配下标位置。 4. 最后一个参数表示字符串本身。 1234567function entityEscape(str)&#123; var obj = &#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'\"'&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(a,b,d,c)&#123; console.log(a+\" \"+d+\" \"+b+\" \"+c); //return obj[c]; &#125;);&#125; 如上就会输出这样的格式：&amp;nbsp; 0 nbsp &amp;nbsp;&amp;lt;a&amp;gt;alert(&#39;1&#39;);&lt;/a&gt; 再看个小例子这个例子跟我们的问题关系其实并不是很大，只是我在做上面的总结时，发现了下列问题：1234&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div id=\"box1\"&gt;&lt;/div&gt; 大家想想下面两种不同的情况会输出什么呢？1234567891011121314//情形一var box = document.getElementById(\"box1\");box.innerHTML = \"&lt;script&gt;alert('a');&lt;/script&gt;\";//情形二var box = document.getElementById(\"box1\");box.innerHTML = \"&amp;lt;script&amp;gt;alert('a');&amp;lt/script&amp;gt\";//情形三var script = document.createElement('script');var text = document.createTextNode('alert(1)');script.appendChild(text);var box1 = document.getElementById('box1');box1.appendChild(script);//情形四console.log(escape(\"&amp;nbsp;&amp;lt;a&amp;gt;alert('1');&lt;/a&gt;\")); 答案是第一种情况不会输出alert(a),第二种情况会输出alert(a),第三种情况会输出alert(1)。想想这是为啥呢？ 总结以前虽然知道转义这种东西，但是实际项目里用过的，都是直接把所有的标签给过滤了，也就没有实际操作过，涨知识了。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"正向代理与反向代理","slug":"正向代理与反向代理","date":"2016-03-31T04:37:00.000Z","updated":"2016-12-12T02:54:46.000Z","comments":true,"path":"2016/03/31/正向代理与反向代理/","link":"","permalink":"http://sevencai.github.io/2016/03/31/正向代理与反向代理/","excerpt":"","text":"先问几个问题，什么事正向代理？什么是反向代理？两者又有啥区别呢？正向代理可以为我们做什么？反向代理又有什么作用呢？先前只知道反向代理，可是却忽略了正向代理。知识的学习没有全面，反思。下面图片部分整理学习来自网络，如有侵权请告诉我，谢谢啦。 正向代理 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 下面这张图很好的向我们解释了正向代理： 举个小例子简单的有个小例子：我们知道谷歌在国内被墙了，所以我们会去用vpn。vpn的作用就相当于一个代理服务器，使我们能够访问我们访问不了的网站。在这个过程中，我们知道有这样一个代理服务器存在，也知道访问谷歌也存在一个谷歌的服务器。这两个服务器的存在我们都很清楚。 上面的图中，用户A主动请求要访问的服务器B，在图中我们可以看到A先访问了代理服务器Z，Z收到请求后，再发送给服务器B。然后再由服务器Z把数据返回给A。 这个过程中，用户知道服务器B，也知道代理服务器Z，但这些所有的请求都是由代理服务器来处理的。 正向代理能够帮助我们做什么做缓存，加速访问可以在代理服务器Z做缓存，比如用户已经访问过B服务器后，把数据又返回给了Z，Z把这些信息都存在了本地，做了缓存，那么下次A再访问B的时候，是不是就不需要通过多次转发，不需要经过很多路由，而直接用了Z呢？这样就是利用代理服务器加速访问的原理。 翻墙原理刚刚提到了google那个例子，就是一个翻墙的常见实例。现在我们看下原理图。 服务器验证比如说我们可以采用代理服务器做一些验证，比如上网权限，因为互联网要先经过代理服务器。也是由于正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。 整个来说，正向代理就像一个跳板，我们不能访问一个服务器，但我们可以访问代理服务器，这个代理服务器又可以访问，我们交给代理服务器去取数据，然后再返回给我。客户端必须要经过一些特别的设置才能使用正向代理。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 对外表现为一个服务器怎么理解？比如访问cailidan.cn的时候，大家是不知道我用了反向代理的。大家以为访问的就是这个，但实际上用了反向代理，这个时候我的nginx表现的就像一个服务器一样。 反向代理服务器有两种模型，一种是作为内容服务器的替身，也可以作为内如服务器集群的负载均衡器。 反向代理的特点比如下图，用户A在访问B的资源的时候，并不知道中间还存在一个代理服务器，她一直以为请求的是原始服务器。但实际是反向代理服务器再接受了A的请求后，从原始B取得A的需求资源，并且发送给A。由于防火墙的作用，只允许代理服务器ZZ访问原始资源服务器B，尽管在这个环境下，真实的是由于防火墙和反向代理的共同作用保护了B，但是我们用户A并不知道。 相当于正向代理是代理客户端而言，反向代理是代理服务器。 反向代理的用途代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。 负载均衡 负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。 简单的来说，就是当我们的http请求过多的时候，反向代理服务器负责分发http请求，来确保某一个服务器不会压力太大，然后崩掉。 实现CDN刚刚我们知道了正向代理服务器可以实现缓存，从而加快访问的效果，那反向代理服务器也是一个代理服务器，那肯定也是拥有Cache功能的，它可以暖村原始资源服务器的资源，从而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。 CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置反向代理节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。 总结从安全上说 正向代理允许客户端通过访问任意网站并且还隐藏客户端的身份，因此咱么必须要用安全的措施用来确保，并未经过授权的客户提供服务。 反向代理对外是透明的，大家不知道自己访问的是一个代理服务器。 从用途上总结 正向代理主要是为防火墙内的局域网客户端提供internet访问途径，并且可以利用缓存来减少网络使用率。 反向代理的主要用途是为后台服务器提供负载均衡或者为后端比较慢的服务器提供缓冲技术。并且还有一些更加高级的URL策略和管理技术。 举个比方：正向代理就是有3个人，a是b的好朋友，b的好朋友是c，a有困难找了b，b不能解决就找了c。a他很清楚的知道b有个好朋友叫做c。就像我们用VPN翻墙，是知道必须买这个才行的。 但是反向代理，也是一样的过程，区别就是a他不知道b有个好朋友c，而且b还向c寻求帮助。a以为他的忙就是b帮的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"操作系统体系结构-梳理二-处理机管理","slug":"操作系统体系结构-梳理二-处理机管理","date":"2016-03-27T04:31:50.000Z","updated":"2016-12-12T02:54:34.000Z","comments":true,"path":"2016/03/27/操作系统体系结构-梳理二-处理机管理/","link":"","permalink":"http://sevencai.github.io/2016/03/27/操作系统体系结构-梳理二-处理机管理/","excerpt":"","text":"上一篇文章是操作系统的一个简述，这一篇文章就记录操作系统几个重要功能的详细内容。操作系统的功能主要是由4大功能：处理机管理，存储管理，设备管理，文件管理，作业管理。下面看看处理机管理。 处理机管理上一篇文章说了，处理机管理我们可以就归结为进程管理。那么进程到底是啥子？和程序又有什么区别呢？ 程序是完成特定功能而编排的指令集合的有序集合，是静态的，特点是顺序执行。但在多道系统中，由于存在多个独立的程序，他们对系统的资源即共享又竞争，程序不再以顺序方式执行，程序的顺序性，可再现行（不管怎么运行，都得到相同的结果），封闭性，与时间无关性，这些特点就没有了。这个时候，系统中的程序的执行方式也有了本质的变化，从顺序执行变成了并发执行。 并发与并行注意并发就是时间上有重叠，一个程序没有结束另一个程序就可以开始。这个时候，处理机在内的系统资源不再由一道程序独占，而是由多道程序共享。宏观上是并行的特征，微观上肯定还有顺序行的。毕竟同一个时刻，只有一个事物处于活动状态。 并行就是同一时刻，两个事物均处于活动状态。 进程的概念进程是操作系统最基本，最重要的概念。 进程是一个具有独立功能的程序关于某个数据集合的一次活动，是系统进行资源分配和调度的一个独立单位。两点：1.是程序的执行活动2.是资源调度的基本单位。 进程的组成进程 = 程序+数据+进程控制块（PCB） PCB的组织方式（其实大多数的组织方式，不仅仅是PCB都是类似下面的这种情况） 线性表结构 链接表结构 索引表结构 线性表特点肯定就是：在一个连续的区域中，并且每次都要扫描整个线性表，增加了系统开销。适用于进程比较少的操作系统。 链接表，由于系统中的进程的总数量以及处于各种状态下的进程数量是动态变化的，为了便于管理，就把有些操作系统使用链表数据结构把处于相同状态进程中的PCB链接在一起，成为进程队列。 索引表结构是利用索引表记载各种状态进程的PCB地址，将线性表中相同的进程的PCB建立一个索引表，形成比如说就绪索引表，等待态索引表等。索引表中就绪索引表只有一个。注意这个图中为啥美欧运行指针的索引表呢？因为运行的时候只有一个进程，那就不需要建立一个索引表啦。 PCB的状态及其转换这是重点，三种状态： 运行态：进程获得了处理机，注意处于裕兴状态的进程个数不能大于CPU的数目。对于单处理操作系统，任何时刻，正处于运行状态的进程最多一个。 就绪态：指进程已经具备了可以在处理机上运行的条件，但因为出理解已经被其他的进程占用而处于一种等待处理机的状态。 等待态：当一个处理机上运行的程序，因为等待某一个事情发生而不能继续运行，那么这个进程处于等待太，比如中途一个进程需要申请使用某种I/O设备。 当一个进程刚被创建的时候，处于就绪态。进程的转换图如下，看到这里的时候想一想下面的转换分别会发生在什么时候。 进程的控制进程的控制室操作系统的底层功能之一，本身属于操作系统的内核，内核在执行操时候，往往是通过各种原语操作实现的。 原语为了防止进程在执行过程中被其他的程序给打断，并且要保证程序执行的唯一性和数据结构的完整性，我们一如了原语的概念。一般的，把系统态下的执行的某些具有特定功能的程序段成为原语。 包括创建原语，撤销原语，阻塞原语，唤醒原语。 这里只看下进程创建原语的功能： 首先申请一个空闲的PCB,并指定唯一的进程标志号PID 为新进程分配资源。根据调用者提供的所需内存的大小，为新进程分配必要的内存空间，并且装入该进程的试题（程序和数据） 将新进程的PCB初始化 讲进程加入到就绪队列中 进程调度在多道的系统中，往往进程数目多余处理机的数目，他们都要使用处理机运行自己的程序，所以处理机成为竞争的主要资源。 进程调度的方式 可剥夺调度方式 剥夺原则1：优先级原则 剥夺原则2：短进程优先原则 剥夺原则3：时间片原则 剥夺原则4：强制性剥夺（人工干预） 非可剥夺调度方式 这种方式又称为不可抢占式方式。这是指一旦把处理机分配给某个进程之后，则该进程一直占用处理机，只有当进程运行完毕或者等待某种外部原因而不能继续运行自动放弃处理机的情况下。系统才把处理机分配给其他的进程。 进程调度算法 先来先服务调度算法（不利于段作业，但算法实现简单） 优先数法（先按照某种原则赋一个优先级，又分为下面几种） 静态优先数法（创建的时候赋给一个优先数） 动态优先数法（根据进程的生命期动态变化） 时间片轮转法（一个进程占用一点） 注意这里的时间片轮转法，太长的话，就会变成先来先服务，太短的话，调度程序剥夺处理机次数增多，会导致切换次数太大，而且加重了系统开销。 进程的同步与互斥一方面进程需要互相协作才能待到运行用户作业的目的，另外一个方面就还存在某种简介或者直接的制约关系。 临界资源，临界区：一次只能一个进程使用的资源成为临界资源。访问临界资源的程序段成为临界区。 进程的同步：进程为了完成那个某个共同的目标，必须相互合作的协同工作，有前后次序de直接制约关系，成为进程的同步。 进程的互斥：多个进程不能同时访问临界资源而产生的制约关系。 一个是合作，一个是竞争。我觉得可以这么理解。这个过程中又设计了PV操作和信号量。 信号量是由两个部分组成的：一个成员变量是信号量的值，整型，另一个是PCB的指针。 当信号量的值大于等于0时候，就是表示当前可用资源的实体个数。当它的值小于0的时候，就表示正在等待使用该资源的进程个数。即在信号量队列上排队的PCB的个数。 进程的通信机制刚刚的同步和互斥是低级通信，有的时候如果我们需要交换大量的信息，这种方式就需要专门的通信机制来实现。我们把实现进程交换大量信息的通信方式成为高级通信。 两种方式： 直接通信（消息缓冲通信）过程是：发送进程在发送消息之前，先在内存中设置一个发送区，把要发送的消息正文还有进程名填入其中，然后发送消息程序。接收程序在读取消息之前，先在自己占用的内存空间中设置一个消息接受区，然后调用接收消息的程序。 间接通信（信箱通信）这个最大的好处就是发送进程和接受进程之间没有时间上的限制。想想为啥叫信箱。 进程和线程线程是一个进程的实体，是CPU调度和分派到基本单位，是进程的一个执行单元。进程是操作系统资源分配的基本单位。 我们把计算机中执行的程序成为线程，而不是程序。所谓线程，是进程中某个单一顺序的控制流 线程很轻，所以切换非常迅速，减少了系统的开销。 在引入线程的操作系统中，调度的基本单位是线程，而不是进程。真正在CPU上执行的是线程。 进程是抢占处理机的调度单位。拥有一个完整的虚拟地址空间。 刚刚看了一个多线程，单线程的理解，简单的就这么理解： 你早上上班，正要打卡的时候，手机响了。。你如果先接了电话，等接完了，在打卡，就是单线程。如果你一手接电话，一手打卡。就是多线程。2件事的结果是一样的。。你接了电话且打了卡。 —-来自网络 多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。 最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。 总结进程调度是操作系统最核心的部分，要掌握线程和进程的区别和联系。要知道进程的调度算法。要了解同步和互斥的关系。还要知道并发和并行的区别。","categories":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"操作系统体系结构-梳理一","slug":"操作系统体系结构-梳理一","date":"2016-03-27T00:52:31.000Z","updated":"2016-12-12T02:54:28.000Z","comments":true,"path":"2016/03/27/操作系统体系结构-梳理一/","link":"","permalink":"http://sevencai.github.io/2016/03/27/操作系统体系结构-梳理一/","excerpt":"","text":"最近慢慢的把操作系统那块的东西捡起来，看的比较快了，因为里面的东西都没有全部忘记。为了方便每次查找和遗忘，我想把这个整体简单的一些知识做一些梳理，细节不会讲很多，因为这样才会每次去想这个到底是什么。具体的知识梳理我看的就是学校发的教材《操作系统原理分析》。先前看到了winter大神的【这篇】文章，觉得里面说的建立自己的知识体系结构等等，我觉得特别棒。 操作系统的概述先问自己几个问题： 操作系统是什么？ 操作系统的功能是什么？ 操作系统是怎么发展的？ 操作系统有哪些类型？ linux的优越性能？ 如果都答出来了，下面的就可以忽略啦。 操作系统是什么？操作系统是一组控制和管理计算机系统资源的程序集合，它控制和协调并发起活动，为用户提供良好的接口。 操作系统有4个特征：并发性，共享性，不确定性，虚拟性。下面是具体的这几个特点的解释。 并发性并发性是指计算机中若存在干个程序的运行，系统中多个活动同时进行，I/O操作和计算机操作重叠。目的是改善系统资源的利用率，提高了系统的吞吐量，但是它也使系统复杂话了，操作系统必须具有控制和管理各种并发活动的能力。 共享性共享性是指多个计算机任务对系统资源的共同享用，操作系统程序与多个用户程序公用系统中的各个资源，比如中央处理器,内外存储器，外部设备，文件等。 不确定性在多道程序中环境下，操作系统的运行实在随机的环境下运行的。 这里的随机是指：操作系统不可能对所运行的程序的行为和硬件设备的情况作出任何事先假定。 虚拟性所谓的虚拟，是指的把一个物理上的实体变为若干的逻辑上的对应物。物理实体是实的，而后者是虚的，相应的，用于实现虚拟的技术，成为虚拟技术。 比如在操作系统中，分别用来实现虚拟处理机，虚拟内存，虚拟外部设备和虚拟信道。 操作系统的功能处理机管理 存储管理 设备管理 文件管理 作业管理 处理机管理为了准确的描述多道系统中多个作业的运行情况，以及系统资源分配的情况，采用什么可以反映与描述计算机程序的执行过程和资源共享和用户随机的特点呢？ 操作系统引入了进程的概念，进程是资源分配和独立运行的基本单位和基本实体。 所以我们这里把处理机管理可归结为进程管理。 具体的操作系统其他功能包括进程管理等，下一篇文章单独做记录。 操作系统的发展无操作系统的计算机系统 早期简单批处理操纵系统 多道批处理系统 操作系统的类型下面只列举了针对不同的使用环境和对作业的处理方式来分的情况： 单用户操作系统 批处理操作系统 分时操作系统 实时操作系统 通用操作系统 网络操作系统 分布式操作系统 单用户操作系统一次只能支持一个用户程序的运行。单用户操作系统向用户提供练级的交互环境。比如MS-DOS就是一个典型的单用户操作系统。 批处理操作系统 顾名思义：批处理操作系统就是对多个用户的作业进行成批的处理，批处理系统的设计目标是提到系统资源的使用率和作业吞吐量。 这里面又分为了单道批处理系统和多道批处理系统。 多道批处理系统是每一次把一批经过合理搭配的作业通过输入设备提交给操作系统，并暂时存入外存，等待运行。 当系统需要调度新的作业的时候，就根据运行的情况和用户要求，按照某种调度原则，从外存中挑选一个或者几个作业装入内存运行。 此过程的最大特点就是脱机处理，系统运行的过程中不允许用户与作业交互作业，用户不能直接干预自己的作业的运行，知道运行作业运行完毕。 这是早期的一种大型机用的操作系统。无交互性。 分时操作系统为克服多道批处理系统的缺点，出现了分时系统。 分时系统是指一台计算机主机连接着多个终端机，可以被多个用户同时处理使用，每个用户通过自己使用的终端采用人机对话的形式控制自己的程序，系统将cpu分成时间片为多个终端用户服务。 目标是：及时响应，并在可能的情况下提高资源的利用率。 实时操作系统是指对计算机的特定输入做出快速的反应，以控制发出实时信号的对象，即计算机及时响应外部的请求，在规定的短时间内完成这个事情。 实时就是立即，现在的意思。 网络操作系统是使网络上各计算机能方便而有效的共享网络的资源，为网络用户提供各种软件和规程（如协议）的集合。 信息交换，资源共享，自治，分散。是其特点。 分布式操作系统由多台计算机组成。这些计算机系统资源可以分布在不同的地理位置，但在逻辑上是一个完整的计算机系统。 统一性，共享性，透明性，自治性，独立性。 与网络操作系统不同，分布式操作系统网络的概念被淡化了，所有资源都用同一方式进行管理和访问，用户不需要知道资源在哪里或者是怎么存储的。 注意这里的透明。网络操作系统的资源是透明的吗？当然不是了。 linux的优越性能首先linux第一个肯定是最好的就是开源和免费。并且支持多用户，多任务。还有非常好的界面，同时具有字符界面和图形界面。还有很强大的网络功能。支持多种文件系统，支持多种硬件平台。","categories":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"Date对象","slug":"Date对象","date":"2016-03-24T07:57:18.000Z","updated":"2016-12-12T02:59:26.000Z","comments":true,"path":"2016/03/24/Date对象/","link":"","permalink":"http://sevencai.github.io/2016/03/24/Date对象/","excerpt":"","text":"Date对象，以前每次看书都没有重视过，每次要用的时候就去查相应的函数，api不熟悉。虽然可能失败了，但是知道自己哪里不行，能学到东西就已经很开心了，而且还涨了个教训，挺好的。下面来看看api得到的具体结果是什么。123456789101112131415161718var now = new Date();console.log(now);console.log(now.toLocaleString());console.log(now.toGMTString());console.log(now.getUTCDate());console.log(now.getTime());console.log(now.valueOf());console.log(Date.parse(now));console.log(now.getDate());console.log(now.getDay());console.log(now.getHours());console.log(now.getFullYear());console.log(now.toString());var dt = new Date(\"2012-12-1\");console.log(dt); 判断时间就用时间戳是最方便的，把每个时间戳都算出来。然后对比是不是在相应的时间段内。当时写的时候，不能在本机调试，所以不知道每个调用函数得到的结果是什么。还是要多写多练才好，这样熟了，也不用一个个去打印调试了。加油。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//获取某年某月某天的0点的时间戳function setDate0(dateTime)&#123; var year = dateTime.getFullYear(); var month = dateTime.getMonth(); var day = dateTime.getDate(); var newDate = new Date(year,month,day,0,0,0); return newDate.getTime();&#125;function printTime(datetime)&#123; //设置一天的微秒数 var micro = 24*60*60*1000; //获取dateTime对应的时间对象,datetime为时间戳，大小写区分 var dateTime = new Date(datetime); //获取今天此刻的时间戳和时间 var today = new Date(); var todayTS = today.getTime(); //获取今天0点的时间戳 var today0 = setDate0(today); //明天的0点时间戳 var tom0 = today0 + micro; //获取昨天零点的时间戳 var yesterday0 = today0 - micro; //获取一个本星期一开头的时间戳 var week0 = today0 - ((today.getDay()+6)%7)*micro; console.log(today0+\"hello\"+tom0+\"world\"+week0); //开始判断和输出 if(datetime &gt;= today0 &amp;&amp; datetime &lt; tom0)&#123; return dateTime.getHours()+\":\"+dateTime.getMinutes(); &#125;else if(datetime &gt;= yesterday0 &amp;&amp; datetime &lt; today0)&#123; return \"昨天\"; &#125;else if(datetime &gt;= week0 &amp;&amp; datetime &lt; yesterday0)&#123; var arr = [\"周日\",\"周一\",\"周二\",\"周三\",\"周四\",\"周五\",\"周六\"]; return arr[dateTime.getDay()]; &#125;else&#123; return null; &#125;&#125;console.log(printTime(1458803593715));","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"BFC-Block Formatting Context","slug":"BFC-Block-Formatting-Context","date":"2016-03-20T01:43:53.000Z","updated":"2016-12-12T02:59:12.000Z","comments":true,"path":"2016/03/20/BFC-Block-Formatting-Context/","link":"","permalink":"http://sevencai.github.io/2016/03/20/BFC-Block-Formatting-Context/","excerpt":"","text":"以前知道BFC,但是感觉理解的不是很清楚，今天查了些资料总结记录如下。 A Block Formatting Context is part of the visual CSS rendering of a web page in which block boxes are laid out. The positioning scheme to which it belongs is normal flow. 这句话告诉了我们，第一，BFC是可视化格式模型（Visual Formattting Model）的一个部分。第二，BFC属于普通流中的一种。 总的来说关系是：可视化格式模型&gt;定位方案&gt;普通流&gt;BFC. 前提知识在css的可视化格式模型（Visual Formattting Model）中有一个重要的概念：定位方案。 定位方案分为三种定位方案： 普通流(Normal Flow) 浮动（Floats） 绝对定位（Absolute Positioning） 普通流（Normal Flow）在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行， 除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动（Floats）在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位（Absolute Positioning）在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响（如果看了上文的童鞋，会发现这点与浮动元素会影响兄弟元素是不同的），而元素具体的位置由绝对定位的坐标决定。 在这个普通流中，就有一种布局：BFC,它不会对兄弟元素造成什么影响。 那么到底什么事BFC呢？从样式上看，具有 BFC 的元素与普通的容器没有什么区别。 但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，比如清除浮动的方法（如 overflow 方法）就是触发了浮动元素的父元素的 BFC ，使到它可以包含浮动元素，从而防止出现高度塌陷的问题。 简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。 再简单的来说，用了下面的一些属性后，你就创建了一个BFC。这个BFC功能上不同于普通容器。 这个BFC并不是这些元素，而是某些元素的带有属性产生了BFC. 怎么样形成BFC Floats, absolutely positioned elements, inline-blocks, table-cells, table-captions, and elements with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts. 浮动、绝对定位元素（position 为 absolute 或 fixed）、行内块元素 display:inline-block 、表格单元格 display:table-cell 、表格标题 display:table-caption 以及overflow 属性值部位visible 的元素（除了该值被传播到视点viewport的情况）将创建一个新的块级格式化上下文。 也就是说下面的情况会形成一个BFC： 1. float的值不为none 2. position的值不为static或者relative 3. display的值为table-cell,table-caption,inline-block,flex,inlineflex 4. overflow的值不为visible 创建一个块级格式上下文可能产生的问题一个BFC可以通过上面的很多css样式触发，但毕竟上面的CSS属性都有自己原本的样式，那么久可能在原来的基础上，加入了一些我们不需要的样子。比如说： display:table可能引发响应式问题 overflow:scroll可能产生多余的滚动条 float:left浮动，将把元素移动到左侧，并被其他元素环绕 overflow:hidden讲剪裁溢出元素 所以，咱们在创建一个BFC的时候，就要选择最恰当的样式，一般可以选用overflow:hidden。123.container&#123; overflow:hidden;&#125; 那么BFC到底有很么特点和作用呢？ BFC中的盒子对齐 In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子Line Box可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。 这是BFC的一个特点。简单来说，如上图所示，所以属于BFC的盒子都是左对齐（在从左到右的格式下）并且他们的左外侧紧贴包含块的左侧。在最后一个盒子中我们可以看到，尽管左侧存在一个浮动元素（棕色），另外一个元素（绿色）仍然紧贴包含块的左侧。该情况的产生原理将在下文关于文字环绕的部分中讨论。 使用BFC避免文字环绕Using Block Formatting Contexts to Prevent Text Wrapping 浮动最初设计的目的就是文字环绕，这一个目的导致我们后来用浮动的时候会出现一些问题，比如说，我本就不想要文字环绕这一特点，我就需要想办法去除它。12345678910&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt; Floated div &lt;/div&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolorum rerum minima tenetur qui provident laudantium reprehenderit porro maiores facilis vitae, quas, quos quibusdam eum accusamus suscipit. Quos molestiae saepe unde. &lt;/p&gt;&lt;/div&gt; 当我们把floated设置为浮动的时候，整个样子如图1所示。 我们来看看为什么会这样。其实我们以为的是这样的： 但事实是当我们把浮动的颜色去掉后是这样的：如我们所见，p 元素没有移位但它叠在了浮动元素之下，而p元素的行盒子（即文本行）却移位了，行盒子水平变窄来给浮动元素腾出了空间。 随着文本的增加，最后文本将环绕在浮动元素之下，因为那时候行盒子不再需要移位，也就成了图1的样子。这就是为什么即便有浮动元素，段落仍紧贴包含块的左侧，而行盒子会变窄来给浮动元素腾位子。 如果我们能位移整个 p 元素，这个环绕问题也就迎刃而解了。 然后我们再回顾下上一个BFC中的盒子对齐的特点。 在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。 如果我们给p元素创建一个新的BFC,就可以解决了。我们给p元素加上overflow:hidden这个元素。这样就变成了我们想要的样子了。 提醒，这也是为什么有的时候我们需要两块之间有一些间距，然后我们设置了margin-left但还是不管用的原因，并不是margin-left不管用，只是我们设置的太小啦。 会造成外边距重叠，但也可以防止外边距重叠A Block Formatting Context Causes Collapsing Margins. Block formatting contexts stop margins from collapsing. 仔细看上面两句话，是不是觉得有点奇怪，他的意思是说：BFC会造成外边距重叠，但是BFC也可以阻止外边距重叠。 在常规流中，盒子从包含块的顶部开始一个个地垂直摆放。两个同胞盒子间的垂直距离由两个盒子各自的外边距所决定，但不是二者外边距之和。 1234&lt;div class=\"container\"&gt; &lt;p&gt;sibling 1&lt;/p&gt; &lt;p&gt;sibling 2&lt;/p&gt;&lt;/div&gt; 12345678.container &#123; background-color: red; overflow: hidden;&#125;p &#123; background-color: lightgreen; margin: 10px 0;&#125; 上面我们利用overflow：hidden创建了一个BFC。这个BFC造成了外边距重叠，也就形成了上面的情况，本来该是20px的边距的，现在只有了10px。 在讨论了上面BFC折叠外边距的情况后，我们必须牢记于心的一件事是，相邻块级盒子（同胞）之间的垂直外边距只有在它们处于同一个BFC时才会发生折叠。如果它们分属于不同的BFC，就不会折叠了。所以，通过创建新的BFC我们可以避免外边距折叠。 1234567&lt;div class=\"container\"&gt; &lt;p&gt;Sibling 1&lt;/p&gt; &lt;p&gt;Sibling 2&lt;/p&gt; &lt;div class=\"newBFC\"&gt; &lt;p&gt;Sibling 3&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.container &#123; background-color: red; overflow: hidden; /* creates a block formatting context */&#125;p &#123; margin: 10px 0; background-color: lightgreen;&#125;.newBFC &#123; overflow: hidden; /* creates new block formatting context */&#125; 由于第二个和第三个兄弟节点分属于不同的BFC,所以在他们之间不会有任何的外边距重叠。 使用BFC包含浮动Using a Block Formatting Context to Contain FloatsBFC可以包含浮动。我们经常遇到容器中含有浮动元素的情况。这种情况下容器元素没有高度并且其浮动子元素脱离了网页的常规流。我们通常用清除浮动解决这个问题，最普遍的做法就是使用伪元素。但我们也可以通过创建一个BFC来解决问题。12345678910111213&lt;div class=\"container\"&gt; &lt;div&gt;Sibling&lt;/div&gt; &lt;div&gt;Sibling&lt;/div&gt;&lt;/div&gt;.container &#123; background-color: green;&#125;.container div &#123; float: left; background-color: lightgreen; margin: 10px;&#125; 上面的我们可以很清楚的知道为啥会没有把父元素撑起来，因为子元素浮动，脱离了文档流，我们一般用clear:both，或者伪元素，或者这里的overflow:hidden。都可以很好的解决这个问题。12345678910.container &#123; overflow: hidden; /* creates block formatting context */ background-color: green;&#125;.container div &#123; float: left; background-color: lightgreen; margin: 10px;&#125; 现在容器可以包住浮动子元素，并且其高度会扩展至包住其子元素，在这个新的BFC中浮动元素又回归到页面的常规流之中了。 在多列布局中使用BFCUsing Block Formatting Contexts in Multi-column Layouts 如果我们创建一个占满整个容器宽度的多列布局，在某些浏览器中最后一列有时候会掉到下一行。这可能是因为浏览器四舍五入了列宽从而所有列的总宽度会超出容器。但如果我们在多列布局中的最后一列里创建一个新的BFC，它将总是占据其他列先占位完毕后剩下的空间。 1234567891011121314151617&lt;div class=\"container\"&gt; &lt;div class=\"column\"&gt;column 1&lt;/div&gt; &lt;div class=\"column\"&gt;column 2&lt;/div&gt; &lt;div class=\"column\"&gt;column 3&lt;/div&gt;&lt;/div&gt;.column &#123; width: 31.33%; background-color: green; float: left; margin: 0 1%;&#125;/* Establishing a new block formatting context in the last column */.column:last-child &#123; float: none; overflow: hidden; &#125; 在尽管盒子的宽度稍有改变，但布局不会打破。当然，对多列布局来说这不一定是个好办法，但能避免最后一列下掉。这个问题上弹性盒或许是个更好的解决方案，但这个办法可以用来说明元素在这些环境下的行为。 为什么会是这样，这跟上面一个原因差不多。我们在最后定义了一个新的BFC后，这个盒子的左外侧就不会紧贴包含块的左侧。 当然，在这里我们也可以用增加伪元素来实现。 总结主要是把BFC的整个的总结记录下。也方便以后查阅。学习参考自：understanding-block-formatting-contexts-in-css,感谢。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"冒泡排序vs归并排序vs选择排序vs插入排序","slug":"冒泡排序vs归并排序vs选择排序vs插入排序","date":"2016-03-18T04:47:05.000Z","updated":"2016-03-18T05:02:36.000Z","comments":true,"path":"2016/03/18/冒泡排序vs归并排序vs选择排序vs插入排序/","link":"","permalink":"http://sevencai.github.io/2016/03/18/冒泡排序vs归并排序vs选择排序vs插入排序/","excerpt":"","text":"今天写了几个小排序，记录下来，都是比较简单的。 归并排序归并排序的思想是分治，我们先来看下分治的思想。 分治：分而治之。就是把一个复杂的问题分成两个或者更多的相同的货相似的子问题，再把子问题分成更小的子问题。一直到最后子问题可以简单的直接求解。原问题的解即为子问题的合并。 比如快速排序，归并排序，傅里叶变换都是利用的分而治之的思想。 分治的策略是： 对于一个规模为n的问题，若该问题可以容易的解决，则直接解决。 若不能直接解决，将其分解为K个规模比较小的子问题。 这些子问题互相独立与原问题形式相同，递归的解这些子问题，然后将各子问题的解合并得到原问题的解。 归并排序：将待排序元素分成大小大致相同的2个子集合(递归直到最小的排序单元），分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。 归并排序算法的时间复杂度是O（nlogn）,对于冒泡排序的O(n*n),效率还有有比较好的提高。js代码如下： 1234567891011121314151617181920212223242526function merge(left,right)&#123; var resultArr = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0)&#123; if(left[0]&lt;right[0])&#123; resultArr.push(left.shift()); &#125;else&#123; resultArr.push(right.shift()); &#125; &#125; return resultArr.concat(left).concat(right);&#125;function mergeSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var mid = parseInt(arr.length/2); var left = arr.slice(0,mid); var right = arr.slice(mid); return merge(mergeSort(left),mergeSort(right));&#125;var arr = [2,4,1,7,8,4];console.log(mergeSort(arr)); 插入排序将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n^2)。 注意与选择排序的区别，插入排序是把后面的每一个数插入到前面已经排好序的队列中。而选择排序是每次在后面选择最小的或者最大的，插入到已经有序的队列后面。 1234567891011121314function insertSort(arr)&#123; for(var i=1;i&lt;arr.length;i++)&#123; var j=i-1; var value = arr[i]; while(j&gt;-1 &amp;&amp; value&lt;arr[j])&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = value; &#125; return arr;&#125;var arr = [2,4,1,7,8,4];console.log(insertSort(arr)); 前面已经排好序了，要把后面最小的数插入到前面，所以是要从j=i-1开始找。然后如果该数一直比前面的有序的小，就把比他大的数往后移动，最后找到该点后，再把元素插入到该地方。 冒泡排序冒泡排序可谓是最经典的,最简单的排序算法了，它是基于比较的排序算法，时间复杂度为O(n^2)，其优点是实现简单，n较小时性能较好。 相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。下面是js完成冒泡排序。12345678910111213141516function bubbleSort(arr)&#123; var len = arr.length; for(var i=0;i&lt;len;i++)&#123; for(var j=len-1;j&gt;i;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; var temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125; return arr;&#125;var arr = [2,4,1,7,8,4];console.log(bubbleSort(arr)); 选择排序有两个序列，一个是已经排序的序列，一个是暂未排序的序列。每次都从后面选出一个最大的或者最小的插入到前面已经排序好的末尾。依次类推，知道所有的元素排列完毕。 先把第一个定位基准，往后面未排序的找到最小的并且记录下index。如果index是不等于原来的i，说明这一趟已经找到了比他小的数，就可以讲这两个数交换了。 12345678910111213141516171819function selectSort (arr)&#123; var len = arr.length; for(var i=0;i&lt;len;i++)&#123; var index = i; for(var j=i+1;j&lt;len;j++)&#123; if(arr[index]&gt;arr[j])&#123; index = j; &#125; &#125; if(index!=i)&#123; var temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; &#125; &#125; return arr;&#125;var arr = [2,4,1,7,8,4];console.log(selectSort(arr)); 事件复杂度","categories":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/tags/算法/"}]},{"title":"javascript单线程整理和理解","slug":"javascript单线程整理和理解","date":"2016-03-17T11:23:17.000Z","updated":"2016-12-12T03:00:34.000Z","comments":true,"path":"2016/03/17/javascript单线程整理和理解/","link":"","permalink":"http://sevencai.github.io/2016/03/17/javascript单线程整理和理解/","excerpt":"","text":"异步的另外一种含义是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。异步与多线程与并行不是同一个概念。 先问自己几个问题 javascript是单线程的吗? javascript如果是单线程为什么能让ajax异步发送和回调请求？ setTimeout一定是按照它定的时间发生的吗？ 浏览器是多线程的吗？ event loop是什么呢？ 下面这段代码的结果是什么？ 123456789function foo()&#123; setTimeout(function()&#123; console.log(\"inner\"); &#125;) console.log(\"outer\");&#125;for(var i = 0;i &lt; 10;i++)&#123; foo();&#125; javascript是单线程方便理解，可以这么想，如果js不是单线程的，那么当我们要可能在操作一个DOM的时候（比如修改，删除，添加），另一个线程可能也在对这个DOM节点进行操作。这么肯定是不行的。 这跟javascript最初的用途是有关的，js本来设计就是为了更好交互效果，更方便操作DOM，这一特点某种程度上决定了他的单线程。 js运行在浏览器中是单线程的。每一个window一个js线程。由于是单线程，那么在一个时刻只能够执行某个特定的代码，并且阻塞其他的代码。这也就意味着如果前面一个任务耗时很长的时候，后一个任务就会一直等待。js的单线程机制其实是:有两个队列，一个是主线程。一个是任务队列。 浏览器不是单线程的js运行在浏览器中，是单线程的，每个window一个js线程，但是浏览器不是单线程的。他可能有很多线程，比如js引擎线程，界面渲染线程，浏览器事件触发线程，http请求线程。 单线程的机制刚刚提到了javascript的单线程的机制其实是有两个队列，一个是主线程队列，一个是任务队列。 之所以要有这么两个队列： JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。–from ruanyifeng 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 js都是先执行同步任务，再执行异步任务。 那么上面的第六个问题就很清楚了，答案是先输出10个outer,再输出10个inner。因为outer是位于主线程上，inner是位于任务队列中，js在执行的时候必须先把主线程的做完，再执行任务队列。在主线程和任务队列这两个队列里又是又是阻塞的。 123setTimeout( function()&#123; while(true)&#123;&#125; &#125; , 100);setTimeout( function()&#123; alert('你好!'); &#125; , 200);console.log(\"hello\"); 上面这个的结果里是可以输出hello的，跟我们想的一样，但是alert的你好，是永远都没有办法出来的。原因上面说了。 异步事件驱动浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。 setTimeout(func, 0)一定是0s就执行吗？上面说了必须要等主线程的所有事件被完成时，才能够执行任务队列上的事件。setTimeout(func, 0）这句话，告诉了js引擎，要在0s之后吧func函数放到主事件队列里面，等待当前其他的所有的主线程任务完成了，就开始执行。之所以有用，是因为当前并没有主线程上并没有其他的任务。如果当前的主线程上有其他的任务，那么其实func的执行时间，绝对不会是0s。因为它还要排队。 总结异步执行的运行机制（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 总的来说就是，任务队列里的任务都是必须等主线程的执行栈空了才去执行的。我们通常说的同步也就是没有上面的异步任务。 Event Loop是啥子？主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 为什么会看见下面这种现象？现在想想以前写xhr的时候就在书上这么看过，但是当时也没多想，虽然知道是异步没关系。123456789101112//写法一var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send();//写法二var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 这两种写法是一样的，为什么呢？因为send是一个异步执行过程，那么他会等当前所有的非异步执行完再去执行。它被放入了任务队列。 再来看看异步，多线程，并行的概念并行，一般指并行计算，是说同一时刻（注意并发是同一时间段）有多条指令同时被执行，这些指令可能执行于同一CPU的多核上，或者多个CPU上,或者多个物理主机甚至多个网络中. 异步，与同步相对应，异步指的是让CPU暂时搁置当前请求的响应,处理下一个请求,当通过轮询或其他方式得到回调通知后,开始运行。 线程，是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 总结了解了js单线程，知道什么是异步事件驱动，知道了有主线程的执行栈和任务队列这两个机制。还有setTimout不一定就是在它设置的时间执行呦。学习和整理自ruanyifeng的文章，感谢。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"解析和整理this的指向问题","slug":"解析和整理this的指向问题","date":"2016-03-15T12:44:43.000Z","updated":"2016-12-12T03:02:22.000Z","comments":true,"path":"2016/03/15/解析和整理this的指向问题/","link":"","permalink":"http://sevencai.github.io/2016/03/15/解析和整理this的指向问题/","excerpt":"","text":"本篇主要总结了this指针的指向问题。如果把问题细分，就可以更容易的得到判断。 以普通函数的方式调用（Invocation as a function）1234function test()&#123; console.log(this);&#125;test(); 结果是window。结论是当我们以一个函数的方式调用的时候，this就是指向window全局作用域。定义在全局的函数, 函数的所有者就是当前页面, 也就是window对象。我们可用通过函数名直接调用, 也可用通过window.方法名来调用, 这个时候, 方法中的this关键字指向它的所有者:window对象.12345function a() &#123; function b() &#123; console.log(this); &#125; b();&#125;a(); 试试这一个，可能大家跟我一样,如果不仔细看，就会觉得结果是b。但实际上打印出来的还是window对象。 When invoked in this manner, the function context is the global context—the window object. 以对象方法来调用（Invocation as a method）函数还可以作为某个对象的方法调用，这时this就指这个上级对象。123456var obj = &#123; fun : function()&#123; console.log(this); &#125;&#125;;obj.fun(); 结果是object。结论是当我们以一个对象的方法的形式来调用一个函数，这个时候的上下文就变成了这个对象，this指向的也就是这个对象。 When we invoke the function as the method of an object, that object becomes the function context and is available within the function via the this parameter. 以构造函数的形式（Invocation as a constructor）通过构造函数可以生成一个新对象，this就指向这个新对象。12345function creep()&#123; console.log(this); return this; &#125;new creep(); 结果是creep{}。当我们以构造函数的形式唤醒一个函数的时候，就会发生下面这些事情：一个新的对象会首先被创建，被创建的对象会成为当前构造函数的上下文。 Invoking a function as a constructor is a powerful feature of JavaScript, because when a constructor is invoked, the following special actions take place: * A new empty object is created. * This object is passed to the constructor as the this parameter, and thus becomes the constructor’s function context. * In the absence of any explicit return value, the new object is returned as the constructor&apos;s value. Call和Apply改变this指向(Invocation with the apply() and call() methods)apply()，Apply()是函数对象的一个方法，它的作用是改变函数的调用对象，切换函数执行的上下文环境（context），即 this 绑定的对象。Call和Apply的区别在于，apply传递的是数组，call传递的是直接参数量。12345678910111213function juggle() &#123; var result = 0; for (var n = 0; n &lt; arguments.length; n++) &#123; result += arguments[n]; &#125; this.result = result;&#125; var ninja1 = &#123;&#125;;var ninja2 = &#123;&#125;;juggle.apply(ninja1,[1,2,3,4]);juggle.call(ninja2,5,6,7,8); assert(ninja1.result === 10,\"juggled via apply\");assert(ninja2.result === 26,\"juggled via call\"); To invoke a function using its apply() method, we pass two parameters to apply(): the object to be used as the function context, and an array of values to be used as the invocation arguments. The call() method is used in a similar manner, except that the arguments are passed directly in the argument list rather than as an array. 以事件处理函数的方式1234function test()&#123; console.log(this.value);&#125;document.getElementById(\"ele\").onblur = test; 这样是可以准确的得到input里面的值的,但是为啥这里this不是window对象呢？test是再全局作用域下定义的吗？为啥可以成功的获取到DOM的值呢？问题出在onclick事件绑定的时候，在对onclick绑定处理器的时候, 其实是对id为name的输入框Dom对象的onclick属性赋值。比如说我们把这个onblur对象打印出来：console.log(document.getElementById(“ele”).onblur); 可以看到这个onblur底下是有test函数的。 比如说下面这个可以得到正确的答案吗？1234function test() &#123; alert(this.value);&#125;&lt;input id=\"name\" type=\"text\" value=\"test\" onclick=\"test()\"/&gt; 这个时候的alert出来的是undefined。所以这里的this指向全局对象window。 嵌套函数中的this嵌套函数中的this不会继承父级函数的this，需要将this变量进行暂存，保存到另外一个变量中才行。比如下面一个例子：12345678910111213141516171819202122232425262728//例子1var name = \"outer\"; var foo3 = &#123; name: \"inner\", sayHello: function() &#123; console.log(this.name); var subSayHello = function() &#123; console.log(this.name); &#125; subSayHello(); &#125; &#125; foo3.sayHello(); //先输出inner，后输出outer//例子2 var name = \"outer\"; var foo3 = &#123; name: \"inner\", sayHello: function() &#123; var that = this; console.log(that.name); var subSayHello = function() &#123; console.log(that.name); &#125; subSayHello(); &#125; &#125; foo3.sayHello(); // 都输出inner 严格模式下的thisECMAScript 5 引入了 strict mode ,现在已经被大多浏览器实现(包括IE10. 会使web浏览器更容易的解析代码(只需要添加 “use strict”; 在源码的最上面), 由现有的代码到严格模式的过渡需要一些事做. 在普通的函数调用f()中,this的值会指向全局对象.在严格模式中,this的值会指向undefined.当函数通过call和apply调用时,如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串,数字,布尔值),则this的值会成为那个原始值对应的包装对象,如果thisvalue参数的值是undefined或null,则this的值会指向全局对象.在严格模式中,this的值就是thisvalue参数的值,没有任何类型转换. 总结问题来啦，调用者是谁this就指向谁，这句话对吗？？？！！！","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"javascript的垃圾回收机制","slug":"javascript的垃圾回收机制","date":"2016-03-13T05:48:14.000Z","updated":"2016-12-12T03:00:44.000Z","comments":true,"path":"2016/03/13/javascript的垃圾回收机制/","link":"","permalink":"http://sevencai.github.io/2016/03/13/javascript的垃圾回收机制/","excerpt":"","text":"和java,c#一样，javascript也有自动垃圾回收的机制，比如说c++和c就没有自动垃圾回收机制。可能有这么一种倾向，垃圾回收机制必须有一种平台来进行回收。比如说下面将的javascript的执行环境V8就会负责管理代码执行过程中的垃圾回收。 javascript具有自动垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存。原理就是找出那些不再继续使用的变量，然后释放其占有内存。这整个过程也会按照一个固定的事件周期性的整形（时时的话开销太大）。 变量的声明周期刚刚原理中提到要找出不再使用的变量，什么是不再使用的对象呢？不再使用的变量也就是生命周期结束的变量。目前javascript有两种变量，全局变量和在函数中产生的局部变量（暂不考虑ES6中的块级作用域）。 全局变量的声明周期一直持续到浏览器关闭页面才会清除，而局部变量只是在函数执行器存在，而在这个过程中会为局部变量在栈或者堆上分配相应的空间，来存储他们的值，然后当函数要使用这些变量的值时再取出来使用。一直到函数结束（闭包会不同）。 一旦函数结束，局部变量就不需要了，这时候就可以释放他们的内存。12345var globalVariable = \"I'm global\";function test()&#123; var localVariable = \"I'm local\";&#125;test(); 这个例子里面，global在关闭浏览器时释放，local在函数test结束后，释放。 具体看下垃圾回收的两种回收机制。 js的两种回收机制标记清除（mark and sweep）从语义上理解就比较好理解了，大概就是当变量进入到某个环境中的时候就把这个变量标记一下，比如标记为“进入环境”，当离开的时候就把这个变量的标记给清除掉，比如是“离开环境”。而在这后面还有标记的变量将被视为准备删除的变量。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上的标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作。销毁那些带标记的值并回收它们所占用的内存空间。 这是javascript最常见的垃圾回收方式。至于上面有说道的标记，到底该如何标记？好像是有很多方法，比如特殊位翻转，维护一个列表什么的。 引用计数（reference counting）引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个时候的引用类型的值就会是引用次数+1了。如果同一个值又被赋给另外一个变量，则该值的引用次数又+1。 相反如果包含这个值的引用的变量又取得另外一个值，即被重新赋了值，那么这个值的引用就减一。当这个值的引用次数编程0时，表示没有用到这个值，这个值也无法访问，因此环境就会收回这个值所占用的内存空间回收。这样，当垃圾收集器下次再运行时，它就会释放引用次数为0的值所占用的内存。 但是刚刚也说了，第一种标记清除是最经常用到的，那么这个看起来这么好的引用计数为啥不被别人用了呢？ 因为这个过程中会出现一个循环引用的问题! 简单点来说就是一个对象小a的属性，引用了对象小b。小b对象也有一个属性引用了小a,那么小a,小b互相引用对方，也就造成了循环引用的问题啦。 煮个栗子：123456function test()&#123; var a = &#123;&#125;; var b = &#123;&#125;; a.property = b; b.property = a;&#125; 这就是一个很明显的循环引用了，小a和小b通过各自的属性互相引用，导致了内存无法释放。（有那么一点点的感觉像死锁。。。。）即使是再test()执行完后，如果使用标记清除是没有问题的，离开环境的时候就会被清除。但是引用计数不行，因为这两个对象的引用次数还是存在，不会变成0，所以其占用空间也不会清理，如果这个函数被调用多次，就会不断有内存被占用。造成了内存泄露。 IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM(Component Object Model)对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。 因此即使IE的js引擎是用的标记清除来实现的，但是js访问COM对象如BOM,DOM还是基于引用计数的策略的，也就是说只要在IE中设计到COM对象，也就会存在循环引用的问题。 比如说第一种情况：一个DOM元素和一个原生的js对象之间的循环引用1234567var ele = document.getElementById(\"ele\");var obj = &#123;&#125;;obj.property = ele;ele.property = obj;//这种情况应该手动设置，在不适用的时候手工断开js和dom元素之间的连接obj.property = null;ele.property = null; 比如第二种情况是闭包的作用域链中包含着一个html元素，那么这个元素无法被销毁123456window.onload = function outerFunction()&#123; var ele= document.getElementById(\"element\"); ele.onclick = function ()&#123; console.log(ele.id); &#125;&#125; 上面这个代码创建了一个作为ele元素处理程序的闭包，而这个闭包则又创建了一个循环引用。y匿名函数中保存了一个outerFunction()的活动对象的引用，因此就会导致无法减少ele的引用。可以改成下面这个： 12345678window.onload = function outerFunction()&#123; var ele= document.getElementById(\"element\"); var id = ele.id; ele.onclick = function ()&#123; console.log(id); &#125; ele = null;&#125; 在上面的代码中，通过把ele.id 的一个副本保存在一个变量中，并且在闭包中引用改变量消除了循环引用。 必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着elem。即使闭包不直接引用ele（比如上面的例子我们不用id），包含函数的多动对象中也依旧会保存一个引用。因此，有必要把ele变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。 javascript与V8引擎垃圾回收机制的好处和坏处好处：大幅简化程序的内存管理代码，减轻程序猿负担，并且减少因为长时间运转而带来的内存泄露问题。 坏处：自动回收意味着程序猿无法掌控内存。ECMAScript中没有暴露垃圾回收的借口，我们无法强迫其进行垃圾回收，更加无法干预内存管理。 node内存管理问题在浏览器中，V8引擎实例的生命周期不会很长（因为我们使用完网站就会把网站关闭），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。 涨知识之V8内存限制Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用。 V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。 总结对js的垃圾回收机制有所了解了，也明白了平常自己写代码的时候肯能会有这些问题，比如COM的循环引用。但是看到IE9的已经把COM变成了真正的js对象，以后应该会越来越好。主要学习和整理自：segmentfault和javascript的高级程序设计。感谢。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"总结圣杯布局和双飞翼布局","slug":"总结圣杯布局和双飞翼布局","date":"2016-03-12T09:02:32.000Z","updated":"2016-12-12T03:01:58.000Z","comments":true,"path":"2016/03/12/总结圣杯布局和双飞翼布局/","link":"","permalink":"http://sevencai.github.io/2016/03/12/总结圣杯布局和双飞翼布局/","excerpt":"","text":"很久以前就知道这两个布局，但一直觉得这两个布局有点奇怪，可能是因为以前没有用过这种方法。但是因为兼容会很好，而且可以自适应中间区块，所以好像还是很多人用。今天动手写了demo，虽然比较容易就能做出来，但这里面的有些地方还是感觉怪怪的，最后有我的不明白的地方。下面是具体的两种写法以及区别。 圣杯布局圣杯布局是一种常用的网页布局，他可以由现有的技术来实现，现有的布局多多少少都有些缺点，所以找到一种最优的实现方法就好像寻找难以捉摸的圣杯一样。注意下这里left和center的位置放置。其实主要思想就是让三列布局都浮动后，设置中间浮动的元素的宽度为100%，利用padding留出两边left和right的距离，再利用定位的思想把左右两个盒子放在该放的位置上。 1234567&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435body&#123; min-width: 640px; /*两倍的左边距离加上右边距离，如果不加，当resize窗口的时候会出现问题*/&#125;.header,.footer&#123; background: red; height: 50px;&#125;.container&#123; padding-left: 220px; padding-right: 200px;&#125;.center,.left,.right&#123; float:left; min-height: 500px; position:relative;&#125; .center&#123; width:100%; background: yellow; opacity: 1;&#125;.left&#123; width:220px; background: lightgreen; margin-left: -100%; right:220px;&#125;.right&#123; width:200px; background: blue; margin-right: -200px;&#125;.footer&#123; clear:both;&#125; 双飞翼布局双飞翼布局由淘宝UED提出来。如果把三栏布局当做一个大鸟的话，可以吧main当做鸟的身体，sub和extra当做鸟的两个翅膀，这个布局的实现思路是先把最重要的身体部分放好，然后再将翅膀移动到适当的地方。是在圣杯布局上的修改，不再使用relative和padding,改用直接添加一个元素inner，并用margin来实现。之所以这么改我猜是因为一旦我们设置了relative就很难再对其做别的定位。主要代码如下：这里添加了inner，设置center为100%以后，再对inner设置margin,这样就可以使内部元素不受影响，不会被盖住。注意注释掉的就是圣杯布局的部分写法。123456789&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"center\"&gt; &lt;div class=\"inner\"&gt;fad&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334body&#123; min-width: 640px;&#125;.header,.footer&#123; background: red; height: 50px;&#125; .center,.left,.right&#123; float:left; min-height: 300px; /*position:relative;*/&#125; .center&#123; background: yellow; width: 100%;&#125;.left&#123; width:220px; background: lightgreen; /*margin-left: -100%; right:220px;*/ margin-left: -100%;&#125;.right&#123; width:200px; background: blue; margin-left: -200px;&#125;.footer&#123; clear:both;&#125;.inner&#123; margin:0px 200px 0px 220px;&#125; 我的疑问疑问1，正常情况下，如果盒子非浮动，margin-left设置成-9000px（举个例子），就会隐藏了，但是因为这个里面的center是浮动的，所以当left的margin-left设置成比自身宽度要宽的时候就会往上移，也就形成了圣杯布局，可以用chrome不断缩小margin-left的值试试，开始是隐藏，一旦大于自身宽度就会往上了。可是为什么是呢？疑问2，按道理来说左边和右边是固定的宽度，为什么我缩小到一定的程度的时候，是右边先减少宽度，中间减少宽度，最后才是左边减小宽度，而不是中间先减小宽度呢？","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"HASH 哈希","slug":"HASH-哈希","date":"2016-03-12T02:02:02.000Z","updated":"2016-03-12T02:15:04.000Z","comments":true,"path":"2016/03/12/HASH-哈希/","link":"","permalink":"http://sevencai.github.io/2016/03/12/HASH-哈希/","excerpt":"","text":"生活中的hash应用安全领域的hash值比如计算机的登陆密码，一般是一串字符。然而，为了安全起见，计算机不会直接保存该字符串，而是保存该字符串的hash值(使用MD5、SHA或者其他算法作为hash函数)。当用户下次登陆的时候，输入密码字符串。如果该密码字符串的hash值与保存的hash值一致，那么就认为用户输入了正确的密码。这样，就算黑客闯入了数据库中的密码记录，他能看到的也只是密码的hash值。上面所使用的hash函数有很好的单向性：很难从hash值去推测键值。因此，黑客无法获知用户的密码。 注意，hash只要求从A到B的对应为一个映射，它并没有限定该对应关系为一一映射。因此会有这样的可能：两个不同的键值对应同一个hash值。这种情况叫做hash碰撞(hash collision)。比如网络协议中的checksum就可能出现这种状况，即所要校验的内容与原文并不同，但与原文生成的checksum(hash值)相同。再比如，MD5算法常用来计算密码的hash值。已经有实验表明，MD5算法有可能发生碰撞，也就是不同的明文密码生成相同的hash值，这将给系统带来很大的安全漏洞。 哈希的几个概念哈希表：Hash Table，也叫散列表，是根据关键码值(Key Value)而直接进行访问的的一种数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。 哈希函数：hash操作其本质上就是将一个数据映射成另一个数据，通常情况下原数据的长度比hash后的数据容量大。这种映射的关系我们叫做哈希函数。或者这个函数叫做散列函数，存放记录的数组叫做散列表。 为什么会用到hash数组的优点是可以快速寻址，但是增加和删除元素确很难。 链表的优点是可以方便的增加和删除元素，但是确不是很方便寻址。 hash表就是这两种办法的优化，是一种即寻址容易并且删除和增加元素也比较方便的数据结构。 哈希表使用范围：快速查找，删除的基本数据结构O(1),通常需要将总数据量放入内存 应用举例这是我看到的一个非常非常好的例子。一定要学下来。题目是： 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 这个题首先可以这样分析：要统计出最热门的10个查询串，首先要统计每个query出现的次数。然后再是将这些query排序，选择出query次数最大的10个。这样我们就分成两部来做： 首先统计query出现的次数 算法1： 简单排序统计 首先我们最先想到的的算法就是排序了，首先对这个日志里面的所有Query都进行排序，然后再遍历排好序的Query，统计每个Query出现的次数了。 但是题目中有明确要求，那就是内存不能超过1G，一千万条记录，每条记录是255Byte，很显然要占据2.375G内存，这个条件就不满足要求了。 让我们回忆一下数据结构课程上的内容，当数据量比较大而且内存无法装下的时候，我们可以采用外排序的方法来进行排序，这里我们可以采用归并排序，因为归并排序有一个比较好的时间复杂度O(NlgN)。 排完序之后我们再对已经有序的Query文件进行遍历，统计每个Query出现的次数，再次写入文件中。 综合分析一下，排序的时间复杂度是O(NlgN)，而遍历的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(N+NlgN)=O（NlgN）。 如果是js里面我们就可以先生成一个数组，然后每次遍历的时候，就用indexOf查看新的元素是否在新的数组中，这样时间复杂度其实还是o(n)。因为indexof本身也要遍历一次。这个也不好。 算法2：利用Hash Table是一种更好的方法 在第1个方法中，我们采用了排序的办法来统计每个Query出现的次数，时间复杂度是NlgN，那么能不能有更好的方法来存储，而时间复杂度更低呢？ 题目中说明了，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择，因为Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。 那么，我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。 本方法相比算法1：在时间复杂度上提高了一个数量级，为O（N），但不仅仅是时间复杂度上的优化，该方法只需要IO数据文件一次，而算法1的IO次数较多的，因此该算法2比算法1在工程上有更好的可操作性。 2.找出Top 10的query 算法一：普通排序 我想对于排序算法大家都已经不陌生了，这里不在赘述，我们要注意的是排序算法的时间复杂度是NlgN，在本题目中，三百万条记录，用1G内存是可以存下的。 算法二：部分排序 题目要求是求出Top10，因此我们没有必要对所有的Query都进行排序，我们只需要维护一个10个大小的数组，初始化放入10个Query，按照每个Query的统计次数由大到小排序，然后遍历这300万条记录，每读一条记录就和数组最后一个Query对比，如果小于这个Query，那么继续遍历，否则，将数组中最后一条数据淘汰，加入当前的Query。 最后当所有的数据都遍历完毕之后，那么这个数组中的10个Query便是我们要找的Top10了。不难分析出，这样，算法的最坏时间复杂度是N*K， 其中K是指top多少。 算法三：10个query之间利用二分查找 在算法二中，我们已经将时间复杂度由NlogN优化到NK，不得不说这是一个比较大的改进了，可是有没有更好的办法呢？ 分析一下，在算法二中，每次比较完成之后，需要的操作复杂度都是K，因为要把元素插入到一个线性表之中，而且采用的是顺序比较。 这里我们注意一下，该数组是有序的，一次我们每次查找的时候可以采用二分的方法查找，这样操作的复杂度就降到了logK，可是，随之而来的问题就是数据移动，因为移动数据次数增多了。不过，这个算法还是比算法二有了改进。 算法四： 堆排序 基于以上的分析，我们想想，有没有一种既能快速查找，又能快速移动元素的数据结构呢？回答是肯定的，那就是堆。 借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此到这里，我们的算法可以改进为这样，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。 思想与上述算法二一致，只是算法在算法三，我们采用了最小堆这种数据结构代替数组，把查找目标元素的时间复杂度有O（K）降到了O（logK）。 那么这样，采用堆数据结构，算法三，最终的时间复杂度就降到了N*logK，和算法二相比，又有了比较大的改进。 总结： 至此，算法就完全结束了，经过上述第一步、先用Hash表统计每个Query出现的次数，O（N）； 然后第二步、采用堆数据结构找出Top 10，N*O（logK）。 所以，我们最终的时间复杂度是：O（N） + N&apos;*O（logK）。（N为1000万，K为300万）。 最后一个例子学习记录自：Frank Fan||非常谢谢。整体来说对hash有了进一步的了解，发现以前自己用过hash确没有认出来是hash。js里的hash就可以定义一个对象{}，例如{“query1”:30,”query2”:20}这样就可以把值存入键，把次数存入值。当我判断一个query是否在hash里面的时候，可以直接hash[query]如果在的话就将次数加1。关于散列函数和散列冲突方法会接着学习。","categories":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/tags/算法/"}]},{"title":"今日算法小练习，排序与查找","slug":"今日算法小练习，排序与查找","date":"2016-03-11T14:31:35.000Z","updated":"2016-03-11T14:33:28.000Z","comments":true,"path":"2016/03/11/今日算法小练习，排序与查找/","link":"","permalink":"http://sevencai.github.io/2016/03/11/今日算法小练习，排序与查找/","excerpt":"","text":"从小做起，以后每天定时写几个js算法，并且做总结打卡。今天写了几个简单的排序和查找，还买了一本书，《算法导论》，接下来的2个月的目标就是它啦，加油。 快速排序快速排序的思想是分治，比如这里[3,4,1,5,6,9]这样一个数组，先选一个轴，比如说是起点，然后先从右向左找到比这个轴小的数，并把这个小数覆盖掉轴的位置。这时候原来小数的位置可以当成是空，然后再以轴为中心从左往右找，找到比轴大的数，再把这个数覆盖原来轴所在的位置。算法复杂度最差是$$n^2$$，最好是nlogn。 123456789101112131415161718192021222324function quickSort (arr,l,r) &#123; var left = l,right = r; var key = arr[l]; if(left &lt; right)&#123; while(left &lt; right)&#123; while(left&lt;right &amp;&amp; key &lt; arr[right])&#123; right--; &#125; arr[left] = arr[right]; while(left&lt;right &amp;&amp; key &gt; arr[left])&#123; left++; &#125; arr[right] = arr[left]; &#125; arr[right] = arr[left]; quickSort(arr,l,left-1); quickSort(arr,r+1,right); &#125; &#125;var arr = [3,4,1,5,6,9];quickSort(arr,0,5);console.log(arr); 两种数组去重方法第一种利用indexOf,直接每次在新数组里查找是否有值，如果有则不push进入。否则push进入。1234567891011function unique (arr) &#123; var newArr = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [3,2,5,6,7,6,7,2];console.log(unique(arr)); 第二种利用hash，来生成一个键值对，用来存储已经有了的数。1234567891011121314function unique (arr)&#123; var newArr = []; var hash = &#123;&#125;; for(var i = 0;i&lt;arr.length;i++)&#123; if(!hash[arr[i]])&#123; newArr.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return newArr;&#125;var arr = [3,2,5,6,7,6,7,2];console.log(unique(arr)); 二分查找二分查找没什么说的，就是3个指针，分别每次从一半来查找，前提是数组已经排号序。logn是其算法时间复杂度。1234567891011121314151617181920function bSearch (arr,n,left,right)&#123; var mid; while(left&lt;=right)&#123; mid = parseInt((left+right)/2); if(n == arr[mid])&#123; return mid; &#125;else if(arr[mid]&lt;n)&#123; left = mid + 1; &#125;else if(arr[mid]&gt;n)&#123; right = mid - 1; &#125; &#125; return 0;&#125;var arr = [0,3,5,7,11,14];var x = bSearch(arr,5,0,5);console.log(x);","categories":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://sevencai.github.io/tags/算法/"}]},{"title":"js小例子之自定义右键菜单和jquery拖动元素","slug":"js小例子之自定义右键菜单和jquery拖动元素","date":"2016-03-11T06:11:52.000Z","updated":"2016-12-12T03:00:46.000Z","comments":true,"path":"2016/03/11/js小例子之自定义右键菜单和jquery拖动元素/","link":"","permalink":"http://sevencai.github.io/2016/03/11/js小例子之自定义右键菜单和jquery拖动元素/","excerpt":"","text":"总结两个小实例，一个是jquery拖动元素，一个是js自定义右键菜单。感觉jquery的API都快忘了，所以又写了个jquery的。 js自定义右键菜单我大概的想法是先隐藏列表菜单，当监听到oncontextmenu时，显示列表并定位到鼠标点击的地方。当页面有点击事件的时候，再来让列表显示。 这里可以用preventDefault或者return false；来阻止右键的默认行为。 代码如下：12345&lt;ul id=\"menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;menu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;menu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;menu1&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425&lt;script&gt; var menu = document.getElementById(\"menu\"); menu.style.display = \"none\"; document.oncontextmenu = function(event)&#123; event = event || window.event; var top = event.clientY; var left = event.clientX; console.log(top + \"Hello\" +left); menu.style.top = top + \"px\"; menu.style.left = left + \"px\"; menu.style.position = \"absolute\"; menu.style.display = \"block\"; event.preventDefault(); &#125; document.onclick = function(event)&#123; menu.style.display = \"none\"; &#125;&lt;/script&gt; 我老是忘记eft,top加后面的px单位。这个要注意。 jquery拖动元素原理是一样的。首先对可以拖动的元素进行监听鼠标点下事件，然后获得点击位置距离点击元素的偏移量。最后再对这个鼠标移动时间进行监听，并把元素定位到该有的位置。最后当鼠标点击的时候一定要取消绑定mousemove事件。123&lt;div class=\"dragObj\"&gt; drag div&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839$(document).ready(function()&#123; var mouseX=0,mouseY=0, offsetX,offsetY; $(\".dragObj\").mousedown(function(event) &#123; event = event || window.event; console.log(\"aa\"); mouseX = event.clientX; mouseY = event.clientY; var offset = $(this).offset(); var targetX = parseInt(offset.left,10); var targetY = parseInt(offset.top,10); offsetX = mouseX - targetX; offsetY = mouseY - targetY; $(this).bind(\"mousemove\",dragElement); &#125;); function dragElement(e)&#123; var left = e.clientX - offsetX; var top = e.clientY - offsetY; $(this).css(&#123; \"position\":\"absolute\", \"left\":left+\"px\", \"top\":top + \"px\" &#125;); return false; &#125; $(document).mouseup(function(event) &#123; console.log(\"b\"); $(\".dragObj\").unbind(\"mousemove\"); &#125;);&#125;)","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"http真的是阻塞的吗？","slug":"http真的是阻塞的吗？","date":"2016-03-10T14:49:34.000Z","updated":"2016-12-12T02:28:46.000Z","comments":true,"path":"2016/03/10/http真的是阻塞的吗？/","link":"","permalink":"http://sevencai.github.io/2016/03/10/http真的是阻塞的吗？/","excerpt":"","text":"今天总结我的一个错误，有个面试官问我优化的方法，然后我提到了以前在慕课网上有做的精灵小游戏，里面用到了css sprites。通过把多张小图合并成一张小图，利用position和background-image,就可以减少http的请求，从而减少页面加载时间。然后他问我，为啥可以减少页面加载的时间。我说因为http请求需要花费大量的事件，而且会在请求头里面包含很多不必要的信息,而且http是阻塞的，导致一个请求如果没有应答，就会导致后面的请求阻塞排队。然后这个时候棒棒的面试官又问我，http是阻塞的吗？我当时一直这么认为了好久，然后就肯定的说是的。后来他又问了我，说有没有注意到百度图片的时候是一张一张的加载还是一排一排的加载。我以前看过是一排一排的加载。这个时候面试官又说那为什么会是一排一排的加载的？你不是说是阻塞的吗？然后，，，后来他告诉了我，http是可以开多个线程的，可以并行加载。下面是我找的解释和我的理解。 http1.0和http1.1的区别 访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。 比如一个网页它有10个资源，比如js文件，css文件，图片文件，在http1.0中这个是首先建立一次tcp链接，然后请求一个http，然后下载第二个文件又建立一次tcp链接，再请求一个http,这样下去，一直到第10个文件。这样tcp在每次连接和断开的时候都要进行三次握手和四次挥手。这当然是费时费性能。 为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。 上面提到的不用等待上次的请求结果，就可以发出下一次请求也就是http1.1的不阻塞现象了。总结上面两个特点一个是支持了持久长连接，还有一个是http可以并行请求不阻塞。 另外：HTTP/1.1流水线只能部分地解决了并发的请求，并从线头的阻塞受到影响。 因此，需要进行多次请求客户端通常使用多个连接到服务器，以减少等待时间。 还有，HTTP/1.1的报头字段经常重复和冗长，其中，除了产生更多或更大的网络数据包，可能会导致小的初始TCP拥塞窗口来快速填充。 这可能会导致过度的延迟，当多个请求在一个新的TCP连接进行。 涨知识HTTP2.0的服务器推送 HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 当浏览器请求一个html，服务器其实大概知道你是接下来要请求资源了，而不需要等待浏览器得到html后解析页面再发送资源请求 所有的HTTP2.0的请求都在一个TCP链接上 HTTP2.0所有通信都是在一个TCP连接上完成。HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应 着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。就好比，我请求一个页面http://www.qq.com。页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！HTTP性能的关键在于低延迟而不是高带宽！大多数HTTP 连接的时间都很短，而且是突发性的，但TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用TCP 连接，让高带宽也能真正的服务于HTTP的性能提升。 HTTP/2提供更多的加密支持现在，大多数普通用户的设备和网络服务器之间的网络通道并没有被加密，除非站点选择使用HTTP的升级版——HTTPS，后者包括一个名为“传输层安全”的加密步骤。银行、电子商务站点、谷歌等一般会使用这一协议（如果一个站点以“https://”开头，表示它已使用这一协议）。 增加头压缩它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 关于ICMPICMP是(Internet Control Message Protocol)Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP是Internet 控制信息协议（ICMP）是 IP 组的一个整合部分。通过 IP 包传送的 ICMP 信息主要用于涉及网络操作或错误操作的不可达信息。 ICMP 包发送是不可靠的，所以主机不能依靠接收 ICMP 包解决任何网络问题。ICMP不象TCP或UDP有端口，但它确实含有两个域：类型(type)和代码(code)。而且这些域的作用和端口也完全不同。Ping用到的是ICMP协议。不是端口。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"页面重流和回流以及优化的整理和学习","slug":"页面重流和回流以及优化的整理和学习","date":"2016-03-09T11:00:24.000Z","updated":"2016-12-12T03:02:36.000Z","comments":true,"path":"2016/03/09/页面重流和回流以及优化的整理和学习/","link":"","permalink":"http://sevencai.github.io/2016/03/09/页面重流和回流以及优化的整理和学习/","excerpt":"","text":"浏览器从下载文档到显示页面的过程是个复杂的过程，这里包含了重绘和重排。各家浏览器引擎的工作原理略有差别，但也有一定规则。简单讲，通常在文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。 渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器 就可以将元素放置到正确的位置了，再根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用 table做布局的一个原因。 页面重绘Repaint,页面重排Reflow具体解释如下： 页面重绘Repaint重绘发生在一个元素的外观被改变，但是整体的布局没有发生变化。比如我们如果只改变了visibility和outline,background,color之类的。 在这个时候浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 页面重排Reflow页面重排发生在我们改变了DOM元素的几何属性，比如我们给一个元素加了border,或者width,height发生了变化，或者我们突然让它float了这些。再比如，我们改变了文字的大小，改变了文字内容。 具体的一些总结如下： 添加或者删除可见的DOM元素 元素位置改变 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 这些时候浏览器会重新计算元素的属性，会使渲染树中受到影响的部分失效，并且会验证DOM树上的所有节点的visibility属性。这样肯定会造成很大的低效。如果我们重排太过于频繁的话，浏览器肯定就又占用了很多cpu。 刚刚提到了我们重排的时候会验证DOM树上的所有属性，这又是为啥呢？ 当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重建构建渲染树中失效的节点。之后，会根据新的渲染树重新绘 制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点的重排， 祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系列的反 应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 举个例子以区别重绘和重排12345678var s = document.body.style;s.padding = \"2px\"; // 回流+重绘s.border = \"1px solid red\"; // 再一次 回流+重绘s.color = \"blue\"; // 再一次重绘s.backgroundColor = \"#ccc\"; // 再一次 重绘s.fontSize = \"14px\"; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!')); 如果答对了，就证明已经可以区分重绘和重排了。再来仔细看下，上面的时候我们把节点插入到了body最后，那么我们为什么不插入到最前面呢？因为插入到后面不一定会影响到前面，但是插入前面就一定会影响到后面。 解决方案？浏览器自身的优化从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 将多次改变样式属性的操作合并成一次操作比如说把1234var changeDiv = document.getElementById('changeDiv'); changeDiv.style.color = '#093'; changeDiv.style.background = '#eee'; changeDiv.style.height = '200px'; 变成为：123456div.changeDiv &#123; background: #eee; color: #093; height: 200px;&#125;document.getElementById('changeDiv').className = 'changeDiv'; 通过这种方式我们也减少了重绘和重排的次数。 让改变的元素不影响别的元素将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 先拼接html代码在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。 缓存到变量在需要经常取那些引起浏览器重排的属性值时，要缓存到变量。比如说如果用到多次getElementById(“id”)就把这个变量先存起来。 display:none法由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 补充页面的重构这个跟上面的一样是优化，但是是完全不同的额，我弄错了先前。 代码重构（英语：Code refactoring）重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。比如我们写完网站的时候，就可以重新看下整个网站是不是有很多不必要的标签，或者语义化不是很好。 总结上面我们知道了 Reflow 有时确实不可避免，所以只能尽可能限制Reflow的影响范围。我觉得最棒的地方在这几种解决方法里，比如说display:none和float方法，我可能不会想到。谢谢这几篇文章：from张鑫旭和from独占神话","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"javascript事件委托","slug":"javascript事件委托","date":"2016-03-04T10:27:04.000Z","updated":"2016-12-12T03:00:30.000Z","comments":true,"path":"2016/03/04/javascript事件委托/","link":"","permalink":"http://sevencai.github.io/2016/03/04/javascript事件委托/","excerpt":"","text":"先举个现实生活中委托的例子。比如有3个人在同一个公司里，星期天他们得知他们的快递都要来。如果不用委托，意味着这三个人都要去一次楼下，而且要一直等，直到他们的快递来。但是我们知道公司都是有前台的，所以一般快递公司都是把东西直接放到前台，然后由前台打电话让他们来领取。这里的前台服务就是委托。 在比如电商的模式（如淘宝），如果没有淘宝，大家都要一家一家的去看衣服，找衣服，买衣服。但是有了淘宝的这种类似委托模式，我们只需要用手机进入淘宝就可以去找衣服，买衣服。 同样一个道理，一般来说我们如果要监听一个事件，就直接addEventListerner。但我们知道在javascript中，添加到页面上的事件处理程序是直接影响到整个页面的性能。当我们有很多事件要监听时，我们一个个的获取元素并监听就显然不是好的方法啦。具体的弊端有： 首先，每个都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致DOM访问次数，会延迟整个页面的交互就绪时间。 这个时候我们就要用到javascript事件委托。 先举个事件委托的例子123456&lt;ul id=\"parent\"&gt; &lt;li id=\"1\"&gt;trigger event1&lt;/li&gt; &lt;li id=\"2\"&gt;trigger event2&lt;/li&gt; &lt;li id=\"3\"&gt;trigger event3&lt;/li&gt; &lt;li id=\"4\"&gt;trigger event4&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819var obj = document.getElementById(\"parent\");obj.addEventListener(\"click\",function(event)&#123; var event = event || window.event; var target = event.target || event.srcElement; if(target &amp;&amp; target.nodeName == \"LI\")&#123; switch(target.id)&#123; case '1': console.log(\"first event\"); break; case '2': console.log(\"second event\"); break; default: console.log(\"fifth event\"); &#125; console.log(event.target.id+\" was triggered\"); &#125;&#125;) 比如在这个例子里，我要对1234个ul添加事件，一般的方法就是addEventListener。但我们通过委托，只声明了一个变量obj，只用了一个事件监听器。方法是我们监听父元素parent。由于事件冒泡机制，当parent监听的事件发生是，获取target对象，然后内部再对target进行处理。 javascript事件委托的优点1、document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。 2、在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。 3、整个页面占用的内存空间更少，能够提升整体性能。 总结事件委托使用事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件，并做相应的处理。 回顾事件冒泡和事件捕获（javascript的事件传播过程）Netscape定义了一种叫做事件捕获的处理方法，事件首先发生在 DOM树的最高层对象(document)然后往最深层的元素传播。如：事件捕获首先发生在document上，然后是html元素，body元 素，最后是button元素。 IE的处理方法正好相反。他们定义了一种叫事件冒泡的方法。事件冒泡认为事件促发的最深层元素首先接收事件。然后是它的父元素，依次向上，知道 document对象最终接收到事件。尽管相对于html元素来说，document没有独立的视觉表现，他仍然是html元素的父元素并且事件能冒泡到 document元素。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"HTML5 Drop and Drag API学习与整理","slug":"HTML5 Drop-and-Drag-API学习与整理","date":"2016-03-03T14:20:52.000Z","updated":"2016-12-12T03:00:22.000Z","comments":true,"path":"2016/03/03/HTML5 Drop-and-Drag-API学习与整理/","link":"","permalink":"http://sevencai.github.io/2016/03/03/HTML5 Drop-and-Drag-API学习与整理/","excerpt":"","text":"Drop和Drag是能够DOM元素拖动与释放的API。过去我们也有一个能够实现拖动与释放的流程。今天总结一下，可以看到新的API是给我们提供了很大的便利和简化了许多代码的。 拖拽的旧方法总的是下面下面的三个流程：（js以前是没有直接拖拽的方法的，所谓的拖拽也就是把鼠标拖拽的偏移值赋值给拖动的元素，这样就好像形成一个假象，我是可以拖拽的，实际上该元素就是我们硬性规定他的新新位置的） 通过mousedown事件捕获DOM元素 通过mousemove事件来移动DOM元素 通过mouseup事件来释放DOM元素 我们在拖拽元素时，要计算该元素距离浏览器的top值和left值，当我们获得这个值后，我们再直接给他定位。获得这个top和left需要我们计算，我们很容易算出上图中红色线的距离，利用e.clientX和e.clientY，就可以获得点击该元素时，该点的位置，然后我们再算出该元素距离顶部和底部的距离，相减就可以得到鼠标距离该拖动对象的距离。 具体代码如下：先定义一个可拖动对象，并给其父框加入对应的样式（做完以后可以试试如果main的absolute去掉会怎么样）：123456789101112//CSS.main&#123; position:absolute; overflow:hidden; width:500px; height:500px; border:1px solid red;&#125;//DOM&lt;div class=\"main\"&gt; &lt;img src=\"./face.png\" alt=\"drag\" id=\"item\"&gt;&lt;/div&gt; 下面是js代码，对应解释以下几点： 两个对象dragObj是拖动对象，mouseOffset是鼠标距离对象的偏移量。 要给document加入onmousemove事件，而不是给对应的obj,否则会页面抖动。 mouseup是用来释放对象，用来结束拖动，设置拖动对象为空。 设置mousePoint对象是为了使用的时候更加方便。直接以对象属性的形式访问。 getMousePos是用来获得鼠标偏移量的。 mousemove用来计算位置并定位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var dragObj = null;var mouseOffset = null;document.onmousemove = mousemove;document.onmouseup = mouseup;function mouseup (e)&#123; dragObj = null;&#125; function mousePoint (x,y)&#123; this.x = x; this.y = y;&#125;function getMousePos (e) &#123; var x = parseInt(e.clientX); var y = parseInt(e.clientY); return new mousePoint(x,y);&#125;function getMouseOffset(target,e)&#123; e = e || window.event; var mousePos = getMousePos(e); var x = mousePos.x - target.offsetLeft; var y = mousePos.y - target.offsetTop; return new mousePoint(x,y);&#125;function mousemove (e)&#123; if(!dragObj)&#123; return; &#125; e = e || window.event; var mousePos = getMousePos(e); if(dragObj)&#123; console.log(\"entermousemove\"); dragObj.style.position = \"absolute\"; dragObj.style.left = mousePos.x - mouseOffset.x + \"px\"; dragObj.style.top = mousePos.y - mouseOffset.y + \"px\"; return false; &#125; &#125; function startdrag (item)&#123; if(item)&#123; item = document.getElementById(item); item.onmousedown = function(e)&#123; dragObj = this; mouseOffset = getMouseOffset(this,e); return false; &#125; &#125;&#125;window.onload = startdrag('item'); 新方法的拖拽 上面的这种方法代码比较复杂，新的API,通过dragstart和drop等添加高度抽象的事件。就能够实现更为直观的拖动与释放操作。同时，由于拖动过程中基本的显示更新处理也都是教给浏览器处理，我们开发人员就可以将精力集中于程序。 为什么已经有很丰富的拖拽库了，我们还要用Drag Drop API呢因为在这些API中有一个叫做DataTransfer的API。它用来给拖动操作中的数据接收与传递提供支持。它并未限定数据的发送方和数据的接收方限定在一个窗口。比如：可以讲桌面上的文件拖拽到浏览器，讲DOM元素拖拽到文本编辑器。这个它消除了web应用程序与原生的应用的界限。 先煮个例子12&lt;div id=\"dragElement\" class=\"element\" draggable=\"true\"&gt; drag me &lt;/div&gt;&lt;div id=\"dropElement\" class=\"element\"&gt; drop here &lt;/div&gt; 12345678910111213141516171819202122var dragElement = document.getElementById(\"dragElement\");var dropElement = document.getElementById(\"dropElement\");dragElement.ondragstart = function(e)&#123; e.dataTransfer.setData(\"text/plain\",e.target.textContent);&#125;dropElement.ondragover = function(e)&#123; //zhe if(e.dataTransfer.types == \"text/plain\")&#123; //取消浏览器默认操作（浏览器默认操作时将drop事件取消，所以这里必须取消默认操作） e.preventDefault(); &#125;&#125;dropElement.ondrop = function(e)&#123; //取消浏览器默认操作 e.preventDefault(); //获取所拖动时设置的数据 var dragData = e.dataTransfer.getData('text/plain'); console.log(dragData);&#125; 在上面这个例子中我们就获得了drag里面的值并且输出到了控制台。这个数据发送方也就是拖动的元素与接收方也就是释放的区域是一种松耦合的关系。通过对这两个区域分别实现你想要的事件处理程序就能够完成操作。 下面是具体的讲解上面我们也看到了给drag设置了draggable=true，要让特定的元素支持被拖动，需要将元素设置为true,当然如果该元素如img,a本来默认就可以拖动，就不用写了。其他的值还可以设置成false,auto。 下面是设定拖动区域与设防区域的事件处理程序的API 能够拖动元素的事件处理程序dragstart 在拖动操作时被触发 drag 在拖动操作中被**定期**触发 dragend 在拖动操作结束时被触发 能够设定释放区域的事件处理程序dragenter 拖动操作中，进入DOM元素的领域时被触发 dragover 拖动操作中，处于DOM元素的领域内被定时触发 dragleave 拖动操作中，离开DOM元素领域时触发 drop 在DOM元素上释放时触发 关于DataTransfer它的功能有： 数据的接收 数据处理方式的指定 拖动图像的设定 下面是具体的属性和方法概览： setData(format,data) 以format所指定的格式添加数据（只在dragstart中有效） getData(format) 以format所指定的格式获取数据（只在drop事件中有效） clearData([format]) 以format所指定的格式清除数据，如果没有指定format,则清除所有数据 types属性 包含正在拖动数据的format的数组 files属性 包含正在拖动文件的File对象数组 setDragImage(element,x,y) 设定拖动的图像（在dragstart中有效） adddElement(element) 设定拖动的图像（在dragstart中有效） effectAllowed 设定允许用于拖动操作的目标效果。通常会在dragstart事件中设定 dropEffect 设定操作的目标的效果，或由用户选择的效果。系统会在copy,move,link,none中选择。并根据院中的效果显示相应的拖动对象。 上面setDragImage和addElement的区别是什么？区别在于拖动图像的显示位置不同。setDragImage以拖动图像的左上角为拖动位置，并可以通过x,y坐标来调整位置。而addElement则将整个容器作为拖动对象。12345&lt;div id=\"container\" draggable=\"true\"&gt; &lt;div id=\"dragElement\" draggable=\"true\"&gt; &lt;/div&gt;&lt;/div&gt; 123456var dragObj = document.getElementById(\"dragElement\"), container = document.getElementById(\"container\");dragObj.ondragstart = function(event)&#123; event.dataTransfer.addElement(container);&#125; 关于文件的drag-in–drag-out我们先前提到了通过DataTransfer的一些优点，数据的发送方和数据的接受方并未限定于同一个窗口。比如dataTransfer的files属性以通过拖动操作来获取桌面的程序的文件。尽管要获取的是一个文件。我们只需要现在释放区域的dragover中执行preventDefault既可以。 第一个例子（files.length）123&lt;div id=\"drop\"&gt; drop here&lt;/div&gt; 获得释放区后，监听释放操作并做处理。12345678910111213141516var elem = document.getElementById(\"drop\");elem.ondragover = function(e)&#123; e.preventDefault();&#125;elem.ondrop = function(e)&#123; //通过files.length来判别是否拖动了对象 //也就是说一次可以拖动多个文件(File对象) if(e.dataTransfer.files.length)&#123; alert(\"你拖动了文件\"); var file = e.dataTransfer.files[0]; console.log(file); &#125; event.preventDefault();&#125; 第二个例子将文件保存至桌面可以通过拖动操作来把文件从浏览器中保存至桌面升序的方法。可以按照下列的格式，将数据设置于dataTransfer,以实现通过拖动操作讲文件从浏览器保存至桌面程序。1event.dataTransfer.setData(\"DownloadURL\",\"MIMETYPE:文件名:文件URL\"); 通过这个功能，就能够实现与原声应用之间的双向文件收发。使桌面环境中运行的Web应用程序的实用性得到了飞跃性的提高。下面的是一个文件下载的实例。 12&lt;a href=\"http://www.example.com/foo.mp3\" data-downloadurl=\"audio/mpeg:foo.mp3:http://example.com/foo.mp3\" class=\"dragObj\" draggable=\"true\"&gt;download mp3&lt;/a&gt;&lt;a href=\"http://www.example.com/bar.pdf\" data-downloadurl=\"application/pdf:bar.pdf:http://example.com/bar.pdf\"&gt;download pdf&lt;/a&gt; 先利用querySelectorAll来获得所有的drag对象。然后监听dragstart事件。然后setData下载。 123456var files = document.querySelectorAll(\".dragObj\");for(var i=0;i&lt;files.length;i++)&#123; file.addEventListener(\"dragstart\",function(e)&#123; e.dataTransfer.setData(\"DownloadURL\",this.dataset.downloadurl); &#125;,false);&#125;","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"我理解的TCP的三次握手和四次分手","slug":"我理解的TCP的三次握手和四次分手","date":"2016-03-03T14:12:54.000Z","updated":"2016-12-12T02:53:56.000Z","comments":true,"path":"2016/03/03/我理解的TCP的三次握手和四次分手/","link":"","permalink":"http://sevencai.github.io/2016/03/03/我理解的TCP的三次握手和四次分手/","excerpt":"","text":"这学期就开始学网络啦，下下个星期就开课。看看我理解的TCP/IP的三次握手和四次挥手。顺便也总结了一下当用户输入网址的过程中发生了什么。以及关于HTTP的一些基本知识。 首先我的理解：三次握手： 客户端首先请求说我要请求你的服务器上的资源。 服务器说好我知道啦。 这时候客户端收到了服务器的响应又对服务器说我收到啦，谢谢。 此时建立连接，可以开始传送数据了，这就是三次握手。 四次挥手：可以是服务器先说分手或者是客户端。比如客户端说： 我这里没有请求了，你可以等把你的东西发完咱们就分手。 服务收到消息后说，好的，我把手边的东西发完咱们就分手哈。 等服务器发完手边的东西跟客户端说：我发完了，可以分手了。 这时候客户端收到说：好哒，收到，咱们分手吧。。。。 至此为止客户端和服务器端的链接就断开了。 当然不能像我理解的简单三次握手OSI参考模型中的网络层，在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 SYN-ACK 重传次数：服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。 半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。 四次挥手 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是 当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 TCP采用四次挥手关闭连接如图所示为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建 连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅 表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之 后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 意思就是：客户端告诉服务器我没有数据发送给你了，但不代表此时服务器此时已经把所有的数据都发送给客户端了，所以需要等到服务器发送完所有的数据，主动发送报文告诉客户端，我这里的数据也发送完了。这个时候客户端知道了服务器端数据发送完了。两边都清楚，就可以断开连接。 为什么要进行TCP连接首先看下http的网络层次： 在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。 HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程也就需要上面所谓的“三次握手”。 在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。比如一个页面一共需要20个http请求：这上面20个HTTP请求，只依靠一个TCP连接就够了，这就是所谓的持久连接。也是所谓的一次HTTP请求完成。一直到没有http请求，四次挥手断开连接。 建立一次http请求的过程我的想法是：当用户接受用户输入后，首先教给DNS解析对应的IP,并发送给相应的服务器。然后客户端向服务器发送请求改网址网页，服务器收到后，向客户端返回网页信息。浏览器得到后把得到的网页从字节编程一个个的Token，然后渲染成DOM tree。浏览器渲染页面，并异步加载网页中通过异步的方式加载的javascript,css等文件资源。 当用户输入网页 URL 的时候，WebKit 调用其资源加载器加载该 URL 对应的网页。 加载器依赖网络模块建立连接，发送请求并接收答复。 WebKit 接收到各种网页或者资源的数据，其中某些资源可能是同步或异步获取的。 网页被交给 HTML 解释器转变成一系列的词语（Token）。 解释器根据词语构建节点（Node），形成 DOM 树。 如果节点是 JavaScript 代码的话，调用 JavaScript 引擎解释并执行。 JavaScript 代码可能会修改 DOM 树的结构 如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前 DOM 树的创建，直到 JavaScript 的资源加载并被 JavaScript 引擎执行后才继续 DOM 树的创建。 上面图1,2来自网络，如有侵权，请告之。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://sevencai.github.io/tags/计算机网络/"}]},{"title":"解决跨浏览器问题的几个代码段总结","slug":"解决跨浏览器问题的几个代码段总结","date":"2016-03-03T08:02:47.000Z","updated":"2016-12-12T03:02:18.000Z","comments":true,"path":"2016/03/03/解决跨浏览器问题的几个代码段总结/","link":"","permalink":"http://sevencai.github.io/2016/03/03/解决跨浏览器问题的几个代码段总结/","excerpt":"","text":"Ajax对象：XMLHttpRequest和IE的ActiveX对象这两种对象的构造函数有两种不同的格式，但却共享了同一种功能和方法。一旦创建完初始的对象并将其赋值给一个对象，也就解决了Ajax的跨浏览器问题。1234567var xmlhttp = false;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); xmlhttp.overrideMimeType('text/xml');&#125;else if(window.ActiveXObject)&#123; xmlhttp = new ActiveXObject();&#125; 实例1-Hello Ajax下面这个就是一个基本的级联的例子，首先获得xmlhttp对象（解决跨浏览器问题），然后发送ajax请求，过程就是open,onreadyStateChange,send。当服务器接收到相应时，就要对相应进行处理，这里就是通过XMLHttpRequest的属性，status=200时表示服务器额的状态一切正常，readyState==4的时候表示响应加载完毕。所以，当一个在请求的就绪状态发生改变时就调用onreadyStateChange，来处理。12345678910111213141516171819202122232425var xmlhttp = false;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest(); xmlhttp.overrideMimeType('text/xml');&#125;else if(window.ActiveXObject)&#123; xmlhttp = new ActiveXObject();&#125;function populateList()&#123; var state = document.forms[0].elements[0].value; var url = \"ajax.php?state=\"+state; xmlhttp.open('GET',url,true); xmlhttp.onreadyStatechange = getCities; xmlhttp.send(null);&#125;function getCities()&#123; var cities = document.getElementById(\"cities\"); if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; cities.innerHTML = \"&lt;select&gt;\"+xmlhttp.responseText + \"&lt;select&gt;\"; &#125;else&#123; cities.innerHTML = \"Error\"; &#125;&#125;populateList(); Ajax也有缺点，这里记录一下：可访问性问题，缺少永久链接问题，浏览历史记录的问题。 尝试获取CSS样式信息 如果说就该style样式比较简单，或者style属性就没有那么简单。如果没有通过Javascrip直接设置属性，或者在元素中使用内联的style属性，即使通过样式表来设置style值，style的属性的值也都是undefined。记住这一点很重要，因为在使用DHTML（动态构建网页）很可能会遇到这个问题。 若要访问样式，你需要使用其他属性，每个属性专门用于不同的类型的浏览器。Microsoft和Opera支持currentStyle属性，而Firefox，Mozilla使用window.getComputedStyle。跨浏览器写法可如下：12345678910function getStyle(obj,jsprop,cssprop)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[jsprop]; &#125;else if(window.getComputedStyle)&#123; return document.defaultView.getComputedStyle(obj,null).getPropertyValue(cssprop); &#125;else&#123; return null; &#125;&#125;alert(getStyle(obj,\"backgroundColor\",\"background-color\")); 看到JAVASCRIPT核心技术上写了这么一段话：在处理动态DHMTL时，一个很好的经验规则是：努力避免从页面样式设置中直接检索信息，相反，只要可能，就使用程序变量来保持值，只是在设置属性时才使用style。我对这个程序变量保持值不是很明白。如果大家有理解，可否在地下留下言？谢谢啦。 opcity元素透明度跨浏览器解决方案元素的透明度由它的opacity不透明度的百分比来决定，Microsoft坚持使用alpha滤镜。其他浏览器如Mozilla都决定采用新的css3标准。因为微软的滤镜使用百分比，而不是使用数字型的值，因此在使用IE时，保存当前opacity不透明度的变量应该乘以100。1234567891011function adjustOpacity()&#123; var img = document.getElementById('img1'); if(img.style.filter)&#123; opacity = opacity*100; img.style.filter = \"alpha(:\"+opacity+\")\"; &#125;else if(img.style.opacity)&#123; img.style.opacity = opacity; &#125;else &#123; alert(\"Opacity not supported\"); &#125;&#125;","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"如何生成多个ssh并将hexo博客布置到github","slug":"如何生成多个ssh并将hexo博客布置到github","date":"2016-02-26T16:34:44.000Z","updated":"2016-12-12T02:52:58.000Z","comments":true,"path":"2016/02/27/如何生成多个ssh并将hexo博客布置到github/","link":"","permalink":"http://sevencai.github.io/2016/02/27/如何生成多个ssh并将hexo博客布置到github/","excerpt":"","text":"昨天是我好朋友的生日。她是一个写东西特别好的人。我一直觉得她写作的才华特别赞。所以就给也用hexo搭建了个博客。我给她申请了个github账号。这就有一个问题：我必须要再生成一个ssh公钥和密钥才能够控制她的github。 生成新的公钥和密钥 生成新的公钥1$ ssh-keygen -t rsa -C \"your-email-address\" 注意这里不能一直按enter键，否则会覆盖原来我的ssh。当出现下面的第一行时，要输入新的ssh的地址并且命名。如下就是将id_rsa_aaa保存在了root/.ssh/下，并命名为id_rsa_aaa。注意window目录下不是root，你要找到你相应的.ssh的地址。如/c/users/username/.ssh/1234Enter file in which to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaaEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa_aaa. 输入后就生成了一个新的ssh。 将公钥拷贝到github这时候需要进入github的settings里面的ssh。并把生成的公钥复制到对应的栏目里。直接vi id_rsa_aaa.pub，就可以编辑复制。 加入ssh agent上把该key加到ssh agent上。由于不是使用默认的.ssh/id_rsa，所以你需要显示告诉ssh agent你的新key的位置1$ ssh-add ~/.ssh/id_rsa_aaa 这时，你可能会报一个错：1Could not open a connection to your authentication agent 此时先执行 eval ssh-agent（是～键上的那个）再执行 ssh-add ~/.ssh/id_rsa_aaa就可以成功。下面可解释原因。 SSH private-keys are usually stored encrypted on the computers they are stored on. A pass-phrase is used to decrypt them when they are to be used. Since most people use SSH public-private key-pairs to get around typing in passwords all the time, the ssh-agent daemon exists to store decrypted private-keys you plan on using in a given session. The thing most people get tripped up on when using ssh-agent is that what the program outputs, some borne or csh shell commands, needs to be run. It may look like ssh-agent has set some variables for you, but it has in fact done no such thing. If you call ssh-add without processing ssh-agent’s output, it will complain it is unable to open a connection to your authentication agent. The most straightforward way to run ssh-agent on the command line is as follows: eval ssh-agent. After doing this, calls to ssh-add should succeed without error. 可以通过下面的命令测试是否生成ssh成功：1234//检测原来的github账号的ssh是否设置成功ssh -T git@github.com//检测新的ssh是否设置成功ssh -T git@github_aaa.com 配置config文件.ssh下面本来是没有config文件，因为默认你的电脑就只有一个github与本地关联。但由于此时有多个github和对应的ssh，所以必须要配置才能加以区分。进入$ vi .ssh/config。并加入下列内容。保存后退出。123456789# 加上以下内容#default githubHost github.com HostName github.com IdentityFile ~/.ssh/id_rsaHost github_aaa.com HostName github.com IdentityFile ~/.ssh/id_rsa_aaa 如何使用这样的话，你就可以通过使用github.com别名github_aaa来明确说你要是使用id_rsa_aaa的SSH key来连接github，即使用工作账号进行操作，如下：123456#本地建库$ git init$ git commit -am \"first commit' #push到github上去$ git remote add origin git@github_aaa.com:xxxx/test.git$ git push origin master 由于我是要把hexo博客部署到github上，所以方式有所不同，更改_config.yml文件：1234deploy: type: git repository: git@github_aaa.com:zxqblog/zxqblog.github.io.git branch: master 如上，上面的@后面不是github.com而是我们刚刚起的别名，github_aaa.com。注意这里的type要写成git而不是默认的github,否则会报下面的错：1error deployer not found:github 这是由于hexo 更新到3.0之后，deploy的type 的github需要改成git。 部署hexo博客到github首先新建一个仓库如：zxqblog.github.io。最好是以这种形式命名。Github Pages的Repository名字是特定的，比如我Github账号是cnfeat，那么我Github Pages Repository名字就是cnfeat.github.io。 部署仓库使用命令123hexo cleanhexo generatehexo deploy 在部署的过程中你可能会出现以下的几个问题：问题1 Error: spawn ENOENT 错误信息解决方案解决方法就是在cmd下敲的命令无法实现，我们把命令在git shell下面敲打就可以实现了。或者配置环境变量如：C:\\Program Files (x86)\\Git\\bin;C:\\Program Files (x86)\\Git\\libexec\\git-core，这样就解决了问题了。 问题2 页面一直显示 404 page 解决方案在github部署完成之后，马上访问可能出现404错误，这是正常的，（最多）等待十分钟左右就可以访问了。如果还不行，那很可能是 github 发送给你的验证邮件你没有打开看，据多方反映，验证后就没问题了。或者是验证邮箱里会出现deploy false的现象，并告诉你部署不成功的原因。这时候你去检查文件，再查找原因即可。 问题3 Page build failed: Missing submodule的解决方案这个问题我犯的真的很低级。因为以前都是通过阿里云来部署我的网站。以为github page部署hexo是一样的，于是就用先前的：git init,git add,git commit,git remote add,git push来做。 但后来知道github page部署hexo不需要这样，只需要上面的步骤配置好_config.yml文件即可。造成这个错误的原因有很多。但是我的错误的大概原因是git里面又有git。或者是git文件不正确（不一定理解正确。。。）。解决方法是重建仓库，查到以前有人用： - Make a backup of the content locally - Delete the repository from GitHub - Delete the repository locally - Recreate the repository, ensuring that you don&apos;t include the repository within the repository locally, which is what you did previously - Push it to GitHub 这个方法解决了，其实就是重新建了仓库。简单的方法是把原来blog里的所有git全部删除，包括deploy_git。然后把github上的文件全部清空。只保留库名字。然后再deploy即可。 涨知识什么是SSHSSH是一种网络协议，用于计算机之间的加密通信。 公钥Public Key与私钥Private KeySSH需要生成公钥Public Key和私钥Private Key, 常用的是使用RSA算法生成id_rsa.pub和id_rsa。 公钥Public Key(id_rsa.pub)是可以暴露在网络传输上的，是不安全的。而私钥Private Key(id_rsa)是不可暴露的，只能存在客户端本机上。 所以公钥Public Key(id_rsa.pub)的权限是644，而私钥Private Key(id_rsa)的权限只能是600。如果权限不对，SSH会认为公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)是不可靠的，就无法正常使用SSH登陆了。 同时在服务端会有一个~/.ssh/authorized_keys文件，里面存放了多个客户端的公钥Public Key(id_rsa.pub)，就表示拥有这些Public Key的客户端就可以通过SSH登陆服务端。 SSH公钥登陆过程 客户端发出公钥登陆的请求(ssh user@host) 服务端返回一段随机字符串 客户端用私钥Private Key(id_rsa)加密这个字符串，再发送回服务端 服务端用~/.ssh/authorized_keys里面存储的公钥Public Key去解密收到的字符串。如果成功，就表明这个客户端是可信的，客户端就可以成功登陆 由此可见，只要多台电脑上的的公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)是一样的，对于服务端来说着其实就是同一个客户端。 所以可以通过复制公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)到多台电脑来实现共享登陆。 总结进一步了解了SSH,并且也知道github page怎么部署网站。最后还选了一个好看的主题。希望她会喜欢。可以访问看看，她的文章写得好好。地址","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"CentOS上如何把Web服务器从Apache换到Nginx","slug":"CentOS上如何把Web服务器从Apache换到Nginx","date":"2016-02-23T05:43:23.000Z","updated":"2016-12-12T02:26:32.000Z","comments":true,"path":"2016/02/23/CentOS上如何把Web服务器从Apache换到Nginx/","link":"","permalink":"http://sevencai.github.io/2016/02/23/CentOS上如何把Web服务器从Apache换到Nginx/","excerpt":"","text":"先前有一篇文章是写如何通过nginx实现反向代理。但当时出现了一个问题，就是我原先centos上面装的opache由于端口原因必须停掉。并且/的配置使路由转发出现了问题。导致我以前的php网站都不能访问。今天把这个问题解决了并记录。 先学习几个概念反向代理是什么 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 Nginx和Apache的区别与联系Nginx是一个高性能的HTTP服务器和反向代理服务器，最大的优点是节省资源。适用于处理高并发的请求。 Nginx最初是按照反向代理设计的，和Apache不同, nginx关心如何处理url,而不是文件！ Apache是基于进程处理的web服务器，Nginx是基于事件(event)的异步处理模式。 Nginx比较适合来处理静态文件和资源。Apache虽然占用内存多了点，性能上稍逊，但一直比较稳健。适用于处理动态文件。 Apache 是个基于进程处理的web服务器，如果同时有多个请求，必须要启动多个进程来处理。 这样在高负载的情况下，资源的消耗和响应的速度都会有很大的问题。 而Nginx是个基于事件(event)的异步处理模式， 下面是Nginx的一个简单的示意图，有一个Master进程，Maste进程负责系统配置，管理socket,以及管理一个或是多个Worker进程。 而Worker进程接收和处理来自用户（浏览器）的请求。一般来讲，一个worker进程可以同时处理上千个用户的连接请求。每个worker进程采用异步的，基于event的方式来处理用户的请求。对于HTML的静态页面，Nginx会自行来处理，但对于PHP,JSP, Python等动态页面，Nginx是通过FastCGI(或者SCGI,UWSGI)来把动态页面的请求交给相应的处理程序来处理。 安装和配置安装nginx这里安装nginx上一篇文章讲了。有一点要注意和提醒的：在CentOS的YUM的基础的容器中，并没有nginx和php-fpm的RPM包。这两个RMP包在epel的容器中， 虽然可以从官网下载RPM包来安装，但如果你的CentOS/Redhat中没有加入YUM的epel容器，还是先把这个yum容器加上去比较好，以后可以省无数的折腾。 安装php-fpm刚刚说了Nginx是通过FastCGI来把动态页面的请求交给相应的处理程序来处理。PHP-FPM (PHP-FastCGI Process Manager) 是目前最常用的一个PHP FastCGI的实现。通俗的讲，这个模块在Nginx和PHP之间桥梁，使之可以互相通信和交换。123yum install php-fpm/etc/init.d/php-fpm startchkconfig php-fpm on 安装好后来确认是否nginx和php-fpm安装正确。使用netstat tunlp命令。查看端口监听情况。 配置default.conf文件使nginx可解析php文件配置文件最后如下：路由为/时是反向代理。如果所有的文件我都放在html目录下。那么当我访问里面的多个网站时，都必须在conf文件里配置一下路由，比如下面的/images目录等。所以我专门建立了一个web目录，用来放我所有的php站点。fastcgi监听9000端口。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950server &#123; listen 80; server_name cailidan.cn,www.cailidan.cn; root /usr/share/nginx/html; #charset koi8-r; #access_log logs/host.access.log main; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://127.0.0.1:4000/; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; error_page 404 /404.html; location = /404.html &#123; root /usr/share/nginx/html; &#125; location /web &#123; root /usr/share/nginx/html; index index.php index.html index.htm; &#125; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 中间学到的东西Redhat/CentOS安装软件有下面三种方法： 1.使用YUM 来在线安装软件，基本和 “软件商店”的概念类似， 只需要在yum的容器中找到相应的软件（rpm包），然后直接安装（或升级）就OK了，过程比较简单。 2.下载相应的RPM软件包，然后用RPM命令安装。 3.下载软件的源码的Tarball, 在自己的机器上编译和安装。这种方法相对来说比较麻烦。 RPMRPM是 Redhat Package Manager的缩写，是Linux上的一种软件打包和管理的工具。 因为Linux的不同发行版(distribution)，甚至同一发行版的不同版本之间往往有很多的不同， 开发者在某个Linux发行版下开发和编译的程序，直接放到另外一个Linux下有非常大的可能性无法运行。 因此早期的Linux的软件都是通过源码来分发，使用者基本都是通过在自己的Linux平台上重新编译源代码来安装软件。 但是这种编译源代码的方式比较繁琐和复杂，普通用户往往也难以掌握。 后来 Redhat推出了RPM这个软件打包的方式。就是在特定的Linux平台上把软件编译好，然后把与这个软件相关的文件和库打包成一个文件（RPM包）， 但需要注意的是： 通常不同的distribution所发布的RPM包往往不能用于其他的Linux的distributions上面。 例如，针对Redhat的RPM包往往无法直接在OpenSUSE上进行安装。因此，在使用RPM方式进行安装的时候，必须选择和你使用的平台一致的RPM安装包。 RUM为了解决软件依赖的问题，已经为了给用户提供一种更加方便简单的软件安装方法， YUM被开发出来了。 YUM 是Yellowdog Updater Modified 的缩写. YUM 是建立在RPM的基础之上的， 为用户提供软件安装，升级，卸载的功能。 YUM最大的好处是解决了软件依赖的问题。YUM 把很多软件的RPM包放在RPM 容器(repository)中， 用YUM 方式来安装软件的时候，会自动分析你要安装的软件的依赖关系，并会自动帮你安装必须的“依赖软件”， 这样就解决了最为困扰用户的软件依赖的问题。 那YUM容器（repository)的是什么呢？ YUM容器类似一个软件仓库的概念，不但有各个软件的RPM安装包，还记录了他们之间的依赖关系。 1234567yum list/search /info xxxyum list httpd //检查apache是否已经安装yum info httpd //查看apache的详细信息， 类似 rpm -qi httpdyum search httpd //查询和 apache (httpd)相关的软件yum install httpd //安装yum update httpd //升级yum remove httpd //卸载软件","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"理解DOM中的事件流的概念","slug":"理解DOM中的事件流的概念","date":"2016-02-22T14:03:39.000Z","updated":"2016-12-12T03:02:06.000Z","comments":true,"path":"2016/02/22/理解DOM中的事件流的概念/","link":"","permalink":"http://sevencai.github.io/2016/02/22/理解DOM中的事件流的概念/","excerpt":"","text":"什么是事件流流：用术语说流是对输入输出设备的抽象。以程序的角度说，流是具有方向的数据。 事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。 事件：用户或者浏览器自身执行的某个动作，比如load，click，mousemove等 事件处理程序：相应处理某个事件的函数叫做事件处理函数（也叫做事件侦听器） 比如说React中的单向数据流，Node中的流，又或是今天本文所讲的DOM事件流。都是流的一种生动体现。 理解DOM中的事件流 当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。 IE提出的事件冒泡事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"click\"&gt;点击&lt;/button&gt; &lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.onclick = function()&#123; console.log(\"1. button\"); &#125; document.body.onclick = function()&#123; console.log(\"2. document.body\"); &#125; document.onclick = function()&#123; console.log(\"3. document\"); &#125; window.onclick = function()&#123; console.log(\"4. window\"); &#125; &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在代码所示的页面中，如果点击了button，那么这个点击事件会得到如下的结果：也就是说，click事件首先在button元素上发生，然后逐级向上传播。这就是事件冒泡。 netscape提出的事件捕获事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。比如说刚才的demo，如果是事件捕获的话，事件发生顺序会是刚好与上面相反的。即window,document,document.body,button。 虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。 所以放心的使用事件冒泡，有特殊需要再使用事件捕获即可。 DOM事件流DOM事件流可以分为下面3个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 事件捕获阶段也就是说，当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会。例如，我把上面的Demo中，window点击事件更改为使用事件捕获模式。 addEventListener最后一个参数，为true则代表使用事件捕获模式，false则表示使用事件冒泡模式。 12345678910111213&lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.addEventListener(\"click\",function()&#123; console.log(\"1. button\"); &#125;,true) //省略document.body和document ..... window.addEventListener(\"click\",function()&#123; console.log(\"4. window\"); &#125;,true) &#125;)() &lt;/script&gt; 结果如下：可以看到，点击事件先被父元素截获了，且该函数只在事件捕获阶段起作用。 在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到body后就定停止了。下一个阶段是处于目标阶段，于是事件在button上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。 但是：我们的各大浏览器总是不喜欢按照规范来，IE9，Safari，chrome，firefox及其更高的版本中都会在捕获阶段出发事件对象上的事件，最后导致有两个机会在目标对象上操作事件。 处于目标与事件冒泡阶段事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分。随后，冒泡阶段发生，事件开始冒泡。 阻止事件冒泡件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。 这个方法就是:stopPropagation()12345678910111213(function()&#123; var btn = document.getElementById(\"click\"); btn.addEventListener(\"click\",function(event)&#123; console.log(\"1. button\"); event.stopPropagation(); console.log('Stop Propagation!'); &#125;,false) //省略document.body和document ..... window.addEventListener(\"click\",function()&#123; console.log(\"4. window\"); &#125;,false)&#125;)() 最后结果是：1.button，Stop Propagation!。通过stopPropagation();阻止了事件的冒泡。 事件处理程序类别刚刚我们已经讲了事件处理程序就是相应处理某个事假的函数。它可以分为几个类别： html事件处理程序某个元素支持的某个事件可以用与事件处理程序同名的html特性来指定，该特性的值是能够执行的javascript代码,这也是我们最初学js，最开始的方法。123456789&lt;script&gt; function show()&#123; alert('我被点击了'); &#125;/* 点击后也会弹出 '我被点击了'*/&lt;/script&gt;&lt;input type=\"button\" value=\"点击\" onclick=\"show()\" /&gt; 优点：简单明了，省去获取元素等一系列前提操作 缺点：html代码与js代码高度耦合，不符合分离原则 DOM0级别事件处理函数DOM0级别事件处理函数，使用 element.on[eventname]=fn的方式给元素添加事件12345678910&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click'); //该方式被认为是元素的方法，即事件处理程序在元素的作用域中进行，this即该元素本身 oBtn.onclick=function()&#123; alert(this.id);//click &#125; //注意：删除该事件处理程序可以用如下方法 oBtn.onclick=null;//即点击后不再有任何反应 &lt;/script&gt; DOM2级事件处理程序DOM2级添加了addEventListener（添加事件处理程序）和removeEventListener(移除事件处理程序),也就是我们刚刚讲的上面的DOM2例子。 添加事件处理函数addEventListener 参数1 指定事件名称...click mouseover mouseout 参数2 事件处理程序（匿名函数或者有名函数） 参数3 true（捕获阶段发生） or false（冒泡阶段发生） 1234567891011&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click'); oBtn.addEventListener('click',function()&#123; alert(this.id)//click this指的是该元素作用域内 &#125;,false) //注意该种方式可以给一个函数添加多个事件处理函数，执行顺序与添加顺序相同 oBtn.addEventListener('click',function()&#123; alert('Hello World')//click &#125;,false) &lt;/script&gt; 移除事件处理函数removeEventListener 如果事件处理函数是有名函数，则可以通过名字来移除，匿名函数无法移除。12345678910111213&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click');function showId()&#123; alert(this.id);&#125;;function HelloWorld()&#123; alert('HellowWorld');&#125;oBtn.addEventListener(\"click\",showId,false);oBtn.addEventListener(\"click\",HelloWorld,false);oBtn.removeEventListener('click',showId,false)&lt;/script&gt; 最后只能弹出HellowWorld IE事件处理程序attachEvent,detachEvent ie实现了与dom类似的两个方法，attachEvent（添加），detachEvent（删除）123 oBtn.attachEvent('onclick',showId);//这时候会报错，因为这里的是在window的作用域内//修改如下oBtn.detachEvent('onclick',showId) ;//点击没有任何反应","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"JS模块化工具requirejs","slug":"JS模块化工具RequireJS","date":"2016-02-18T12:11:54.000Z","updated":"2016-12-12T02:30:00.000Z","comments":true,"path":"2016/02/18/JS模块化工具RequireJS/","link":"","permalink":"http://sevencai.github.io/2016/02/18/JS模块化工具RequireJS/","excerpt":"","text":"上一篇文章记录的是AMD和CMD模块化标准。requireJS就基于AMD。下面看看requireJS的基本知识。 RequireJs出现的原因随着网站功能逐渐丰富，网页中的js也变得越来越复杂和臃肿，原有通过script标签来导入一个个的js文件这种方式已经不能满足现在互联网开发模式，我们需要团队协作、模块复用、单元测试等等一系列复杂的需求。比如：1234567&lt;script type=\"text/javascript\" src=\"a.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"b.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"c.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"d.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"e.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"f.js\"&gt;&lt;/script&gt;....... 这样做有很大的问题。经常会造成我们说的白页。首先由于浏览器再加载脚本时，默认是阻塞的。即在加载这些js脚本时，会停止网页的渲染。当加载的文件越来越多时，网页失去响应的时间就会越来越长。其次，由于JS之间存在依赖关系（比如使用b.js必须要等需要等待a.js加载完)，此时必须严格保证这些脚本的书写（加载）顺序。依赖最大的模块一定要放在后面。这就造成代码的编写和维护非常困难。比如： index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"a.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"\"&gt;test&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; a.js123456(function()&#123; function fun1()&#123; alert(\"it works\"); &#125; fun1();&#125;)() 此时在alert(it works)之前浏览器是没有任何东西的如下：此时如果我们利用requireJS异步加载。就不会出现这个问题。alert的同时，dom结构也会被渲染出来。 RequireJs作用基于上面的种种原因，RequireJS就出现了。 RequireJS是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一。最新版本的RequireJS压缩后只有14K，堪称非常轻量。它还同时可以和其他的框架协同工作，使用RequireJS必将使您的前端代码质量得以提升。 下面是几种作用： 实现js文件的异步加载，避免网页失去响应 管理模块之间的依赖性，便于代码的编写和维护 声明不同js文件之间的依赖 可以按需、并行、延时载入js库 可以让我们的代码以模块化的方式组织 开始使用requireJS在html中引入requirejs如果直接在网页中这样写：1&lt;script src=\"js/require.js\"&gt;&lt;/script&gt; 同样也会可能造成浏览器失去响应，因为加载这个文件。可以： 使用defer或者async1&lt;script src=\"js/require.js\" defer async=\"true\" &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 将其放在body最下面。最后加载。 最后写成：1&lt;script src=\"js/require.js\" data-main=\"js/config\" defer async=\"true\"&gt;&lt;/script&gt; 通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。 属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块，这里我们是在js文件夹下又创建了config.js。 基本APIrequire会定义三个变量：define,require,requirejs，其中require === requirejs，一般使用require更简短 define 从名字就可以看出这个api是用来定义一个模块 require 加载依赖模块，并执行加载完后的回调函数 主模块的写法先来回忆下AMD的写法：1234// config.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here&#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。–ranyifeng 假定主模块依赖jquery、underscore和backbone这三个模块，config.js就可以这样写：123require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); require.js假定这三个模块与config.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块的加载一般config.js(入口的文件)的作用主要有两个： 配置requirejs 比如项目中用到哪些模块，文件路径是什么 载入程序主模块 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（config.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。1234567require.config(&#123; paths:&#123; \"jquery\":\"jquery.min\", \"underscore\":\"underscore.min\" \"backbone\":\"backbone.min\" &#125;&#125;) 下面这样写path是由于这些js文件都和config.js是同级目录,如果不是同级目录，比如下面这些文件都在lib/下，那么对应下面的paths中要指明/lib/jquery.min或者使用baseUrl: &quot;js/lib&quot;。 之前的例子中加载模块都是本地js，但是大部分情况下网页需要加载的JS可能来自本地服务器、其他网站或CDN，这样就不能通过这种方式来加载了，我们以加载一个jquery库为例：1234567891011require.config(&#123; paths : &#123; \"jquery\" : [\"http://libs.baidu.com/jquery/2.0.3/jquery\"], \"a\" : \"js/a\" &#125;&#125;)require([\"jquery\",\"a\"],function($)&#123; $(function()&#123; alert(\"load finished\"); &#125;)&#125;) 通过paths的配置会使我们的模块名字更精炼，paths还有一个重要的功能，就是可以配置多个路径，如果远程cdn库没有加载成功，可以加载本地的库，如：1234567891011require.config(&#123; paths : &#123; \"jquery\" : [\"http://libs.baidu.com/jquery/2.0.3/jquery\", \"js/jquery\"], \"a\" : \"js/a\" &#125;&#125;)require([\"jquery\",\"a\"],function($)&#123; $(function()&#123; alert(\"load finished\"); &#125;)&#125;) 这也是为什么是以数组的形式出现的原因。这样配置后，当百度的jquery没有加载成功后，会加载本地js目录下的jquery。 AMD模块的写法上面介绍了主模块的写法，以及主模块是如何加载模块的，下面来看些是如何编写这些AMD模块的。比如我们刚刚写的a.js是这样写的。通过define函数定义了一个模块，然后再页面中使用：1234567define(function()&#123; function fun1()&#123; alert(\"it works\"); &#125; fun1();&#125;) 再例如一个math.js12345678910111213define(function()&#123; var add = function(x,y)&#123; return x+y; &#125; var sub = function(x,y)&#123; return x-y; &#125; return &#123; add:add, sub:sub &#125;&#125;) config.js主模块中加载方法如下：123456require([\"math\"],function(math)&#123; return math.add(2,3);&#125;)require([\"a\"],function()&#123; alert(\"load finished\");&#125;) 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。12345678define(['mylib'],function()&#123; function foo()&#123; return mylib.getInfo(); &#125; return &#123; foo:foo &#125;&#125;) 当require()函数加载上面这个模块的时候，就会先加载mylib.js文件。 加载非规范的模块 理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？ 比如定义一个hello.js的模块：123function hello()&#123; alert(\"hello\");&#125; 它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？它并不是一个AMD规范的模块，因为并没有通过define定义。假如我们还是先前的方法把它当作一个普通的模块。在config.js利用path定义路径。123456789require.config(&#123; paths:&#123; \"hello\":\"hello\", &#125;&#125;)require([\"hello\"],function()&#123; alert(\"test hello\");&#125;) 此时会报错：Uncaught TypeError: undefined is not a function 原因是最后调用 hello() 的时候，这个 hello 是个 undefined . 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。 在这种情况下，我们要使用 shim ，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 再举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。1234567891011require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125; &#125;); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称； 其中deps数组，表明该模块的依赖性。比如，jQuery的插件(这里是滚动插件)可以这样定义：123456shim: &#123; 'jquery.scroll': &#123; deps: ['jquery'], exports: 'jQuery.fn.scroll' &#125; &#125; require.js插件require.js还提供一系列插件，实现一些特定的功能。domready插件，可以让回调函数在页面DOM结构加载完成后再运行。123require(['domready!'], function (doc)&#123; // called once the DOM is ready&#125;); 再比如jquery.form插件（插件形式的非AMD模块，我们经常会用到jquery插件，而且这些插件基本都不符合AMD规范，比如jquery.form插件，这时候就需要将form插件”垫”到jquery中）12345678910111213require.config(&#123; shim: &#123; \"underscore\" : &#123; exports : \"_\"; &#125;, \"jquery.form\" : [\"jquery\"] &#125;&#125;)require([\"jquery\", \"jquery.form\"], function($)&#123; $(function()&#123; $(\"#form\").ajaxSubmit(&#123;...&#125;); &#125;)&#125;) 总结大致知道了requireJS是什么东西，以及基本的如何使用。希望以后能够多多用于项目。要不估计过不久又忘记了。感谢和推荐阮一峰的文章和此文档","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"AMD和CMD的区别和联系","slug":"AMD和CMD的区别和联系","date":"2016-02-18T06:17:27.000Z","updated":"2016-12-12T02:58:36.000Z","comments":true,"path":"2016/02/18/AMD和CMD的区别和联系/","link":"","permalink":"http://sevencai.github.io/2016/02/18/AMD和CMD的区别和联系/","excerpt":"","text":"模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 javascript并不具有传统意义上的类，继承，模块。但Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。 AMD|CMD出现的原因node出现时，跟随node出现的还有commonjs，这是一种js模块化解决方案，像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，其等待时间就是硬盘的读取时间。不用考虑异步加载的方式，CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。 但是浏览器环境不同于Node，浏览器中获取一个资源必须要发送http请求，从服务器端获取，采用同步模式必然会阻塞浏览器进程出现假死现象。 比如下面这个例子中，由于浏览器加载js默认是阻塞的，那么后面的add过程就必须等前面require完成，这个时候就会造成假死现象：12var math = require(math);math.add(5,6); 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。后来出现无阻塞加载脚本方式在开发中广泛应用，在此基础结合commonjs规范，前端模块化迎来了两种方案：AMD、CMD。这就是两种规范诞生的背景。 AMD|CMD的定义AMD（Asynchronous Module Definition），CMD（Common Module Definition） AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，CMD是SeaJS 在推广过程中被广泛认知。RequireJs出自dojo加载器的作者James Burke，SeaJs出自国内前端大师玉伯。 AMD Asynchronous Module Definition，用白话文讲就是 异步模块定义，，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 它包含三个参数1define(id?, dependencies?, factory); 第一个参数， id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。 第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 第三个参数，factory，是一个需要进行实例化的函数或者一个对象。 下面例子来自官方文档 创建模块标识为 alpha 的模块，依赖于 require， export，和标识为 beta 的模块1234567define(\"alpha\", [\"require\", \"exports\", \"beta\"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require(\"beta\").verb(); &#125;&#125;); 一个返回对象字面量的异步模块1234567define([\"alpha\"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 无依赖模块可以直接使用对象字面量来定义12345define( &#123; add : function( x, y )&#123; return x + y ; &#125;&#125; ); 类似与 CommonJS 方式定义12345define( function( require, exports, module)&#123; var a = require('a'), b = require('b'); exports.action = function()&#123;&#125;;&#125; ); CMD先来看看commonJS CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}require用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。 大名远扬的玉伯写了seajs，提出的CMD规范,格式为：1define(factory); define 接受 factory 参数,factory 可以是一个函数,也可以是一个对象或字符串。 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以如下定义一个 JSON 数据模块：1define(&#123; \"foo\": \"bar\" &#125;); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。 factory 方法在执行时，默认会传入三个参数：require、exports 和 module(是不是跟上面提到的commonJS很像呢)：123define(function(require, exports, module) &#123; // 模块代码&#125;); define(function (require, exports, module)和exports(是一个对象，用来向外提供模块接口)详解123456define(function(require, exports) &#123; // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口。1234567define(function(require) &#123; // 通过 return 直接提供接口 return &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); 特别注意：下面这种写法是错误的！1234567define(function(require, exports) &#123; // 错误用法！！! exports = &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); 正确的写法是用 return 或者给 module.exports 赋值：1234567define(function(require, exports, module) &#123; // 正确写法 module.exports = &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。 AMD|CMD的区别知乎上玉伯对于 AMD 与 CMD 区别的解释。 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ...&#125;)// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ...&#125;) AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 AMD擅长在浏览器端、CMD擅长在服务器端。这是因为浏览器加载一个功能不像服务器那么快，有大量的网络消耗。所以一个异步loader是更接地气的。 总结：AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行 总结：CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://sevencai.github.io/tags/Nodejs/"}]},{"title":"Flex 布局语法及实例","slug":"Flex-布局语法及实例","date":"2016-02-17T14:26:34.000Z","updated":"2016-12-12T03:00:14.000Z","comments":true,"path":"2016/02/17/Flex-布局语法及实例/","link":"","permalink":"http://sevencai.github.io/2016/02/17/Flex-布局语法及实例/","excerpt":"","text":"Flex元素是可以让你的布局根据浏览器的大小变化进行自动伸缩。 Flexbox布局（Flexible Box)模块旨在提供一个更加有效的方式制定、调整和分布一个容器里的项目布局，即使他们的大小是未知或者是动态的。（这里我们称为Flex）。 Flex布局主要思想是让容器有能力让其子项目能够改变其宽度、高度(甚至顺序)，以最佳方式填充可用空间（主要是为了适应所有类型的显示设备和屏幕大小）。Flex容器会使子项目（伸缩项目）扩展来填满可用空间，或缩小他们以防止溢出容器。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。-ruanyifeng 基本概念 伸缩容器：一个设有“display:flex”或“display:inline-flex”的元素 伸缩项目：伸缩容器的子元素 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end； 交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 先煮个栗子首先要给父容器添加display:flex或者inline-flex属性。再利用flex-grow给项目添加比例。123456789.parent-box&#123; display: -webkit-flex; display: flex; width:400px; height: 100px; color:white; font-size: 25px; border:1px solid #333;&#125; 12345678.box1&#123; flex-grow:1; background: #8E0FAF;&#125;.box2&#123; flex-grow:2; background: #F7E892;&#125; 下面就是简单的DOM结构12345&lt;div class=\"parent-box\"&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt;&lt;/div&gt; 那么此时整个宽度为400px的容器，就被分成了3个部分。并且比例为1:2:1。此时紫色的区域为100px，黄色区域为200px。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。下面的例子部分基于此例。 容器具有的属性 flex-direction 属性决定主轴的方向（即项目的排列方向） flex-wrap 属性定义，如果一条轴线排不下，如何换行。 flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content 属性定义了项目在主轴上的对齐方式。 align-items 属性定义项目在交叉轴上如何对齐。 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 详细解释如下： flex-direction属性决定主轴的方向（即项目的排列方向）1flex-direction: row | row-reverse | column | column-reverse; 分别给parent-box添加这些样式将会得到下面的情形：123456789101112.parent-box1&#123; flex-direction:column;//横向排列，主轴为水平方向，起点在左端。&#125;.parent-box2&#123; flex-direction:row;//纵向排列，轴为垂直方向，起点在上沿。&#125;.parent-box3&#123; flex-direction:row-reverse;//纵向排列，主轴为水平方向，起点在右端。&#125;.parent-box4&#123; flex-direction:column-reverse;//横向排列并且相反，主轴为水平方向，起点在右端。&#125; 注意这里是基于上面的一个例子，利用类样式分离（把公共的代码提取出来）可以减少代码。这里在parent-box的样式上，增加了上面的parent-box1。其余的几个类似。12345&lt;div class=\"parent-box parent-box1\"&gt; &lt;div class=\"box1\"&gt;1&lt;/div&gt; &lt;div class=\"box2\"&gt;2&lt;/div&gt; &lt;div class=\"box1\"&gt;3&lt;/div&gt;&lt;/div&gt; flex-wrap属性定义，如果一条轴线排不下，如何换行1flex-wrap: nowrap | wrap | wrap-reverse; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 比如我一个盒子设置为了400px，我一共有三个子盒子，并且一个盒子是150px，那么400px肯定是放不下这三个盒子的。此时利用flex-wrap可以解决此时是换行还是不换行的问题。如果设置为不换行，那么此时这400px会再次等分。相当于刚刚设置的每个盒子150px失效。如果设置为换行，那么此时将会分成上下两行。为了看得更清楚我给父容器设置了边框。效果如下：123456789101112.parent-box5&#123; -webkit-flex-wrap:wrap; flex-wrap:wrap;&#125;.parent-box6&#123; -webkit-flex-wrap:nowrap; flex-wrap:nowrap;&#125;.parent-box7&#123; -webkit-flex-wrap:wrap-reverse; flex-wrap:wrap-reverse;&#125; 注意换成两行后，第二行是不占据空间的。这个怎么办，。。求解？。12345&lt;div class=\"parent-box parent-box5\"&gt; &lt;div class=\"box3\"&gt;3&lt;/div&gt; &lt;div class=\"box4\"&gt;4&lt;/div&gt; &lt;div class=\"box5\"&gt;5&lt;/div&gt;&lt;/div&gt; flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式可以取下面5个值1justify-content: flex-start | flex-end | center | space-between | space-around; 123456789101112131415.parent-box8&#123; justify-content:flex-start;&#125;.parent-box9&#123; justify-content:flex-end;&#125;.parent-box10&#123; justify-content:center;&#125;.parent-box11&#123; justify-content:space-between;&#125;.parent-box12&#123; justify-content:space-around;&#125; align-items属性定义项目在交叉轴上如何对齐1align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式如果项目只有一根轴线，该属性不起作用。1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 上面讲的都是容器的属性，其实还有项目的属性。 orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow此属性值为正数值，用来设置扩展比率，也就是剩余空间是正值的时候此伸缩项目相对于伸缩容器里其他伸缩项目能分配到空间比例。若省略则会被设置为“1”。 flex-shrink此属性值为正数值，用来设置收缩比率，也就是剩余空间是负值的时候此伸缩项目相对于伸缩容器里其他伸缩项目能收缩的空间比例。若省略则会被设置为“1”，在收缩的时候收缩比率会以伸缩基准值加权。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 举几个flex的例子flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。例子1——flex-grow与flex-basis：123456789#first &#123; flex: 1 200px;&#125; #second &#123; flex: 2 300px;&#125; #third &#123; flex: 1 250px;&#125; 首先flex-basis的值主要取决于伸缩项目的width或者高，同时取决于流动方向。然后，剩下的空间根据flex-grow给伸缩项目最后宽度来划分。所以伸缩项目会沿着主轴线大小为200px、300px和250px,总共750px。如果伸缩容器沿主轴方向是950px,这样就会多出一个200px空间，那么这多出的200px空间将分配给伸缩项目。第一个和第三个伸缩项目将得到50px的空间，因为他的flex-grow值是“1”,他们最终的空间是250px和300px。第二个伸缩项目将获得100px空间，因为他的flex-grow值为“2”,他的最后空间大小为400px。 例子2——flex-grow与flex-shrink与flex-basis123456789#first &#123; flex: 1 1 400px;&#125; #second &#123; flex: 2 3 600px;&#125; #third &#123; flex: 1 2 400px;&#125; flex-shrink称为收缩比率。这个值只有伸缩项目在没主轴方向溢出伸缩容器才会发挥作用。他们充当比例值，但这回指的是溢出量，将这个溢出量按比例分配给每个伸缩项目，用于防止伸缩容器溢出。 比如说，我们伸缩容器沿主轴方向宽度是1100px，按照上面的示例代码计算，我们的伸缩项目会超出300px(伸缩项目沿主轴方向总值为1400px)，这个时候通过flex-shrink收缩他们： 第一个伸缩项目将得到溢出量的六分之一，也就是50px，这个时候他的值为350px(在当初的基础上减少50px)。 第二个伸缩项目将得到溢出量的六分之三，也就是150px，这个时候他的值为450px(在当初的基础上减少150px)。 第三个伸缩项目将得到溢出的六分之二，就就是100px，这个时候他的值为300px(在当初的基础 上减少100px)。 这样flex-shrink使用伸缩项目得到一个较小的宽度。 例子3——align-self属性可以实现的效果 旧版本的box flex这个以前有写旧的写法(只列举了部分)，详细可以看：旧写法（通过审查元素即可看） 其语法不同，而且也更加不兼容。比如：12345678910111213141516#parent-box&#123; display: -moz-box; display: -webkit-box; display: box; .....&#125;#parent-box2&#123; -moz-box-orient:horizontal|vertical; -webkit-box-orient:horizontal|vertical; box-orient:horizontal|vertical;&#125;#box1&#123; -moz-box-flex:1; -webkit-box-flex:1; box-flex:1;&#125; 大概知道Flex是干什么的了。感谢阮一峰的文章，这个绝对讲的清楚。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"javascript同步和异步加载及async和differ区别","slug":"javascript同步和异步加载及async和differ区别","date":"2016-02-16T14:04:49.000Z","updated":"2016-12-12T03:00:38.000Z","comments":true,"path":"2016/02/16/javascript同步和异步加载及async和differ区别/","link":"","permalink":"http://sevencai.github.io/2016/02/16/javascript同步和异步加载及async和differ区别/","excerpt":"","text":"主要弄清楚几个概念：异步加载（async loading），延迟加载（lazy loading），延迟执行（lazy execution），async 属性， defer 属性。 javascript的同步，异步，延迟加载 加载的网络 timeline 是瀑布模型，而异步加载的 timeline 是并发模型。 同步加载同步模式，又称阻塞模式。javascript在默认情况下是会阻塞加载的。当前面的javascript请求没有处理和执行完时，会阻止浏览器的后续处理，如文件加载（图像），DOM tree的渲染，代码的执行。 js之所以要同步执行，是因为 js 中可能有输出 document 内容、修改dom、重定向等行为，所以默认同步执行才是安全的。以前的一般建议是把script放在页面末尾之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。 异步加载异步加载又叫非阻塞，浏览器在下载执行 js 同时，还会继续进行后续页面的处理。有很多种方式可以实现异步加载。下面是其中的几种。 延迟加载延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。 也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。 特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片。 异步加载的几种方法 Script DOM Element方法12345678(function() &#123; var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://yourdomain.com/script.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x); &#125;)(); 这种方法是在页面中script标签内，用 js 创建一个 script 元素并插入到 document 中。这样就做到了非阻塞的下载 js 代码。将js代码包裹在匿名函数中并立即执行的方式是为了保护变量名泄露到外部可见，这是很常见的方式，尤其是在 js 库中被普遍使用。我的博客就用了百度统计，里面脚本也是通过这种方式。123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(\"script\"); hm.src = \"******\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 但是，这种加载方式在加载执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。 onload时的异步加载1234567891011121314(function() &#123; function async_load()&#123; var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://yourdomain.com/script.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x); &#125; if (window.attachEvent) window.attachEvent('onload', async_load); else window.addEventListener('load', async_load, false); &#125;)(); 这和前面的方式差不多，但关键是它不是立即开始异步加载 js ，而是在 onload 时才开始异步加载。这样就解决了阻塞 onload 事件触发的问题。这种方法也是google最推荐的方法。因为它完全解决在web页面完全加载后，再加载外部js的问题。 defer和async在看这两个的作用和区别之前，一定要先理解下面内容。 JS的加载其实是由两阶段组成：下载内容（download bytes）和执行（parse and execute）。我们都知道通过网络下载 script 需要明显的时间，但容易忽略了第二阶段，解析和执行也是需要时间的。script的解析和执行所花的时间比我们想象的要多，尤其是script 很多很大的时候。有些是需要立刻执行，而有些则不需要（比如只是在展示某个界面或执行某个操作时才需要）。 这两种方法都可以实现异步加载，那么有什么区别呢？下面来看一张图：(非常感谢(sf的这篇文章)[https://segmentfault.com/q/1010000000640869])蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 第一种，没有 defer 或 async，按正常情况加载。1&lt;script src=\"script.js\"&gt;&lt;/script&gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。这种也就是为什么我们会出现白页的原因。 第二种，有 async1&lt;script async src=\"script.js\"&gt;&lt;/script&gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。async属性是HTML5新增的。作用和defer类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在onload 事件之前完成。 第三种，有defer1&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt; 加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 这时候就回想，这个onload和DOMContentLoaded到底什么区别呢？补充：DOMContentLoaded 与 OnLoad 事件 DOMContentLoaded : 页面(document)已经解析完成，页面中的dom元素已经可用。但是页面中引用的图片、subframe可能还没有加载完。 OnLoad：页面的所有资源都加载完毕（包括图片）。浏览器的载入进度在这时才停止。这两个时间点将页面加载的timeline分成了三个阶段 这张图告诉了我们几件事情： defer和async的异步是相对于DOM TREE的解析。它们在网络读取没有任何差别。差别在于下载完了脚本后，何时执行。 defer是全部元素解析完成之后（DOMContentLoaded）执行。所以是按照加载顺序时执行脚本。而async对它来说脚本的加载和执行是紧紧挨着的。，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。所以可能会出现乱序。 async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics和baidu统计。 延迟加载的方法 1234567891011121314151617181920212223242526window.onload = function() &#123; setTimeout(function()&#123; // reference to &lt;head&gt; var head = document.getElementsByTagName('head')[0]; // a new CSS var css = document.createElement('link'); css.type = \"text/css\"; css.rel = \"stylesheet\"; css.href = \"new.css\"; // a new JS var js = document.createElement(\"script\"); js.type = \"text/javascript\"; js.src = \"new.js\"; // preload JS and CSS head.appendChild(css); head.appendChild(js); // preload image new Image().src = \"new.png\"; &#125;, 1000); &#125;;","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"css做三角形原理","slug":"css做三角形原理","date":"2016-02-15T06:26:59.000Z","updated":"2016-12-12T02:59:26.000Z","comments":true,"path":"2016/02/15/css做三角形原理/","link":"","permalink":"http://sevencai.github.io/2016/02/15/css做三角形原理/","excerpt":"","text":"以前知道css能做出各种方向的三角形，但其实一直都不知道中间的原理是什么。今天把它解决了。几个图就能解决清楚。 制作普通的正方形为了能够看清楚各个边的变化，我把各个边的颜色设置成了不同的颜色。每个边的表现都是梯形。如图一所示。设置盒子大小为100px,并且盒子边框为10px;1234567#first-box&#123; width:100px; height: 100px; border-width: 10px; border-style: solid; border-color: red blue yellow green;&#125; 制作没有高度的正方形上面例子中的空白部分，是由于设置了宽和高的大小。当我们设置width为0，height为0时，空白处消失，此时只剩下边框组成的正方形，如上图2。1234567#second-box&#123; width: 0px; height: 0px; border-width: 10px; border-style: solid; border-color: red blue yellow green;&#125; 制作三角形上面我们已经可以看到四个不同的小三角形了。我们需要三角形往哪个方向就设置该方向有颜色和边框。其他方向均透明即可。如图31234567#third-box&#123; width:0px; height: 0px; border-width: 10px; border-style: solid; border-color: red transparent transparent transparent;&#125; 比如上面我们制作了一个向下的三角形，表示上面有边框，左右和下都没有，设置为transparent。即可得到了。 制作直角三角形上面我们知道其实三角形就是边框的高度组成。如果设置border-width为10，图3那个底边就是两者之和，也就是20px。那我们如果设置右边的边框为0px，只有左边的边框，也就得到了一个直角三角形，如图4.12345678#last-box&#123; width: 0px; height: 0px; border-width:10px; border-style: solid; border-color: red transparent transparent transparent; border-right-width: 0px;&#125;","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"css中少见的visibility：collapse","slug":"css中少见的visibility：collapse","date":"2016-02-14T11:43:15.000Z","updated":"2016-12-12T02:59:26.000Z","comments":true,"path":"2016/02/14/css中少见的visibility：collapse/","link":"","permalink":"http://sevencai.github.io/2016/02/14/css中少见的visibility：collapse/","excerpt":"","text":"visibility 属性设置元素是否应该是可见的，允许作者显示或隐藏一个元素。 与display属性类似但仍有很重要的区别。display:none;隐藏元素并且不占据原有的空间。visibility内容不可见，但元素原来的空间，位置，大小仍占据。 visibility所具有的值 visible:默认。元素是可见的。 hidden:元素是不可见的，但仍然影响布局占据空间。 collapse：对于一般的元素，它的表现跟 hidden 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 display: none 一样，也就是说，它们占用的空间也会释放。 inherit：visibility 属性的值从父元素继承。 js设置visibility的值1document.getElementById(\"p1\").style.visibility=\"hidden\"; demo测试代码测试地址css代码：1234567891011&lt;style&gt; .dn&#123; display: none; &#125; .vh&#123; visibility: hidden; &#125; .vc&#123; visibility: collapse; &#125;&lt;/style&gt; html代码：1234567891011121314151617181920212223242526272829303132&lt;h3&gt;测试display和visibility&lt;/h3&gt;&lt;p&gt; 当使用&lt;b&gt;display:none;&lt;/b&gt;属性, 元素会隐藏，并不占据空间。&lt;button&gt;点击测试&lt;/button&gt;&lt;/p&gt;&lt;p&gt; 当使用&lt;b&gt;visibility:hidden&lt;/b&gt;属性,元素会被隐藏,但是占据空间。&lt;button&gt;点击测试&lt;/button&gt;&lt;/p&gt; &lt;hr&gt;&lt;h3&gt;测试visibility的collapse在不同的地方用处不同&lt;/h3&gt;&lt;p&gt;当在普通元素中使用&lt;b&gt;visibility:collapse;&lt;/b&gt;时，跟visibility:hidden表现相同&lt;button&gt;点击测试&lt;/button&gt;&lt;/p&gt;&lt;p&gt;当在table中使用visibility:collapse;时，跟display:none相同,如下&lt;button&gt;点击测试&lt;/button&gt;&lt;/p&gt;&lt;p&gt;当在table中使用visibility:hidden;时,一样的占据空间,如下&lt;button&gt;点击测试&lt;/button&gt;&lt;/p&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;Fruits&lt;/th&gt; &lt;th&gt;Vegetables&lt;/th&gt; &lt;th&gt;Rocks&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Apple&lt;/td&gt; &lt;td&gt;Celery&lt;/td&gt; &lt;td&gt;Granite&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Orange&lt;/td&gt; &lt;td&gt;Cabbage&lt;/td&gt; &lt;td&gt;Flint&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; js代码：12345678910111213141516171819var btn = document.getElementsByTagName('button');var b = document.getElementsByTagName('b');var rows = document.getElementsByTagName('tr');btn[0].onclick = function()&#123; b[0].className = 'dn';&#125;btn[1].onclick = function()&#123; b[1].className = 'vh';&#125;btn[2].onclick = function()&#123; b[2].className = 'vh';&#125;btn[3].onclick = function()&#123; rows[1].className = 'vc';&#125;btn[4].onclick = function()&#123; rows[1].className = 'vh';&#125;","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"JavaScript数据类型–基本类型和引用类型","slug":"JavaScript数据类型–基本类型和引用类型","date":"2016-02-13T14:16:10.000Z","updated":"2016-12-12T03:00:40.000Z","comments":true,"path":"2016/02/13/JavaScript数据类型–基本类型和引用类型/","link":"","permalink":"http://sevencai.github.io/2016/02/13/JavaScript数据类型–基本类型和引用类型/","excerpt":"","text":"ECMAScirpt 变量有两种不同的数据类型：基本类型，引用类型。也有其他的叫法，比如原始类型和对象类型，拥有方法的类型和不能拥有方法的类型，还可以分为可变类型和不可变类型，都是依据这两种的类型特点来命名的。下面是他们的区别和联系。首先必须要知道一些基础知识。堆和栈的区别在哪里呢？我面阿里的时候就被问到了。 栈和堆详解基本类型的栈：栈是内存中一种特殊的数据结构，也称为线性表，栈按照后进先出 的原则存储数据，先进入的数据被压入栈底，最后插入（push）的数据放在栈顶，需要读取数据时从栈顶开始弹出（pop）数据，即最后一个数据被第一个读出来。因此说， 值类型都是简单的数据段。变量的位置和变量值的位置是重叠的，也就是说值类型的数据被存储在变量被访问的位置。 引用类型的堆：这类值存储在堆（heap）中，堆是内存中的动态区域，相当于自留空间，在程序运行期间会动态分配给代码和堆栈。 堆中存储的一般都是对象，然后通过一个编号传递给栈内变量，这个编号就是所谓的引用指针（point），这样变量和变量值之间是分离的，它们通过指针相联系。当读写数据时，计算机通过变量的指针找到堆中的数据块，并进行操作。 number、string、boolean、null和undefined型数据都是值类型。 由于值类型数据占据的空间都是固定的，所以可以把它们存储在狭窄的内存栈区。这种存储方式更方便计算机进行查找和操作，所以执行速度会非常快。 而对于object型数据（包括function和array）来说，由于它们的大小是不固定的，所以不能存储在栈区，只能被分配到堆区，如果存储在栈区，则会降低计算机寻址的速度。而堆的空间是不固定的，所以很适合存储大小不固定的对象数据，然后在栈区存储对象在堆区的地址即可，而地址的大小是固定的，所以这种分离存储的方法不会影响计算机的寻址速度，对于变量的性能也没有任何负面影响（如图）。 在JavaScript语言中，object、function和array等对象都是引用型数据。 很多语言都把字符串视为引用型数据，而不是值类型，因为字符串的长度是可变的。但是JavaScript比较特殊，它把字符串作为值类型进行处理。不过，字符串在复制和传递运算中，是以引用型数据的方法来处理的。 有了这些基本知识，再去看下面的区别就很好理解了。 基本类型和引用类型包含的数据类型不同基本类型包含的数据类型undefined，null，boolean，number，string，基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。 引用类型包含的数据类型对象、数组、函数。也可以说是就是对象了。对象是属性和方法的集合。也就是说引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。 基本类型的值是不可变，引用类型的值是可变基本类型的值不可变任何方法都无法改变一个基本类型的值，比如一个字符串：123var name = 'seven';name.toUpperCase(); // 输出 'Seven'console.log(name); // 输出 'seven' 会发现原始的name并未发生改变，而是调用了toUpperCase()方法后返回的是一个新的字符串。123456var person = 'seven';person.age = 21;person.method = function()&#123;//...&#125;;console.log(person.age); // undefinedconsole.log(person.method); // undefined 通过上面代码可知，我们不能给基本类型添加属性和方法，再次说明基本类型时不可变； 引用类型的值可变我们可为为引用类型添加属性和方法，也可以删除其属性和方法12345678var person = &#123;&#125;;//创建个控对象 --引用类型person.name = 'seven';person.age = 21;person.sayName = function()&#123;console.log(person.name);&#125; person.sayName();// 'seven'delete person.name; //删除person对象的name属性person.sayName(); // undefined 上面代码说明引用类型可以拥有属性和方法，并且是可以动态改变的。 基本类型和引用类型的比较不同基本类型相等时值相等基本类型只有在它们的值相等的时候它们才相等。但有时候会遇到这种情况：123var a = 1;var b = true;console.log(a == b);//true 它们不是相等吗？其实这是类型转换和 == 运算符的知识了，也就是说在用==比较两个不同类型的变量时会进行一些类型转换。像上面的比较先会把true转换为数字1再和数字1进行比较，结果就是true了。 这是当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。123var a = 'seven';var b = 'seven';console.log(a === b);//true 引用类型的比较是引用的比较123var person1 = '&#123;&#125;';var person2 = '&#123;&#125;';console.log(person1 == person2); // true 上面讲基本类型的比较的时候提到了当两个比较值的类型相同的时候，相当于是用 === ，所以输出是true了。上面的两个person都是字符串。123var person1 = &#123;&#125;;var person2 = &#123;&#125;;console.log(person1 == person2); // false 这两个person是字符串。但此时的结果是false。因为引用类型时按引用访问的，换句话说就是比较两个对象的堆内存中的地址是否相同，那很明显，person1和person2在堆内存中地址是不同的。这个会在下面详细的讲。 基本类型和引用类型的存放地址不一样这一点是我认为理解他们不同的最重要的一点。基本类型的变量是存放在栈区的（栈区指内存里的栈内存）123var name = 'seven';var city = 'wuhan';var age = 1; 那么它的存储结构如下图:栈区包括了 变量的标识符和变量的值。引用类型的值是同时保存在栈内存和堆内存中的对象javascript和其他语言不同，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，那我们操作啥呢？ 实际上，是操作对象的引用，所以引用类型的值是按引用访问的。 准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。123var person1 = &#123;name:'seven'&#125;;var person2 = &#123;name:'cld'&#125;;var person3 = &#123;name:'christine'&#125;; 则这三个对象的在内存中保存的情况如下图： 基本类型和引用类型的赋值基本类型是简单赋值在从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上：12345var a = 10;var b = a;a ++ ;console.log(a); // 11console.log(b); // 10 此时，a中保存的值为 10 ，当使用 a 来初始化 b 时，b 中保存的值也为10，但b中的10与a中的是完全独立的，该值只是a中的值的一个副本，此后，这两个变量可以参加任何操作而相互不受影响。也就是说基本类型在赋值操作后，两个变量是相互不受影响的。 引用类型的赋值是对象引用当从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。前面讲引用类型的时候提到，保存在变量中的是对象在堆内存中的地址，所以，与简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响：123456789101112var a = &#123;&#125;; // a保存了一个空对象的实例var b = a; // a和b都指向了这个空对象a.name = 'seven';console.log(a.name); // 'seven'console.log(b.name); // 'seven'b.age = 1;console.log(b.age);// 1console.log(a.age);// 1console.log(a == b);// true 它们的关系如下图：因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。 声明：文章整理自:推酷 &amp;&amp; segmentfault。非常感谢。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"关于浏览器内核的简单笔记","slug":"关于浏览器内核的简单笔记","date":"2016-02-13T05:56:29.000Z","updated":"2016-02-13T06:00:32.000Z","comments":true,"path":"2016/02/13/关于浏览器内核的简单笔记/","link":"","permalink":"http://sevencai.github.io/2016/02/13/关于浏览器内核的简单笔记/","excerpt":"","text":"浏览器由shell和内核组成，其中shell的种类相对比较多，内核则比较少。Shell是指浏览器的外壳：例如菜单，工具栏 等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。其中浏览器内核部分由渲染引擎(layout engineer或Rendering Engine)和JS引擎组成，现在主要来看下浏览器内核。 浏览器内核的组成和作用：主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责对网页语法的解释并渲染（显示）网页。如取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见浏览器内核的分类：Trident(IE内核):是微软开发的一种排版引擎。Trident内核的常见浏览器有IE,360,猎豹，搜狗浏览器等。有些浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。 Gecko(Firefox内核):一套开放源代码的、以C++编写的网页排版引擎。Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。 Webkit(Safari内核,Chrome内核原型,开源):开源，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。。 Presto(Opera前内核) (已废弃)：实际上这是一个动态内核，与前面几个内核的最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 总结 Trident内核：IE,360,搜狗浏览器，猎豹等。[又称MSHTML] Gecko内核：Firefox，Netscape6及以上版本，MozillaSuite/SeaMonkey等 Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]","categories":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://sevencai.github.io/tags/other/"}]},{"title":"css3渐变（Gradient）","slug":"css3渐变（Gradient）","date":"2016-02-12T06:39:46.000Z","updated":"2016-12-12T02:59:16.000Z","comments":true,"path":"2016/02/12/css3渐变（Gradient）/","link":"","permalink":"http://sevencai.github.io/2016/02/12/css3渐变（Gradient）/","excerpt":"","text":"CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。以前，你必须使用图像来实现这些效果。但是，通过使用 CSS3 渐变（gradients），你可以减少下载的事件和宽带的使用。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。 渐变分为：线性渐变（Linear Gradient）和径向渐变（Radial Gradient）,线性渐变通过控制角度或者方向（向下/向上/向左/向右/对角方向）实现变换，径向渐变由中心定义。 现在主流浏览器有Mozilla（Gecko）（熟悉的有Firefox，Flock等浏览器）、WebKit（熟悉的有Safari、Chrome等浏览器）、Opera(presto)（Opera浏览器）、Trident(IE)。css Gradient在IE下也可以实现，但需要通过IE特有的滤镜来实现。 线性渐变实例讲解gradient做的盒子边框在这个例子中，我们只看到了盒子边框有渐变效果，那么这是怎么做的呢？实际就是一个小盒子，一个大盒子，小盒子是中间那个空白区域，大盒子是包括边框和内如空白区域的部分。然后通过设置小盒子的z-index大于大盒子的z-index，使大盒子中间部分被小盒子的白色遮盖，这么看来，也就得到了边框渐变。代码如下：123&lt;div class=\"box first\"&gt;&lt;/div&gt;&lt;div class=\"box second\"&gt;&lt;/div&gt;&lt;div class=\"box third\"&gt;&lt;/div&gt; css如下,注意大盒子的宽和高都比小盒子大20px，是通过定位使两个小盒子在大盒子的中间。：123456789101112131415161718192021222324252627.box &#123; margin: 80px 30px; width: 200px; height: 200px; position: relative; background: #fff; float: left;&#125;.box:before &#123; content: ''; z-index: -1; position: absolute; width: 220px; height: 220px; top: -10px; left: -10px;&#125;.first:before &#123; background-image: linear-gradient(90deg, yellow, gold);&#125;.second:before &#123; background-image: linear-gradient(0deg, orange, red);&#125;.third:before &#123; background-image: repeating-linear-gradient(-45deg,#cc2a2d,#cc2a2d 30px,#f2f2f2 30px,#f2f2f2 40px,#0e71bb 40px,#0e71bb 70px,#f2f2f2 70px,#f2f2f2 80px);&#125; Gradient在webkit和mozila浏览器中语法介绍线性渐变在Mozila下的应用1background: -moz-linear-gradient( top,#ccc,#000); 共三个参数：第一个参数表示渐变的方向，如top是从上到下，left是从左到右，left top从左上到右下。第二个和第三个参数分别是起点颜色和终点颜色，你还可以在它们之间插入更多的参数，表示多种颜色的渐变。如图所示： 线性渐变在Webkit下的应用-webkit-gradient是webkit引擎对渐变的实现参数，一共有五个。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（径向渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如 left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。1background: -webkit-gradient(linear,center top,center bottom,from(#ccc), to(#000)); 1-webkit-linear-gradient(top,#ccc,#000); 还有几种浏览器是opera和trident就不介绍了,仿照下面写，详细可以看w3cplus详细的介绍123456789/* Firefox 3.6+ */background: -moz-linear-gradient(top, #ace, #f96); /* Safari 4-5, Chrome 1-9 */ /* -webkit-gradient(, [, ]?, [, ]? [, ]*) */background: -webkit-gradient(linear,top,from(#ace),to(#f96));/* Safari 5.1+, Chrome 10+ */background: -webkit-linear-gradient(top, #ace, #f96);/* Opera 11.10+ */background: -o-linear-gradient(top, #ace, #f96); 其中的方向当然也可以是角度：当指定的角度，请记住，‘0deg’指向上面，同时正角度顺时针旋转，因此‘90deg’指向右边。（代码举例）当设置为30deg时：12345678#grad5 &#123; height: 100px; width:20%; background: -webkit-linear-gradient(30deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(30deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(30deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(30deg, red, blue); /* 标准的语法（必须放在最后） */&#125; 径向渐变实例1：12background: -moz-radial-gradient(#ace, #f96, #1E90FF);background: -webkit-radial-gradient(#ace, #f96, #1E90FF); 实例2：12background: -moz-radial-gradient(#ace 5%, #f96 25%, #1E90FF 50%);background: -webkit-radial-gradient(#ace 5%, #f96 25%, #1E90FF 50%); 从以上俩个示例的代码中发现，他们起止色想同，但就是示例二定位了些数据，为什么会造成这么大的区别呢？其实在径向渐变中虽然具有相同的起止色，但是在没有设置位置时，其默认颜色为均匀间隔，这一点和我们前面的线性渐变是一样的，但是设置了渐变位置就会按照渐变位置去渐变，这就是我们示例一和示例的区别之处：虽然圆具有相同的起止颜色，但在示例一为默认的颜色间隔均匀的渐变，而示例二每种颜色都有特定的位置。实例3：12background: -moz-radial-gradient(bottom left, circle, #ace, #f96, #1E90FF);background: -webkit-radial-gradient(bottom left, circle, #ace, #f96, #1E90FF); 这里设置中心位置不同，并且形状似圆形，若是设置为椭圆（ellipse），会有不一样的效果。 如果您想重复一个渐变，您可以使用-moz-repeating-linear-gradient和-moz-repeating-radial-gradient。 在下面的例子，每个实例都指定了两个起止颜色，并无限重复。1234background: -moz-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);background: -webkit-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);background: -moz-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px);background: -webkit-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px); 效果如下： 推荐&amp;&amp;感谢w3cplus文章","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"ES6/ES2015 核心内容（最常用的 ES6 特性）","slug":"ES6-ES2015-核心内容（最常用的-ES6-特性）","date":"2016-02-11T12:18:46.000Z","updated":"2016-12-12T02:59:54.000Z","comments":true,"path":"2016/02/11/ES6-ES2015-核心内容（最常用的-ES6-特性）/","link":"","permalink":"http://sevencai.github.io/2016/02/11/ES6-ES2015-核心内容（最常用的-ES6-特性）/","excerpt":"","text":"ECMAScript 6（以下简称 ES6）是 JavaScript 语言的下一代标准。因为当前版本的 ES6 是在 2015 年发布的，所以又称 ECMAScript 2015。也就是说，ES6 就是 ES2015。虽然目前并不是所有浏览器都能兼容 ES6 全部特性，但越来越多的程序员在实际项目当中已经开始使用 ES6 了。所以就算你现在不打算使用 ES6，但为了看懂别人的你也该懂点ES6的语法了… let, const, class, extends, super, arrow functions, template string, default,destructuring, rest arguments基本上这些就是ES6最经常用到的语法了。 let , const(用作声明变量)与var相同，let和const同用作声明变量，但是他们俩实际是有特殊而且重要的用途。 关于let1234567var global = \"global variables\";while(true)&#123; var global = \"local variables\"; console.log(global); break;&#125;console.log(global); 这两次log出来的结果都是：local variables，因为在ES5中作用域只分为全局作用域和函数作用域，并没有其他语言中的块级作用域，这会有很多不合理的地方，在这个地方就表现为内层变量覆盖了外层变量。也就是两次说两次都是全局作用域中的变量，第一次覆盖了第二次global的声明。 let可以很好的解决这一问题：let则实际上为 JavaScript 新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。例如：1234567var global = \"global variables\";while(true)&#123; let global = \"local variables\"; console.log(global); break;&#125;console.log(global); 此时结果是：local variables global variables,但我试了下，我现在的火狐和360都是不支持的。 还有一个var带来的经常会错的地方，这是我经常会弄错的地方，就是用来计数的循环变量泄露为全局变量,下面这个例子应该很经典了：1234567var arr = [];for(var i=0;i&lt;5;i++)&#123; arr[i] = function()&#123; console.log(i); &#125;&#125;arr[3](); 最后不管调用哪一个函数结果都是5，这是由于变量var i是在全局范围内声明的，是全局变量，所以每次循环一次，i都会增加，并且覆盖先前的值。将上面的var改为let边不会出现这个问题。在ES5中应该有两种写法可以避免上面出现的问题：闭包。123456789var arr = [];for(var i=0;i&lt;5;i++)&#123; (function(i)&#123; arr[i] = function()&#123; console.log(i); &#125; &#125;)(i); &#125;arr[3](); 结果为3，还有一种写法就是拆开，把arr[i]对应的函数放在外面。 关于const这里的const就跟我们平常别的语言一样了，用于声明常量如PI，声明后不可更改，更改后浏览器会报错用，const 来声明可以避免未来不小心重命名而导致出现 bug。123const PI = Math.PIPI = 23 //Module build failed: SyntaxError: /es6/app.js: \"PI\" is read-onlyconst monent = require('moment') class , extends , super这三个特性涉及了 ES5 中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？ ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念。新的 class 写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。123456789101112131415161718class Animal &#123; constructor () &#123; this.type = \"animal\"; &#125; says (say) &#123; console.log(this.type + \"says\" + say); &#125;&#125;class Cat extends Animal&#123; constructor () &#123; super(); this.type = \"cat\"; &#125;&#125;let animal = new Animal ();animal.says(\"hello\");let cat = new Cat();cat.says(\"hi\"); 这个例子中我们首先定义了一个Animal类，有一个 constructor构造方法和一个函数says。而这里面的this则代表的是实例对象本身。也就是说，constructor里面的属性和方法是每个被实例化的对象自己的，而constructor外的是所有对象共享的。 ES6中，这里可以通过class和extends来实现继承，比ES5中通过修改原型链来继承要方便和清晰的多，跟我们以前学习的比如PHP,C++都要类似，更容易接受。 super应该也陌生，它代表的是父类的实例（父类的this对象），子类必须在constructor中通过调用super，如果不调用，新建实例时会报错。因为子类并没有自己的this对象，而是继承了父类的this对象，然后进行加工和修改形成子类自己的特性。如果不调用，子类也就自然没有自己的this对象了。 ES6 的继承机制，实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。 template string这个东西也是非常有用，当我们要插入大段的 html 内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如 mustache 等等。例如jquery里面当我们需要插入一段dom节点时：123456$(\"#result\").append( \"There are &lt;b&gt;\" + basket.count + \"&lt;/b&gt; \" + \"items in your basket, \" + \"&lt;em&gt;\" + basket.onSale + \"&lt;/em&gt; are on sale!\"); 这需要对双引号和+都用的恰当才可。下面通过ES6的template string改进，用反引号（\\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，这个可以有对吧。12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); destructuring(解构)ES6中允许按照一定的模式，从对象和数组中提取值，对变量进行赋值，这称为解构。1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; ES6中更改为：1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 也可以反过来解析：123let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default , restdefault 很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’来指定默认值。12345function animal(type)&#123; type = type || 'cat' console.log(type)&#125;animal() 如果用 ES6 我们而已直接这么写(跟c++差不多了)：1234function animal(type = 'cat')&#123; console.log(type)&#125;animal() 最后一个 rest 语法也很简单，直接看例子：（而如果不用 ES6 的话，我们则得使用 ES5 的arguments）1234function animals(...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //[\"cat\", \"dog\", \"fish\"] arrow function我看的这篇文章说：这个恐怕是 ES6 最最常用的一个新特性了，用它来写 function 比原来的写法要简洁清晰很多。我现在还没有真正的体会到。直接上例子，比如原来这么写的可以像现在这样写：12function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; i + 1 //ES6 如果方程比较复杂，则需要用{}把代码包起来：123456function(x, y) &#123; x++; y--; return x + y;&#125;(x, y) =&gt; &#123;x++; y--; return x+y&#125; 除了看上去更简洁以外，arrow function 还有一项超级无敌的功能！长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用 this，必须非常小心。例如：12345678910111213class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将 this 传给 self,再用 self 来指代 this12345says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;, 1000) 第二种方法是用bind(this),即1234says(say)&#123; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;.bind(this), 1000) 但现在我们有了箭头函数，就不需要这么麻烦了：当我们使用箭头函数时，函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，它的 this 是继承外面的，因此内部的 this 就是外层代码块的 this。123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal()animal.says(‘hi’) //animal says hi 完结：学习整理自SegmentFault，太感谢啦。看完以后对ES6有了一点新的认识，最起码看别人写ES6编码时能看懂一点。也达到了我的初衷。但是看的过程中也暴露了自己的一个问题，那就是对this不了解。应该好好去看看啦。回头再写一篇文章整理下。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://sevencai.github.io/tags/ES6/"}]},{"title":"如何通过nginx反向代理","slug":"如何通过nginx反向代理","date":"2016-02-10T12:16:06.000Z","updated":"2016-12-12T02:53:08.000Z","comments":true,"path":"2016/02/10/如何通过nginx反向代理/","link":"","permalink":"http://sevencai.github.io/2016/02/10/如何通过nginx反向代理/","excerpt":"","text":"本文的主要目的是：如何通过nginx反向代理监听4000端口，使直接访问网站而非端口。比如hexo，通过hexo server来启动服务后，是通过http://127.0.0.1:4000来监听实现的，这是不能直接绑定域名的主机空间的，现在我需要直接访问我的域名就可以访问改博客。此时就可以用到nginx反向代理。 反向绑定域名也叫做反向D理，是指用D理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时D理服务器对外就表现为一个服务器。 什么时候要用到反向绑定域名呢？反向绑定可以分流请求和负载均衡，因此它广泛用于一些大流量的网站和数据集群，降低系统负载。对于一些不能直接绑定域名的主机空间，我们可以用反向绑定域名的方法来强制绑定自己的域名。 安装nginx(下面的步骤可快速在centos上安装nginx)安装epel仓库(install the epel repo)1sudo rpm -Uvh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm 安装remi仓库（Install the remi repo）1sudo rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm 安装nginx和响应的依赖（Install nginx and dependencies)1sudo yum install nginx 启动nginx服务器(Start the nginx HTTP server)1sudo /etc/init.d/nginx start 此时启动后，可能会报以下错误： 通过netstat -ntpl可以查看端口占用情况 中间我查了一些资料，解决办法是找到nginx目录中default.d文件(/etc/nginx/conf.d/default.d)，然后修改里面的内容(vi default.d)。1234567891011121314151617181920212223242526272829server &#123; listen 80; server_name cailidan.cn,www.cailidan.cn; #charset koi8-r; #access_log logs/host.access.log main; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://127.0.0.1:4000/; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; error_page 404 /404.html; location = /404.html &#123; root /usr/share/nginx/html; &#125; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; 最后再重新启动sudo /etc/init.d/nginx start即可访问nginx。此时本需要ip:port才能访问的，就变成了ip就可以直接使用，相当于通过代理，重新处理了url. Nginx简介：Nginx是一个高性能的HTTP服务器和反向代理服务器， 最大的优点是节省资源，适用于处理高并发的请求。 Nginx最初是按照反向代理设计的，和Apache不同, nginx关心如何处理url,而不是文件！ Apache 是个基于进程处理的web服务器，如果同时有多个请求，必须要启动多个进程来处理。 这样在高负载的情况下，资源的消耗和响应的速度都会有很大的问题。 而Nginx是个基于事件(event)的异步处理模式 但是Nginx也有劣势，虽然在静态的反向方面Nginx表现优秀，但是在处理PHP动态请求方面不如Apache，并且在操作使用方面不如Apache方便，例如Wordpress一些插件就只能在Apache上起作用。Nginx一个最常见的问题出现访问502错误。 既使用Nginx，又使用ApacheApache是因为其功能强大而出名的，而Nginx是因为其响应速度快而著称的。这就意味着Nginx在静态内容的服务上要相对快些，不过，Apache可以使用模块来运行后台应用服务器，而且还可以运行脚本语言。 Apache和Nginx都可以用作代理服务器，不过通常我们会把Nginx用作代理服务器，而把Apache用作后台服务器。Nginx包含了 先进的负载均衡和内容缓冲功能。当然，Apache服务器的部署数量巨大。为了充分发挥Apache服务器的效能，就需要有负载均衡器。Apache可以使用自身所包含负载均衡模块，另外，还可以使用基于硬件的负载均衡器。 另一种使用方法是给Nginx配置独立的 php-fpm应用，我们认为 php-fpm是一个应用，这是因为它不是执行期间可以装载的.dll或者.so，而是与Apache的模块使用方法相同。Ngnix使用php-fpm（FastCGI进程管理器）来处理php脚本，这就使得Nginx具有生成非静态内容的功能。 我尚未解决的问题心痛，因为以前没有用过nginx,以前也只是听说过，这次也不是专门想学这个，只是想把网站不要通过端口访问，查到可以用nginx比较方便才去简单的了解了一下。但是发现虽然我想要的效果达到了，以前的apach和现在的nginx却有点冲突了。查到可以通过nginx来处理前端的资源，同时可以用apache做后台服务器处理后台php文件。这样可以充分利用两个的优点。但是必须通过更改nginx的配置才可以。相当于由原来的LAMP到了LNAMP。待我弄清楚了这个到底怎么配置，回头再来写一篇记录下来。","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"如何将hexo博客部署到阿里云上","slug":"如何将hexo博客部署到阿里云上","date":"2016-02-09T03:57:12.000Z","updated":"2016-12-12T02:33:32.000Z","comments":true,"path":"2016/02/09/如何将hexo博客部署到阿里云上/","link":"","permalink":"http://sevencai.github.io/2016/02/09/如何将hexo博客部署到阿里云上/","excerpt":"","text":"昨天晚上折腾了一晚上，又是配环境又是传文件。我的阿里云是centos版本，中间各种弯路，希望对大家有用。首先利用putty或者xshell远程连接你的阿里云。用阿里云自带的控制台也是可以的。我自己用的是xshell觉得比较方便点稍微。 配置环境之安装git安装编译git基础包1yum -y install gcc zlib-devel openssl-devel perl cpio expat-devel gettext-devel curl autoconf 下载和安装Git1234567wget http://soft.itbulu.com/git/git-2.4.6.tar.gztar -zxvf git-2.4.6.tar.gzcd git-2.4.6autoconf./configuremakemake install 检测git是否安装好git -v若有版本号出现则证明安装成功 配置环境之安装nodejs若是直接wget http://nodejs.org/dist/v0.9.0/node-v0.9.0.tar.gz会在编译时报如下的错，WARNING: C++ compiler too old, need g++ 4.8 or clang++ 3.4 (CXX=g++)这是由于CentOS 6 中编译 node4+ 需要高版本号的 C++ 编译器，所以这里可以直接用官网编译好的nodejs二进制包。 跳过编译安装在node下载编译好的版本中下载，通过服务器管理工具（我用的是winscp）将上传好的包到/opt目录，然后解压至当前目录并且重命名为node（我下载的是4.2.6版本）12tar -zvxf node-v4.2.6-linux-x64.tar.gzmv node-v4.2.6-linux-x64 node 配置环境变量进入etc目录，打开profile文件（建议在改动前，先做个备份）vi /etc/profile增加下列内容，注意如果你先前不是上传到了opt目录下，那么对应底下的NODE_HOME路径也要改12export NODE_HOME=/opt/nodeexport PATH=$NODE_HOME/bin:$PATH 检测node是否安装成功$ node -v如有版本号，则表示成功。如果提示command not found 证明没有成功 搭建博客安装全局hexo npm install hexo -g 如果是已有本地hexo博客，并且测试本地成功，则直接通过winscp将本地blog上传到云服务器上，如home/blog目录，上传成功后，hexo server既可以在你的ip:4000端口上查看你的hexo。当然我们不可能让别人通过端口来访问我们的网址，所以还需要设置nginx的反向代理，监听4000端口,这我会在下一篇说明。 如果是没有本地博客，第一次接触，也很简单：12345cd bloghexo initnpm installhexo generatehexo server 即可得到默认主题为landscape的hexo博客。至此阿里云上你的hexo博客就完成啦！","categories":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/categories/工具-配置/"}],"tags":[{"name":"工具/配置","slug":"工具-配置","permalink":"http://sevencai.github.io/tags/工具-配置/"}]},{"title":"微信开发之开发者模式下自定义菜单","slug":"微信开发之开发者模式下自定义菜单","date":"2016-02-04T10:03:38.000Z","updated":"2016-12-12T02:53:42.000Z","comments":true,"path":"2016/02/04/微信开发之开发者模式下自定义菜单/","link":"","permalink":"http://sevencai.github.io/2016/02/04/微信开发之开发者模式下自定义菜单/","excerpt":"","text":"获得ACCESS_TOKEN一个简单的方法是直接使用网页调试工具调试该接口。进入网页接口填入你的AppId还有AppSecret。即可以得到ACCESS_TOKEN 编写代码新建一个php文件并写入下面的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phpheader(\"Content-type: text/html; charset=utf-8\");define(\"ACCESS_TOKEN\", '填入你刚刚得到的ACCESS_TOKEN');//创建菜单function createMenu($data)&#123; //利用curl函数发送post请求 $ch = curl_init(); //post该接口，https://api.weixin.qq.com/cgi-bin/menu/create即为微信创建菜单的接口 curl_setopt($ch, CURLOPT_URL, \"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=\".ACCESS_TOKEN); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, \"POST\"); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $tmpInfo = curl_exec($ch); if (curl_errno($ch)) &#123; return curl_error($ch); &#125; curl_close($ch); return $tmpInfo;&#125;//自定义菜单内容，必须是json格式，button为第一层菜单，sub_button为二级菜单，name为对应值//注意其类型常用的有两种，一种是直接跳转到URL页面，即view类型；另一种，是发送指令，即click类型，这个click类型相当于发送关键字。$data = ' &#123; \"button\":[ &#123; \"name\":\"博客\", \"sub_button\":[ &#123; \"type\":\"click\", \"name\":\"我的博客\", \"key\":\"jsxw\" &#125;, &#123; \"type\":\"click\", \"name\":\"沐歌的博客\", \"key\":\"cjzc\" &#125;] &#125;, &#123; \"name\":\"推荐\", \"sub_button\":[ &#123; \"type\":\"click\", \"name\":\"技术文章\", \"key\":\"jrkp\" &#125;, &#123; \"type\":\"view\", \"name\":\"段子\", \"url\":\"http://XX/index.php/market/index\" &#125;, &#123; \"type\":\"click\", \"name\":\"公号推荐\", \"key\":\"jycl\" &#125;, &#123; \"type\":\"click\", \"name\":\"生活\", \"key\":\"tztd\" &#125;] &#125;, &#123; \"name\":\"留言\", \"sub_button\":[ &#123; \"type\":\"view\", \"name\":\"关于我\", \"url\":\"http://www.index.php/article/index/id/114\" &#125;, &#123; \"type\":\"view\", \"name\":\"留言\", \"url\":\"http://www.index.php/article/index/id/115\" &#125; ] &#125; ] &#125;';echo createMenu($data);//创建菜单?&gt; 最后执行这个文件就可以啦。通过POST方式把菜单的数据发送到微信服务器，在浏览器中看到的返回提示中，你看到OK的字眼，那么就证明已经成功了。创建完菜单之后，由于微信客户端的缓存要24小时才清理一次，所以你要马上看到效果就需要重新关注你的公众账号。（我测试的时候可以不需要重新关注（仅限于菜单）） 解释一下curl是什么？cURL利用URL语法规定来传输文件和数据的工具，因为它是模拟浏览器，因此它同样支持多种协议，FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP等协议都可以很好的支持，包括一些：HTTPS认证，HTTP POST方法，HTTP PUT方法，FTP上传，keyberos认证，HTTP上传，代理服务器，cookies，用户名/密码认证，下载文件断点续传，上传文件断点续传，http代理服务器管道，甚至它还支持IPv6，scoket5代理服务器，通过http代理服务器上传文件到FTP服务器等等。 使用curl的步骤1.初始化，创建一个新cURL资源 curl_init() 2.设置URL和相应的选项 curl_setopt() 3.抓取URL并把它传递给浏览器 curl_exec() 4.关闭cURL资源，并且释放系统资源 curl_close() 我们来采集一个页面，通常情况下，我们会使用file_get_contents()函数来获取：1234567&lt;?php $str = file_get_contents('http://****'); //或者是： $str = file(\"http://****\"); //或者是： readfile(\"http://****\"); ?&gt; 这样我们会发现，我们没有办法有效地进行错误处理，更重要的是我们没有办法完成一些高难度的任务：如：处理cookies，验证，表单提交，文件上传等等。1234567891011&lt;?php //1.初始化，创建一个新cURL资源 $ch = curl_init(); //2.设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, \"http://*****/\"); curl_setopt($ch, CURLOPT_HEADER, 0); //3.抓取URL并把它传递给浏览器 curl_exec($ch); //4.关闭cURL资源，并且释放系统资源 curl_close($ch); ?&gt; 上面用到了两个高级选项：CURLOPT_URL和CURLOPT_HEADER，分别代表“需要获取的URL地址”和“启用时会将头文件的信息作为数据流输出”。这样一个简单的就完成了，实际上它还有很多可选项。并且它的效率远远高于file_get_contents().","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/tags/WEB开发/"}]},{"title":"this值&&this上下文&&此法作用域","slug":"this值-this上下文-词法作用域","date":"2016-02-04T06:58:46.000Z","updated":"2016-12-12T03:01:12.000Z","comments":true,"path":"2016/02/04/this值-this上下文-词法作用域/","link":"","permalink":"http://sevencai.github.io/2016/02/04/this值-this上下文-词法作用域/","excerpt":"","text":"this值在ECMAScript的规范中对this的定义为：this是一个特殊的对象，与执行期上下文相关，因此可以称之为上下文对象。this是执行期上下文对象的一个属性。由于this是执行期上下文对象的属性，因此在代码中使用this，其值直接从上下文对戏那个中获得，而无需查找作用域链，其值在进入上下文的那个时刻被确定。 在全局上下文中，this是全局对象本身：1234var attribute = \"attribute\"; console.log(attribute); console.log(this.attribute); 最后结果：attribute attribute而在函数上下文中，不同的调用方式可以有不同的值。 this上下文this值是执行期上下文对象的一个属性(执行期上下文对象包括变量对象，作用域链以及this)。执行期上下文对象有三类，当进入不同的上下文时，this的值会确定下来，并且this的值不能更改。结合前面小节讨论的内容，在执行全局代码时，控制流会进入全局执行期上下文，而在执行函数时，又会有函数执行期上下文。1234567891011121314151617181920var global = this; var tom = &#123; name : \"Tom\", home : \"desine\", getInfo : function()&#123; print(this.name + \", from \"+this.home); &#125; &#125;; tom.getInfo(); var jerry = &#123; name : \"Jerry\", getInfo : tom.getInfo &#125; jerry.getInfo(); global.getInfo = tom.getInfo; global.getInfo(); 最后结果为：Tom, from desineJerry, from undefinedundefined, from undefined tom对象本身具有name和home属性，因此在执行tom.getInfo时，会打印tom对象上的这两个属性值。当将global.getInfo属性设置为tom.getInfo时，getInfo中的this值，在运行时，事实上是global对象(还记得在全局执行期上下文对象中，global的变量对象的this值吗？)的变量对象中的this就是自身。而global.name和global.home都没有定义，因此会得到上边的结果。 从上例中还可以看到，在函数getInfo调用时，在getInfo之前的对象(tom,jerry,global)会被作为this来执行。当然global可以省略，这时仍然是全局对象作为this。应该记住的是，this的值取决于调用函数的方式(当然这里的this指函数上下文中的this，全局上下文的我们已经讨论过了)。 词法作用域在JavaScript中，函数对象的创建和函数本身的执行是完全不同的两个过程：函数创建过程：1234function func()&#123; var x = 0; print(\"function func\"); &#125; 函数执行过程：func()所谓词法作用域(静态作用域)是指，在函数对象的创建时，作用域”[[scope]]”就已经建立，而并非到执行时，因为函数创建后可能永远不会被执行，但是作用域是始终存在的。 比如在上例中，如果在程序中使用没有调用func(),那么，func对象仍旧是存在的，在内存的结构可能是这样的：1func.[\"[[scope]]\"] = global.[\"variable object\"]; 而当函数执行时，进入函数执行期上下文，函数的活动对象被创建，此时的作用域链是活动对象和”[[scope]]”属性的合成。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"javascript作用域链和活动对象","slug":"javascript作用域链和活动对象","date":"2016-02-04T05:18:12.000Z","updated":"2016-12-12T03:00:32.000Z","comments":true,"path":"2016/02/04/javascript作用域链和活动对象/","link":"","permalink":"http://sevencai.github.io/2016/02/04/javascript作用域链和活动对象/","excerpt":"","text":"任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 javascript的作用域全局作用域（Global Scope）1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：123456789101112var author=\"Seven\";function doSomething()&#123; var blogName=\"Seven's Blog\"; function innerSay()&#123; alert(blogName); &#125; innerSay();&#125;alert(author); //Sevenalert(blogName); //脚本错误doSomething(); //Seven's BloginnerSay() //脚本错误 这里author,dosomething都是全局变量 2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：12345678function doSomething()&#123; var author=\"Seven\"; blogName=\"Seven's Blog\"; alert(authorName);&#125;doSomething(); //Sevenalert(blogName); //Seven's Blogalert(author); //脚本错误 这里blogName没有被声明，默认为全局对象。可以在外层访问，而authorName是局部变量 2.局部作用域（Local Scope）和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域，例如上列代码中的author和函数innerSay都只拥有局部作用域。 javascript作用域链在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 作用域链与原型链类似，也是一个对象组成的链，用以在上下文中查找标识符(变量，函数等)。查找时也与原型链类似，如果激活对象本身具有该变量，则直接使用变量的值，否则向上层搜索，一次类推，知道查找到或者返回undefined。作用域链的主要作用是用以查找自由变量，所谓自由变量是指，在函数中使用的，非函数内部局部变量，也非函数内部定义的函数名，也非形式参数的变量。这些变量通常来自于函数的“外层”或者全局作用域，比如，我们在函数内部使用的window对象及其属性。 12345678910111213//全局变量只能访问到toponevar topone = \"top-level\"; (function outter()&#123; //局部变量，可以访问到topone和middle var middle = \"mid-level\"; (function inner()&#123; //局部变量，可以访问到bottom,middle,topone var bottom = \"bot-level\"; print(topone+\"&gt;\"+middle+\"&gt;\"+bottom); &#125;)();&#125;)(); 根据上图我们可以看出，内部函数的作用域链，由两部分：内部函数自身的活动对象，内部函数的一个属性”[[scope]]”,而”[[scope]]”的值为其外部函数outter的活动对象，其更外部的全局global对象的变量对象。这样，如果在inner中要使用外部的自由变量，显然可以很方便的沿着作用域链上溯。事实上，函数的属性”[[scope]]”会在函数对象创建的时候被创建。 作用域链和代码优化从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：12345function changeColor()&#123; document.getElementById(\"btnChange\").onclick=function()&#123; document.getElementById(\"targetCanvas\").style.backgroundColor=\"red\"; &#125;;&#125; 这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下：123456function changeColor()&#123; var doc=document; doc.getElementById(\"btnChange\").onclick=function()&#123; doc.getElementById(\"targetCanvas\").style.backgroundColor=\"red\"; &#125;;&#125; 这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。在函数中使用var操作符定义一个变量，那么当这个函数执行完毕之后，这个变量也会被销毁（也有的情况下不会，比如闭包，后面会说明），而全局变量会一直存在。所以在我们写代码时，尽量少的使用全局变量，滥用全局变量。更加直接的不好如下： 1.变量过多，命名麻烦 2.局部变量，忘记使用var定义，修改了全局变量 3.全局变量会在页面卸载前一直存在，损耗不必要的内存。 活动对象在JavaScript中，当一个函数被调用的时候，就会产生一个特殊的对象：活动对象。这个对象中包含了参数列表和arguments对象等属性。由于活动对象是变量对象的特例，因此它包含变量对象所有的属性如变量定义，函数定义等。 123456789function add(handle, message)&#123; var id = 0; function doNothing(x)&#123; return x; &#125; handle(message);&#125; add(print, \"hello\"); 在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示(注意：图片只例举了全部变量中的一部分）： 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。 当代码执行到add(print, “hello”)时，活动对象被创建，这个活动对象的图形示意如下：","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"javascript原型对象与原型链","slug":"javascript原型与原型链","date":"2016-02-04T03:32:08.000Z","updated":"2016-12-12T03:00:36.000Z","comments":true,"path":"2016/02/04/javascript原型与原型链/","link":"","permalink":"http://sevencai.github.io/2016/02/04/javascript原型与原型链/","excerpt":"","text":"原型对象每个javascript对象都有一个原型对象，这个对象在不同的解释器下的实现不同。比如在firefox下,每个对象都有一个隐藏的proto属性,这个属性就是原型对象的引用。原型的值可以是一个对象或者null。 原型链由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个链就是原型链。JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined，原型链一般实现为一个链表，这样就可以按照一定的顺序来查找。 例子1123456789101112131415var base = &#123; name:\"base\", getInfo:function()&#123; return this.name; &#125;&#125;var ext1 = &#123; id:0, __proto__:base&#125;var ext2 = &#123; id:9, __proto__:base&#125;console.log(ext1.id+\" \"+ext2.id+\" \"+ext1.getInfo()+\" \"+ext2.getInfo()); 最后结果会是：0 9 base base,在访问每个对象的属性时，都是先在对象本身找，如果没找到，则去原型链中查找，下面的图片可以显示这一点。 例子212345678910111213141516var base = &#123; name:\"base\", getInfo:function()&#123; return this.name+\"*\"+this.id; &#125;&#125;var ext1 = &#123; id:0, name:\"ext1\", __proto__:base&#125;var ext2 = &#123; id:9, __proto__:base&#125;console.log(ext1.name+\" \"+ext2.name+\" \"+ext1.getInfo()+\" \"+ext2.getInfo()); 结果是：ext1 base ext10 base9，这里为什么ext1.getInfo()不会有base出现，就是因为name属性在ext2对象中不存在，因此,从对象本身出发，沿着proto查找，直到在base中找到属性名称相同的值（name）。而ext1对象中本身就有name了，所以不会沿着原型链继续查找了。应该注意的是，getInfo函数中的this表示原始的对象，而并非原型对象（this上下文）。如果对象没有显式的声明自己的”proto”属性，这个值默认的设置为Object.prototype,而Object.prototype的”proto”属性的值为”null”，标志着原型链的终结，即该对象没有原型。 构造器除了上边提到的直接操作对象的proto属性的指向以外，JavaScript还支持构造器形式的对象创建。构造器会自动的为新创建的对象设置原型对象，此时的原型对象通过构造器的prototype属性来引用。 例子3123456789101112131415function Task(id)&#123; this.id = id;&#125;Task.prototype.status = \"STOPPED\";Task.prototype.execute = function(args)&#123; return \"execute task_\"+this.id+\"[\"+this.status+\"]:\"+args; &#125;;var task1 = new Task(1);var task2 = new Task(2);task1.status = \"ACTIVE\";task2.status = \"STARTING\";console.log(task1.execute('task1')+\" * \"+task2.execute('task2')); 这里不像上面的例子在对象上直接操作proto属性的指向，而是通过构造器（属性prototype）的形式来操作。这就是构造器方法也是最经常用的一种方法。最后的结果是：execute task_1[ACTIVE]:task1 * execute task_2[STARTING]:task2构造器会自动为task1,task2两个对象设置原型对象Task.prototype，这个对象被Task(在此最为构造器)的prototype属性引用，参看下图中的箭头指向。由于Task本身仍旧是函数，因此其”proto”属性为Function.prototype, 而内建的函数原型对象的”proto”属性则为Object.prototype对象。最后Obejct.prototype的”proto”值为null. 感谢这么棒的文章：核心概念深入","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://sevencai.github.io/tags/Javascript/"}]},{"title":"如何用CSS做漂亮的毛玻璃效果","slug":"如何用CSS做漂亮的毛玻璃效果","date":"2016-01-01T12:37:39.000Z","updated":"2016-12-12T03:01:48.000Z","comments":true,"path":"2016/01/01/如何用CSS做漂亮的毛玻璃效果/","link":"","permalink":"http://sevencai.github.io/2016/01/01/如何用CSS做漂亮的毛玻璃效果/","excerpt":"","text":"前两天在网上看到有个用css做的毛玻璃效果，好喜欢，就仿着做了个demo。demo我放在了新浪云上：演示地址是不是很好看呢，我很喜欢。图是我在网上自己瞎找到，花瓣只是个动态图，所以才会动。 主要是给背景用filter:blur属性（要加上浏览器内核以兼容各种浏览器），背景虚化后，再对不用虚化的内容比如图片和文字，让他们定位到相应的位置。 12345&lt;div class=\"container\"&gt; &lt;div class=\"pic\"&gt;&lt;/div&gt; &lt;img src=\"./images/a.jpg\" alt=\"\" class=\"weather\"&gt; &lt;span class=\"text\"&gt;北京 晴 3-5C&lt;/span&gt;&lt;/div&gt; 这个demo的大致布局如上，很简单。我让container当做图片容器，对pic进行虚化，并让container的大小和pic完全相同并重叠（inherit）,这样大致的毛玻璃就出来了，然后为了突出毛玻璃的效果，需要把前添加一点元素，使有层次感，就是这里的小花瓣和文字北京晴啦，需要的是对他们进行相对于container的绝对定位，定位到中间的位置：123456789101112131415161718192021222324.container &#123; width: 650px; height: 400px; background: transparent url(\"./images/background.jpg\") no-repeat fixed 0% 0%; position: relative;&#125;.pic&#123; width:650px; height: 400px; background: inherit; -webkit-filter:blur(5px); -moz-filter:blur(5px); -o-filter:blur(5px); filter:blur(5px); filter: progid:DXImageTransform.Microsoft.Blur(PixelRadius=4, MakeShadow=false);&#125;.weather &#123; width: 80px; height: 80px; display: block; position: absolute; top: 30%; left: 40%;&#125; 有的时候会看到这个filter:progid:DXImageTransform.Microsoft.Blur(pixelRadius=6, MakeShadow=false); / IE6~IE9 /。这是代表要支持IE6~IE9。 再还有两个例子： [例子1 ]源于我仿的外国的一个人做的&amp;&amp; [例子2] 源于html5中国还有一个推荐就是张鑫旭的博客里面对这个讲的很好，而且有实例，有详细的讲解，还有关于svg的部分，超级棒。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"css做盒子的曲边阴影和翘边阴影","slug":"css做盒子的曲边阴影和翘边阴影","date":"2015-12-19T13:14:11.000Z","updated":"2016-12-12T02:59:26.000Z","comments":true,"path":"2015/12/19/css做盒子的曲边阴影和翘边阴影/","link":"","permalink":"http://sevencai.github.io/2015/12/19/css做盒子的曲边阴影和翘边阴影/","excerpt":"","text":"盒子的曲边阴影，翘边阴影的区别是：曲边阴影看起来盒子下边像是有个曲边。而翘边阴影是往两边翘。两者的本质就是累加，就是看着像是一个盒子的阴影，其实是多个盒子累加起来的阴影，只是其他的看不见，只有shadow。 这个是好久以前跟着慕课网的老师学的，正好现在整理下。下图是直接的感受，要仔细看才能看到不一样的地方，演示地址上面一个大图，下边是有阴影的，而且阴影并不是整个的一样，而是两边阴影稍微少点，约往里阴影越明显，到底是咋做的呢，一张图就可以解决。 曲边阴影这里就是刚才说的盒子加盒子，外面的大盒子我们看得到，而里面的小矩形，就是隐藏的盒子，大盒子有大盒子的阴影，小盒子有小盒子的阴影，这样一叠加，是不是就是中间阴影更大了呢。 dom结构123&lt;div class=\"wrap effect\"&gt; &lt;h1&gt;Shadow Effect&lt;/h1&gt;&lt;/div&gt; css编写1234567891011121314151617181920212223.effect&#123; position: relative; box-shadow: 0px 1px 4px rgba(0,0,0,0.3),0 0 40px rgba(0,0,0,0.1) inset; -webkit-box-shadow:0px 1px 4px rgba(0,0,0,0.3),0 0 40px rgba(0,0,0,0.1) inset; -o-box-shadow:0px 1px 4px rgba(0,0,0,0.3),0 0 40px rgba(0,0,0,0.1) inset; -moz-box-shadow:0px 1px 4px rgba(0,0,0,0.3),0 0 40px rgba(0,0,0,0.1) inset;&#125;.effect:after,.effect:before&#123; content: \"\"; position: absolute; top:50%; bottom: 0px; left:20px; right:20px; background-color: red; border-radius: 100px/10px; box-shadow: 0 0 20px rgba(0,0,0,0.3); -webkit-box-shadow: 0 0 20px rgba(0,0,0,0.3); -moz-box-shadow: 0 0 20px rgba(0,0,0,0.3); -o-box-shadow: 0 0 20px rgba(0,0,0,0.3); z-index: -1;&#125; 上面还用到了box-shadow的inset,还有after和before，以及要浏览器的各个内核。 翘边阴影原理解析图如下，原理跟上面几乎一样，也是盒子加盒子，唯一不同的是，这次两个盒子不一样，朝向不同的方向，为不同的边加了阴影。 dom结构12345&lt;ul class=\"box\"&gt; &lt;li&gt;&lt;img src=\"images/photo1.jpg\" alt=\"\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo2.jpg\" alt=\"\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo3.jpg\" alt=\"\" /&gt;&lt;/li&gt;&lt;/ul&gt; css编写123456789101112131415161718192021222324252627282930313233343536.box li:before&#123; content:\"\"; position:absolute; width:90%; height: 80%; bottom: 13px; left:21px; background: transparent; z-index: -2; box-shadow: 0 8px 20px rgba(0,0,0,0.8); -webkit-box-shadow: 0 8px 20px rgba(0,0,0,0.8); -o-box-shadow: 0 8px 20px rgba(0,0,0,0.8); -moz-box-shadow: 0 8px 20px rgba(0,0,0,0.8); transform:skew(-12deg) rotate(-6deg); -webkit-transform:skew(-12deg) rotate(-6deg); -moz-transform:skew(-12deg) rotate(-6deg); -os-transform:skew(-12deg) rotate(-6deg); -o-transform:skew(-12deg) rotate(-6deg);&#125;.box li:after&#123; content:\"\"; position:absolute; width:90%; height: 80%; bottom: 13px; right:21px; z-index: -2; background: transparent; box-shadow: 0 8px 20px rgba(0,0,0,0.8); transform:skew(12deg) rotate(6deg); -webkit-transform:skew(12deg) rotate(6deg); -moz-transform:skew(12deg) rotate(6deg); -os-transform:skew(12deg) rotate(6deg); -o-transform:skew(12deg) rotate(6deg);&#125; 这里还用到了css3的变形，transform时元素拉伸并且旋转。由于旋转和拉伸，那个隐形的菱形有一边比较靠近边缘，给他加上阴影，阴影范围比较大时，就会有一部分溢出来了，也就是这里的阴影比较明显，2边4个脚都这样，也就形成了翘起来的边啦。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Css","slug":"Css","permalink":"http://sevencai.github.io/tags/Css/"}]},{"title":"angular整理笔记一","slug":"angular整理笔记一","date":"2015-10-15T12:31:23.000Z","updated":"2016-12-12T02:59:10.000Z","comments":true,"path":"2015/10/15/angular整理笔记一/","link":"","permalink":"http://sevencai.github.io/2015/10/15/angular整理笔记一/","excerpt":"","text":"以下是归档内容，来自2015年angular学习笔记。学习自慕课网大漠穷秋。虽然已经过去了好久，但仍然记得老师当时的思路多清晰。棒棒哒。angular的4大核心特性MVC,模块化，指令系统，双向数据绑定是angular的四个最主要的核心特性。 MVC什么是MVC,M数据模型，V视图层，负责展示，C业务逻辑和控制逻辑。职责清晰，代码模块化。 为什么要用MVC?一定要理解这句话：MVC这是手段，终极目标是模块化和复用。不是因为要去实现MVC才去做东西，是因为要要去模块化和复用才去用MVC的。 代码规模越来越大，切分职责是大势所趋 为了复用：很多逻辑是一模一样的 为了后期维护方便，修改一块功能不影响其他的功能。 前端MVC的困难?浏览器加载js文件是要分成两段的，一段是下载，一段是执行，由于下面的一些问题，导致了前端MVC的实现不想后台那么方便。浏览器加载脚本–&gt;加载完成后JIT编译执行。 操作DOM的代码必须等整个页面加载完成 多个JS文件之间如果出现互相依赖，程序猿必须自己解决 js的原型继承也给前端编程带来了很多困难。 关于C（controller）通过ng-controller指令来实现控制器。下面会将下面这种方法来声明控制器是不好的，因为没有实现模块化。12345function hello($scope)&#123; $scope.textInput = &#123; text:\"cailidan\" &#125;;&#125; MVC–controller的实现方式1这样第一种的实现方式并不好，因为如果视图1和视图2并没有任何逻辑关系，控制器的角色就会很尴尬。也不符合我们代码的分离。无法应对大项目。 MVC–controller的实现方式2这样是一种改进型的方法，我们把视图1和视图2的控制器分开，分别控制。但是如果我们视图1和视图2有两个一模一样的方法怎么办？就出现了下面的方式3. MVC–controller的实现方式3看起来时一种好方法，我们让控制器1和2继承这个公用控制器。但这种方法是不可以实行的。这在angular中是不允许，不可行的，不推荐的。 MVC–controller的实现方式4通过sevice来做，把通用的东西抽象成服务，让控制器调用，而不是来继承这个通用控制器。 Controller使用过程中的注意点 不要试图去复用Controller,一般一个控制器只负责一小块试图 不要在Controller中操作DOM,这不是controller的职责 不要在Controller中做数据格式化，ng有很好用的表单 不要在Controller里面做数据过滤，ng有$filter服务来过滤数据 一般来说，Controller是不会互相调用的，控制器之间的交互会通过事件进行。 对上面的几点的稍微解释：控制器是把业务逻辑放进去，业务逻辑一般不会大段大段的相同。操作DOM时指令的工作，而不是控制器的工作。数据过滤和数据格式化都可以用angular自己的服务和控件。Controller不要相互调用，否则耦合性太强。 关于数据模型MODEL首先找ng-app，找到后，里面所有的东西归angular管，然后找这里面所有的指令编译。比如找到了ng-modal，这是挂在rootscope，在ng-app下面的任意一个都可以获得。虽然上面的例子不是angular推荐的，主要看内部的$scope里面的设置。这就是主要实现modal的方法。 模块化不推荐的写法：12345function hello($scope)&#123; $scope.textInput = &#123; text:\"cailidan\" &#125;;&#125; 这样定义了很多很多的全局函数，肯定是不好的，而通过定义一个模块，然后在模块上生成控制器，这是angular的实现模块方法。注意写法，[“$scope”,function()]。123456789var myModule = angular.module(\"myModule\",[]);myModule.directive(\"hello\",function()&#123; return &#123; restrict:\"E\", template:\"&lt;div&gt;cailidan&lt;/div&gt;\", replace:true &#125;&#125;) angular一切都是从模块开始的，只有把模块定义好了，才能够在模块上调用service,controller,filter等等。就是首先就是定义模块。 指令系统下面这个代码中，如果再html中写了hello就会被替换成cailidan。ng-app实际上就是angular的一个指令，相当于main。在任何一个单页中ng-app只能出现一次。 123456789var myModule = angular.module(\"myModule\",[]);myModule.directive(\"hello\",function()&#123; return &#123; restrict:\"E\", template:\"&lt;div&gt;cailidan&lt;/div&gt;\", replace:true &#125;&#125;) 上面也是一种如何复用View的方法。我们可以定义很多个不用的指令，然后在需要他们地方加载他们，这样也就达到了复用模板的目的。 双向数据绑定单项数据绑定目前大多数前端框架都是实现单向数据绑定，jqueryUI,BackBone,Flex。单向数据绑定的过程是：首先是把模板写好，然后加上数据，数据可能是从后台读出来的。把模板和数据绑定在一起，生成html标签，然后插入到模板中，这样不好的地方是，html一旦生成完后就没法变了，当有新的数据来时，只能重新绑定生成。所以angular就实现了双向事件绑定。 双向数据绑定核心想法是:视图和模型是对应的，当数据模型发生变化的时候，它希望视图自动更新，当视图发生变化的时候，数据模型也发生变化。这中间需要一种时间机制。比如表单中，视图会自动变化，当表单的视图发生变化时，就可以自动反应到数据模型。下面是一个实例。 12345&lt;body ng-app&gt; &lt;input type=\"text\" ng-model=\"textInput\"&gt; &lt;p&gt;&#123;&#123;textInput&#125;&#125;,hello&lt;/p&gt; &lt;script src=\"./js/angular-1.3.0.js\"&gt;&lt;/script&gt;&lt;/body&gt; 双大括号是用来取值的。当input里面发生变化时，ng-modal的值也会发生变化。 具体的$scope解释angularJS的MVC都是通过作用域$scope实现的。看下这个$scope能实现什么。 1234567function GreetCtrl($scope,$rootScope)&#123; $scope.name = \"world\"; $root.department = \"Angular\";&#125;function ListCtrl($scope)&#123; $scope.names = [\"Igor\",\"Misko\",\"Vojta\"];&#125; 这里$rootScope就是根作用域，整个的作用域就像一个树形结构一样。12345678910&lt;div ng-controller=\"GreetCtrl\"&gt; Hello&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;div ng-controller=\"ListCtrl\"&gt; &lt;ol&gt; &lt;li ng-repeat = \"name in names\"&gt; &#123;&#123;name&#125;&#125; from &#123;&#123;department&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 这里的department虽然不是在ListCtrl中定义的，但由于是全局作用域，所以根目录下所有的模块都能访问到。跟作用域链有点像，如果再自己的$scope里面没有，就一直往上找，一直到$rootScope为止。 可以用插件来看到$scope的树形结构。 $scope的生命周期首先是创建一个$scope，然后是注册一个监控，然后检测模型变化，然后观察模型，最后销毁（自动或手动）。","categories":[{"name":"WEB开发","slug":"WEB开发","permalink":"http://sevencai.github.io/categories/WEB开发/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://sevencai.github.io/tags/Angular/"}]}]}